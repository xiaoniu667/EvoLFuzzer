{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 2}, {"cost": [[0, 0, 0], [0, 0, 0], [0, 0, 0]], "m": 2, "n": 2}, {"cost": [[1]], "m": 0, "n": 0}, {"cost": [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]], "m": 2, "n": 2}, {"cost": [[999999999, 999999999, 999999999], [999999999, 999999999, 999999999], [999999999, 999999999, 999999999]], "m": 2, "n": 2}, {"cost": [[0]], "m": -1, "n": -1}, {"cost": [[1, 2], [3, 4]], "m": 5, "n": 5}, {"cost": [], "m": 0, "n": 0}, {"cost": [[1, 2, 3], [4, 5, 6]], "m": 1, "n": 2}, {"cost": [[1, 2], [3, 4], [5, 6]], "m": 2, "n": 1}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": [-172, 311, -467, 834, 540], "test_tup2": [225, 262, 508, 418, -87]}, {"test_tup1": [-613, 803, 1002, -479, -522], "test_tup2": [45, -361, 284, 257, 910]}, {"test_tup1": [875, 476, 784, -198, -288], "test_tup2": [556, 149, 327, -782, -474]}, {"test_tup1": [941, -163, -890, -286, 858], "test_tup2": [244, -116, 849, 607, -191]}, {"test_tup1": [50, 267, 385, 798, -593], "test_tup2": [-756, 236, 247, -675, 211]}, {"test_tup1": [563, 202, 791, -120, 784], "test_tup2": [-595, -124, -908, 812, -715]}, {"test_tup1": [34, 960, 245, 472, -145], "test_tup2": [-257, 720, -65, -688, -989]}, {"test_tup1": [183, -16, -190, -480, 191], "test_tup2": [-28, 565, 391, 299, -394]}, {"test_tup1": [345, 944, 396, -419, -246], "test_tup2": [649, 693, -258, 414, 3]}, {"test_tup1": [-72, -508, -67, 665, 808], "test_tup2": [-23, -536, -895, 235, -595]}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [-423, -58, -787, -48, 64, -666, -256, -582, 181, 973, 346]}, {"numbers": [633, 69, -502, -253, 579, 413, 182, 823, 980, -486, -298]}, {"numbers": [906, -97, -984, -105, 905, 572, -695, 964, -389, -656, -782]}, {"numbers": [-261, 944, -839, 982, -455, -119, 296, 955, 214, 622, -896]}, {"numbers": [867, -475, 268, -239, -84, 308, 499, -497, -179, 35, 422]}, {"numbers": [272, 765, -977, -337, 830, -607, 666, -518, 34, -837, -185]}, {"numbers": [-797, 813, 78, -850, 294, -936, 525, -982, 42, -376, 996]}, {"numbers": [-123, 723, -325, 188, 113, -639, 156, -824, 698, 671, 162]}, {"numbers": [932, -188, -48, -454, -848, -180, -872, 166, 454, 458, 374]}, {"numbers": [-1, -595, -869, 972, 905, 608, -10, 471, 157, -570, 205]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [-536, 435, 196, 661, 904], "k": -781}, {"numbers": [860, -52, 778, -757, -9], "k": -905}, {"numbers": [664, 419, -335, -712, 350], "k": -772}, {"numbers": [798, 794, -290, -844, -653], "k": -586}, {"numbers": [-139, 573, 873, 781, 532], "k": 533}, {"numbers": [585, -83, -26, -562, 748], "k": 130}, {"numbers": [655, -608, -135, -348, 6], "k": -673}, {"numbers": [-193, -923, 912, 445, 551], "k": 1001}, {"numbers": [-857, -979, 167, -801, -921], "k": -592}, {"numbers": [457, 417, -8, -428, -762], "k": 225}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": "0"}, {"n": "2"}, {"n": "4"}, {"n": "8"}, {"n": "1"}, {"n": "3"}, {"n": "-2"}, {"n": "100"}, {"n": "1000"}, {"n": "-100"}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": "0", "b": "0"}, {"a": "1", "b": "0"}, {"a": "3", "b": "1"}, {"a": "7", "b": "3"}, {"a": "15", "b": "7"}, {"a": "0", "b": "1"}, {"a": "0", "b": "2"}, {"a": "0", "b": "4"}, {"a": "0", "b": "8"}, {"a": "0", "b": "16"}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "jkhT irduonf pvetqmosue b xag we o czrhylo "}, {"text": "The quick bown fox jumps over the lazy dog"}, {"text": "r ud uh Tal smq yeotkon owxzbjhive ergfco p"}, {"text": "The quick brown fox jumps over the lazy dogz"}, {"text": "  p g  jurhebeqrto kocyi ofosawn dzmluTxvhe"}, {"text": "The quick brown fox jumps overthe lazy dog"}, {"text": " gmhnjbeudkworzecxeootfl    uypvq soTh ai r"}, {"text": "The quik brown fox jumps over the lazy dog"}, {"text": "The quick brown fox juKmps over the lazy dog"}, {"text": "The quick brown fox jumps over the lazy do"}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [523.5367759951228, 554.5050976730806, 773.9181092893496, 507.7826361918094, -571.8280383008805]}, {"numbers": [588.058382509807, -258.59204303614877, -203.31783073865859, 940.1840993253479, 912.1896239582334]}, {"numbers": [-440.06897743701086, 989.4740330397576, -337.5028492445872, -527.7779605214453, -687.9570739791361]}, {"numbers": [428.12050148987623, -308.8096229615252, -956.8595856252088, 947.5031432962808, 110.20136211827594]}, {"numbers": [-152.01365901844167, 992.519453373666, -839.0035757485975, -303.8660444868102, -667.1558051954839]}, {"numbers": [-604.6056484715231, 506.69599991131963, -521.9040134543559, 122.95338210481191, 545.0815715449705]}, {"numbers": [-168.56619641285147, 139.00057796731267, -129.0913168294229, 559.8926260139476, -661.0818715840593]}, {"numbers": [209.38593377644406, 613.5045855115122, -577.1905881514178, 825.2058330134121, 378.1789185095661]}, {"numbers": [823.471224728569, -671.4996884229263, -699.0188615058084, -987.6035710348918, -258.8254602632843]}, {"numbers": [-747.8234257256971, 406.97569725499443, -911.373981590802, -368.63189795617825, -149.78859712549206]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": "abcabco"}, {"s": "abcambc"}, {"s": "abccba"}, {"s": "acacbb"}, {"s": "ababc"}, {"s": "baccba"}, {"s": "abcabc1"}, {"s": "abcac"}, {"s": "ccaabb"}, {"s": "bacabc"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": "[]"}, {"dataset": "[1]"}, {"dataset": "[3, 1, 2]"}, {"dataset": "[5, 5, 5, 5, 5]"}, {"dataset": "[-10, -5, 0, 5, 10]"}, {"dataset": "[9223372036854775807, -9223372036854775808]"}, {"dataset": "[1.1, 2.2, 3.3]"}, {"dataset": "[\"a\", \"b\", \"c\"]"}, {"dataset": "[null, undefined]"}, {"dataset": "[[1, 2], [3, 4]]"}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "tqest_string", "char": "dt"}, {"s": "tst_string", "char": "t"}, {"s": "test_stEring", "char": "tX"}, {"s": "nsierg_tstt", "char": "t"}, {"s": "t_sgttirsne", "char": "ti"}, {"s": "sgnrttiste_", "char": "4t"}, {"s": "tseg_intrts", "char": "t6"}, {"s": "twest_string", "char": "t"}, {"s": "tet_string", "char": "t"}, {"s": "test_stringc", "char": "t"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}, {"matrix": "[]"}, {"matrix": "[[]]"}, {"matrix": "[[], [], []]"}, {"matrix": "[[1], [2], [3]]"}, {"matrix": "[[9223372036854775807, 9223372036854775807], [-9223372036854775808, -9223372036854775808]]"}, {"matrix": "[[0.1, 0.2, 0.3], [1.1, 1.2, 1.3]]"}, {"matrix": "[['a', 'b'], ['c', 'd']]"}, {"matrix": "[[None, None], [True, False]]"}, {"matrix": "[[[1, 2], [3, 4]], [[5, 6], [7, 8]]]"}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "cherry": 5}, "n": 2}, {"word_dict": {}, "n": 1}, {"word_dict": {"test": 1}, "n": 0}, {"word_dict": {"a": 10, "b": 10, "c": 10, "d": 9, "e": 8}, "n": 3}, {"word_dict": {"single": 100}, "n": 5}, {"word_dict": {"x": -5, "y": 0, "z": 10}, "n": 2}, {"word_dict": {"a": 1, "b": 1, "c": 1, "d": 1, "e": 1}, "n": 10}, {"word_dict": {"very_long_word_name_that_exceeds_normal_length_but_still_valid": 100, "short": 50}, "n": 1}, {"word_dict": {"null": 1, "empty": 1, "none": 1}, "n": -1}, {"word_dict": {"duplicate": 3}, "n": 1}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": [3.0, 4.0], "height": 5.0}, {"base_triangle": [0.0, 4.0], "height": 5.0}, {"base_triangle": [3.0, 0.0], "height": 5.0}, {"base_triangle": [0.0, 0.0], "height": 5.0}, {"base_triangle": [3.0, 4.0], "height": 0.0}, {"base_triangle": [-3.0, 4.0], "height": 5.0}, {"base_triangle": [3.0, -4.0], "height": 5.0}, {"base_triangle": [-3.0, -4.0], "height": 5.0}, {"base_triangle": [3.0, 4.0], "height": -5.0}, {"base_triangle": ["1.7976931348623157E+308", "1.7976931348623157E+308"], "height": "1.7976931348623157E+308"}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "HelloWorld"}, {"s": "hello"}, {"s": "HELLO"}, {"s": "a"}, {"s": "A"}, {"s": "TestCase1TestCase2"}, {"s": "HelloworldTest"}, {"s": "HelloWorldTest"}, {"s": "HelloWorldTestCase"}, {"s": "Helloworldtestcase"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": " l3dt1lxoehe2_aep_scr stlelewo_am"}, {"text": "hello_world tet_case example_123"}, {"text": "sltlmel_hdw12areoeas_ tx3pl_eoec "}, {"text": "hello_world test_caseexample_123"}, {"text": "sa3_leotcxhe1w_lolpdaer2 sem_t le"}, {"text": "hello_world testcase example_123"}, {"text": "hello_world testcase example_123"}, {"text": "heello_world test_case example_123"}, {"text": "mrltet __deasoehe2lal1se c3p_oxlw"}, {"text": "e_ hld_a_eemcaxp2o3ellltow1r stes"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": "5"}, {"side_length": "3.5"}, {"side_length": "0"}, {"side_length": "-1"}, {"side_length": "9999999999999999999999999999999999999999"}, {"side_length": "-9999999999999999999999999999999999999999"}, {"side_length": "1.7976931348623157e+308"}, {"side_length": "-1.7976931348623157e+308"}, {"side_length": "NaN"}, {"side_length": "Infinity"}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "hello", "str2": "lo"}, {"str1": "test123", "str2": "123"}, {"str1": "", "str2": "abc"}, {"str1": "abc", "str2": ""}, {"str1": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "str2": "a"}, {"str1": "xyz", "str2": "xyz"}, {"str1": "special!@#$%", "str2": "!@#$"}, {"str1": "unicodeñáé", "str2": "ñ"}, {"str1": "spaces here", "str2": " "}, {"str1": "mixed123!@#", "str2": "123!@"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5]}, {"nums": [1, 2, 3, 2, 4]}, {"nums": []}, {"nums": [1]}, {"nums": [1, 1]}, {"nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1]}, {"nums": [0, 0, 0, 0, 0]}, {"nums": [-1, 2, -1, 4]}, {"nums": [999999999, -999999999, 0, 999999999]}, {"nums": [1.5, 2.5, 1.5]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": 1}, {"n": 7}, {"n": 23}, {"n": 0}, {"n": -1}, {"n": -100}, {"n": 2147483647}, {"n": 9223372036854775807}, {"n": -9223372036854775808}, {"n": 9999999999999999999}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": 3, "m": 4}, {"n": 5, "m": 3}, {"n": 0, "m": 5}, {"n": -3, "m": 4}, {"n": 2147483647, "m": 2}, {"n": -2147483648, "m": 2}, {"n": 1, "m": 1000}, {"n": 1000000, "m": 1000}, {"n": 0, "m": 0}, {"n": 1, "m": -1}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [1, 2, 3, 2, 1]}, {"arr": []}, {"arr": [1]}, {"arr": [1, 1]}, {"arr": [null, null]}, {"arr": [1.1, 2.2, 1.1]}, {"arr": [9999999999, 9999999999]}, {"arr": [true, false, true]}, {"arr": ["a", "b", "a"]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6]]}, {"lists": [[-1, -2, -3], [-4, -5], [-6]]}, {"lists": [[], [], []]}, {"lists": [[0, 0, 0], [0], [0, 0]]}, {"lists": [[1000000, 1000000], [2000000], [3000000]]}, {"lists": [[1], [2], [3], [4], [5]]}, {"lists": [[-1000000, -1000000], [-2000000], [-3000000]]}, {"lists": [[1, 2], [3, 4, 5], [6, 7, 8, 9]]}, {"lists": [[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]]}, {"lists": [[], [1], []]}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "110"}, {"binary_str": "0101"}, {"binary_str": "110"}, {"binary_str": "1010"}, {"binary_str": "0011"}, {"binary_str": "1010D"}, {"binary_str": "101J0"}, {"binary_str": "1Q010"}, {"binary_str": "10w10"}, {"binary_str": "010"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [2, 2, 3, 3, 4, 4]}, {"arr": [1, 1, 1, 1, 1]}, {"arr": []}, {"arr": [0, 1, 2, 3, 4]}, {"arr": [1, 0, 2, 0, 3]}, {"arr": [-1, 2, -3, 4, -5]}, {"arr": [2147483647, -2147483648, 0]}, {"arr": [1, 2, 3, 2, 1, 4, 5, 4]}, {"arr": [1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{"tuple_list": "[]"}, {"tuple_list": "[()]"}, {"tuple_list": "[(1,)]"}, {"tuple_list": "[(1, 2)]"}, {"tuple_list": "[(1, 2, 3)]"}, {"tuple_list": "[(1,), (2, 3)]"}, {"tuple_list": "[(1, 2), (3,)]"}, {"tuple_list": "[(1, 2), (3, 4)]"}, {"tuple_list": "[(1, 2, 3), (4, 5, 6)]"}, {"tuple_list": "[('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')]"}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["a1b2c", "41d5e6f", "g7h8i29", "j0k1Pl2m3n4", "opqrstuvwxAyz", "2639451807", ")!^%*&(#@$", "Mixed123Input456Here7u89"]}, {"strings": ["1a3cb2", "4fe5d6", "g7h8Xi9", "j0k1l2m3n", "zxopwvutqrsy", "124567890", "!@#$A%^&*()", "ixed123Input456Here789"]}, {"strings": ["ab2c3", "4d5ef", "g7h8iY9", "l13nj2k0m4", "opqrstuvwxywz", "12345678990", "!x@#$%^&*()", "6e1euHpi4t3n2M75xe89drI"]}, {"strings": ["cb2a31", "ed4f56", "g7h89", "j014nk3ml2", "opqrtuvwxyz", "1p234567890", "^)!@#*(%&$", "nu6de5i1793pM2xtreIe8H4"]}, {"strings": ["b3c21a", "4d5ef", "g78i9", "0n143ljk2m", "upryvwzsqtxo", "12434567890", "!@#%^&*()", "Mixed123Input456Hre789"]}, {"strings": ["a1b23", "45e6f", "7gih98", "j0k1l2m3Kn4", "opqrstuvxyz", "2189036745", "&%*@!^)(#$", "MixedJ123Input456Here789"]}, {"strings": ["a1b2c", "46d5fe", "hgi897", "jf0k1l2m3n4", "vopsxrywuzqt", "124567890", "!@1#$%^&*()", "Mixed123Input456Herae789"]}, {"strings": ["3c1ba2", "4d5e6", "g7h8ik9", "j0k1l2m3no4", "szurptyvqoxw", "3015684972", "!#$%^&*()", "Mixed123Iput456Here789"]}, {"strings": ["321abc", "4d5e6", "i7hg98", "jv0k1l2m3n4", "oqrstuvwxyz", "123567890", "!@#$%^&()", "Mied123Input456Here789"]}, {"strings": ["a1b2c", "4d5e6", "g7h8i", "j0k12m3n4", "opqrsdtuvwxyz", "12345678c90", "!@#$%^&()", "e3exe8td294HM56n17rIiup"]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": "5", "k": "2"}, {"n": "0", "k": "0"}, {"n": "1", "k": "1"}, {"n": "10", "k": "5"}, {"n": "-1", "k": "2"}, {"n": "5", "k": "-1"}, {"n": "1000000", "k": "500000"}, {"n": "2147483647", "k": "1073741823"}, {"n": "999999999", "k": "999999999"}, {"n": "100", "k": "101"}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 3, 1, 3]}, {"arr": [5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5]}, {"arr": [0]}, {"arr": [1, 1, 1]}, {"arr": [2, 2, 2, 2, 2]}, {"arr": [-1, -1, -2]}, {"arr": [1.5, 1.5, 2.5]}, {"arr": [true, true, false]}, {"arr": ["a", "a", "b"]}, {"arr": [null, null, "test"]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "bc"}, {"s": "ac"}, {"s": "cab"}, {"s": "bca"}, {"s": "aXbc"}, {"s": "abCc"}, {"s": "bc"}, {"s": "abcI"}, {"s": "abcy"}, {"s": "ab"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": [[1, 2, 3]], "k": 1}, {"numbers": [[1, 1, 2], [2, 3, 3]], "k": 2}, {"numbers": [[1]], "k": 0}, {"numbers": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], "k": 5}, {"numbers": [[9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999]], "k": 1}, {"numbers": [[-1, -1, -2, -2, -3]], "k": 3}, {"numbers": [[], [], []], "k": 1}, {"numbers": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "k": 10}, {"numbers": [[1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10]], "k": -1}, {"numbers": [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], "k": 100}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"n": "2"}, {"n": "15"}, {"n": "100"}, {"n": "1"}, {"n": "0"}, {"n": "-1"}, {"n": "2147483647"}, {"n": "9223372036854775807"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "18446744073709551615"}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": "0"}, {"decimal_num": "1"}, {"decimal_num": "10"}, {"decimal_num": "-5"}, {"decimal_num": "2147483647"}, {"decimal_num": "-2147483648"}, {"decimal_num": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"decimal_num": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"decimal_num": "1.5"}, {"decimal_num": "abc"}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"}, {"arr": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 11]"}, {"arr": "[2, 3, 4, 5, 6, 7, 8, 9, 10, 12]"}, {"arr": "[]"}, {"arr": "[0]"}, {"arr": "[1]"}, {"arr": "[1, 3, 4, 5, 6, 7, 8, 9, 10, 11]"}, {"arr": "[0, 1, 2, 3, 4, 5, 6, 7, 8, 10]"}, {"arr": "[2, 3, 4, 6, 7, 8, 9, 10, 11, 12]"}, {"arr": "[0, 1, 2, 3, 4, 5, 6, 7, 9, 10]"}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 1}, {"n": 0}, {"n": -1}, {"n": 2147483647}, {"n": -2147483648}, {"n": 100}, {"n": 65535}, {"n": 1000000}, {"n": -100}, {"n": 999999999}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": "1"}, {"denominator": "1"}, {"n": "1"}, {"numerator": "0"}, {"denominator": "0"}, {"n": "0"}, {"numerator": "-1"}, {"denominator": "-1"}, {"n": "-1"}, {"numerator": "999999999"}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [925, "Yapple", -491, "abanan", -488, "cherryg"]}, {"mixed_list": [-799, "appcle", -481, "abnaan", -783, "rhrcye"]}, {"mixed_list": [-938, "pepal", 233, "bnnaaa", -913, "cherrGy"]}, {"mixed_list": [-516, "a8pple", -671, "Jbanana", -44, "herry"]}, {"mixed_list": [251, "ppela", 12, "aanabn", -93, "cyhrer"]}, {"mixed_list": [30, "bapple", -510, "bnanaa", -49, "cherr"]}, {"mixed_list": [520, "Bapple", 774, "anana", -118, "hyercr"]}, {"mixed_list": [983, "apelp", -451, "baWnana", 761, "chxerry"]}, {"mixed_list": [884, "pple", -95, "aaabnn", -74, "rechry"]}, {"mixed_list": [-881, "ppeal", 574, "bnanaa", -592, "yhercr"]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [2, 1]}, {"numbers": [4, 3, 6, 5]}, {"numbers": [10, 5, 8, 7]}, {"numbers": [100, 51]}, {"numbers": [0, 1]}, {"numbers": [2]}, {"numbers": [1]}, {"numbers": []}, {"numbers": [0, 0, 0, 0]}, {"numbers": [2, -1]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "aabbc"}, {"s": "7aabbcc"}, {"s": "aabbc"}, {"s": "aabbc"}, {"s": "aabbc"}, {"s": "aabcc"}, {"s": "aabcc"}, {"s": "aabbcac"}, {"s": "aabcc"}, {"s": "aabbc"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [2, 4, 6, 8, 10]}, {"numbers": [1, 3, 5, 7, 9]}, {"numbers": [0]}, {"numbers": [-2, -4, -6]}, {"numbers": [2147483647, -2147483648]}, {"numbers": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"numbers": [2, 3, 4, 5, 6]}, {"numbers": []}, {"numbers": [1000000000, 1000000002, 1000000004]}, {"numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [1, 1, 2, 2, 3, 3]}, {"arr": []}, {"arr": [5, 5, 5, 5, 5]}, {"arr": [0, 0, 0, 0, 0]}, {"arr": [-1, -1, 1, 1, 2, 2]}, {"arr": [999999999, 999999999, -999999999, -999999999]}, {"arr": [1, 2, 3, 1, 2, 3, 1, 2, 3]}, {"arr": [0]}, {"arr": [2147483647, 2147483647, -2147483648, -2147483648]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world test_ase example_input"}, {"text": "eelpuoil_a xdltt_hsm eswcelerp_noat"}, {"text": "otxlnuptled_slea_it perlem _cohswea"}, {"text": "isp_sro xdtleapo cnllwtaulh_tm_eeee"}, {"text": "mcept_eeedhwxaiotl_u _tlseolrlsanp "}, {"text": "eatlaoens r_hciow_tedt melpsle_lpxu"}, {"text": "hello_world test_case example_iput"}, {"text": "hello_world test_casez example_input"}, {"text": "hello_world test_case example_inut"}, {"text": "hello_world test_Ccase example_input"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "tset", "string": "sesectat "}, {"word": "tiest", "string": "tet case"}, {"word": "estt", "string": "test cse"}, {"word": "tst", "string": "tst case"}, {"word": "teskt", "string": " eceattss"}, {"word": "testo", "string": "sae tcets"}, {"word": "test", "string": "test casXe"}, {"word": "tes3t", "string": "test ca1se"}, {"word": "tets", "string": "test cas"}, {"word": "tst", "string": "Ltest case"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24]}, {"numbers": [7, 13, 29]}, {"numbers": [0, 5, 10]}, {"numbers": [-12, 18, -24]}, {"numbers": [1]}, {"numbers": []}, {"numbers": [2147483647, 2147483647]}, {"numbers": [-2147483648, -2147483648]}, {"numbers": [0, 0, 0]}, {"numbers": [1, 0, 1]}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}, {"numbers": [1, 1, 2, 3, 4]}, {"numbers": []}, {"numbers": [1]}, {"numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]}, {"numbers": [1, 2, 3, 4, 5, 5, 5, 5, 5, 5]}, {"numbers": [1.1, 2.2, 3.3, 4.4, 5.5]}, {"numbers": [1.1, 1.1, 2.2, 3.3]}, {"numbers": [0, 0, 0, 0, 0]}, {"numbers": [-1, -2, -3, -4, -5]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"a": 5, "b": 10}, {"a": 1, "b": 1}, {"a": 10, "b": 5}, {"a": 0, "b": 5}, {"a": -5, "b": -1}, {"a": 100, "b": 105}, {"a": 999999999, "b": 1000000000}, {"a": 0, "b": 0}, {"a": -10, "b": -5}, {"a": 95, "b": 100}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "255"}, {"n": "2147483647"}, {"n": "4294967295"}, {"n": "-1"}, {"n": "-2147483648"}, {"n": "9223372036854775807"}, {"n": "18446744073709551615"}, {"n": "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": "[[1, 2], [3, 4]]"}, {"matrix": "[]"}, {"matrix": "[[], [1, 2], []]"}, {"matrix": "[[1], [2, 3], [4, 5, 6]]"}, {"matrix": "[[1]]"}, {"matrix": "[[1, 2, 3], [4, 5], [6]]"}, {"matrix": "[[null], [null, null]]"}, {"matrix": "[[1], [2], [3], [4], [5], [6], [7], [8], [9], [10]]"}, {"matrix": "[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]"}, {"matrix": "[[1], []]"}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": []}, {"lists": [[1, 2], [3, 4, 5], [6]]}, {"lists": [[], [1], [2, 3]]}, {"lists": [[1]]}, {"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9]]}, {"lists": [[], [], []]}, {"lists": [[1, 2, 3, 4, 5]]}, {"lists": [[1], [2], [3], [4], [5]]}, {"lists": [[], [1, 2]]}, {"lists": [[1, 2], [], [3, 4, 5]]}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": "1", "side2": "1", "side3": "1"}, {"side1": "0", "side2": "0", "side3": "0"}, {"side1": "-1", "side2": "-1", "side3": "-1"}, {"side1": "9999999999999999999999999999999999999999", "side2": "9999999999999999999999999999999999999999", "side3": "9999999999999999999999999999999999999999"}, {"side1": "1.1", "side2": "1.1", "side3": "1.1"}, {"side1": "A", "side2": "A", "side3": "A"}, {"side1": "", "side2": "", "side3": ""}, {"side1": "null", "side2": "null", "side3": "null"}, {"side1": "1", "side2": "1", "side3": "2"}, {"side1": "0.0000000000000000000000000000000000000001", "side2": "0.0000000000000000000000000000000000000001", "side3": "0.0000000000000000000000000000000000000001"}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": 5.0, "height": 3.0}, {"base": 0.0, "height": 10.0}, {"base": -5.0, "height": 3.0}, {"base": "1.7976931348623157E+308", "height": "1.7976931348623157E+308"}, {"base": "-1.7976931348623157E+308", "height": "-1.7976931348623157E+308"}, {"base": 0.0, "height": 0.0}, {"base": "10", "height": 5.0}, {"base": 5.0, "height": "3"}, {"base": null, "height": 5.0}, {"base": 5.0, "height": null}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "cearrac"}, {"s": "rcaecar"}, {"s": "craacer"}, {"s": "racecar1"}, {"s": "racear"}, {"s": "racrecar"}, {"s": "eacrrca"}, {"s": "racecarj"}, {"s": "crreaca"}, {"s": "aerccra"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": []}, {"arr": [5, 5, 5, 5, 5]}, {"arr": [-10, -5, 0, 5, 10]}, {"arr": [1000000, -1000000]}, {"arr": [0]}, {"arr": [1, 3, 2, 3, 1]}, {"arr": [2147483647, -2147483648]}, {"arr": [1, 2, 1, 2, 1, 2]}, {"arr": [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": "1"}, {"r": "2"}, {"n": "3"}, {"a": "0", "r": "5", "n": "10"}, {"a": "-1", "r": "2", "n": "5"}, {"a": "1", "r": "0", "n": "0"}, {"a": "9223372036854775807", "r": "2", "n": "100"}, {"a": "1", "r": "-2", "n": "100"}, {"a": "1", "r": "0.5", "n": "1000"}, {"a": "1", "r": "1", "n": "1000000"}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"n": "123"}, {"n": "0"}, {"n": "1"}, {"n": "99999999999999999999"}, {"n": "-1"}, {"n": "abc"}, {"n": "123.456"}, {"n": "18446744073709551615"}, {"n": "null"}, {"n": "2147483647"}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [3, 30, 34, 5, 9]}, {"digits": [0, 0, 0, 0]}, {"digits": [1, 2, 3, 4, 5, 6, 7, 8, 9]}, {"digits": [9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9]}, {"digits": [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]}, {"digits": [999, 998, 997, 996, 995, 994, 993, 992, 991, 990]}, {"digits": [123456789, 987654321, 111111111, 222222222, 333333333, 444444444, 555555555, 666666666, 777777777, 888888888, 999999999]}, {"digits": []}, {"digits": [0]}, {"digits": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"a": "0", "b": "0"}, {"a": "1", "b": "1"}, {"a": "-1", "b": "-1"}, {"a": "2147483647", "b": "-2147483648"}, {"a": "-1", "b": "1"}, {"a": "0", "b": "-1"}, {"a": "0", "b": "1"}, {"a": "9223372036854775807", "b": "-9223372036854775808"}, {"a": "18446744073709551615", "b": "0"}, {"a": "-9223372036854775809", "b": "9223372036854775808"}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "2"}, {"n": "-1"}, {"n": "-2147483648"}, {"n": "2147483647"}, {"n": "9999999999999999999999999999999999999999"}, {"n": "-9999999999999999999999999999999999999999"}, {"n": "0.5"}, {"n": "test"}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": []}, {"arr": [1]}, {"arr": [1, 2, 3, 4, 5]}, {"arr": [1, 1, 1, 1, 1]}, {"arr": [1, 2, 2, 3, 3, 3, 4]}, {"arr": [null]}, {"arr": [1, null, 2]}, {"arr": [9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999]}, {"arr": [1.1, 2.2, 3.3]}, {"arr": ["a", "b", "c", "c", "d"]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "11"}, {"s": "01"}, {"s": "e101"}, {"s": "110"}, {"s": "01"}, {"s": "11"}, {"s": "2101"}, {"s": "101N"}, {"s": "011"}, {"s": "1V01"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}, {"numbers": [5, 4, 3, 2, 1]}, {"numbers": [1]}, {"numbers": []}, {"numbers": [1, 1, 1, 1]}, {"numbers": [-1, -2, -3, -4]}, {"numbers": [9999999999, -9999999999]}, {"numbers": [0, 0, 0, 0]}, {"numbers": [1.5, 2.7, 0.3]}, {"numbers": [1, "2", 3]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": "[[1, 2], [3, 4]]"}, {"pairs": "[[0, 0], [0, 0]]"}, {"pairs": "[[-10, -20], [30, 40]]"}, {"pairs": "[[1000000, 2000000], [-1000000, -2000000]]"}, {"pairs": "[[1, 1]]"}, {"pairs": "[]"}, {"pairs": "[[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]]"}, {"pairs": "[[9223372036854775807, 9223372036854775807], [-9223372036854775808, -9223372036854775808]]"}, {"pairs": "[[1.5, 2.5], [3.7, 4.9]]"}, {"pairs": "[[\"1\", \"2\"], [\"3\", \"4\"]]"}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{"tuples_list": "[]", "sort_index": "null", "reverse": "false"}, {"tuples_list": "[[1, 2], [3, 1], [2, 3]]", "sort_index": "0", "reverse": "false"}, {"tuples_list": "[[1, 2], [3, 1], [2, 3]]", "sort_index": "1", "reverse": "true"}, {"tuples_list": "[[5]]", "sort_index": "null", "reverse": "false"}, {"tuples_list": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "sort_index": "2", "reverse": "false"}, {"tuples_list": "[[1, 2], [3, 4]]", "sort_index": "5", "reverse": "false"}, {"tuples_list": "[[1, 2], [3, 4]]", "sort_index": "-1", "reverse": "false"}, {"tuples_list": "[[9223372036854775807, -9223372036854775808], [0, 0]]", "sort_index": "0", "reverse": "false"}, {"tuples_list": "[[]]", "sort_index": "0", "reverse": "false"}, {"tuples_list": "[[null, 1], [2, null]]", "sort_index": "0", "reverse": "false"}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [-130, [714, 644], [-934, [-181, -697]], -794]}, {"lst": [-101, [-367, -606], [-21, [712, -502]], -224]}, {"lst": [653, [-102, 770], [-49, [549, 600]], -58]}, {"lst": [-14, [83, 546], [-703, [-803, -835]], 809]}, {"lst": [859, [400, 20], [-724, [-549, 590]], 100]}, {"lst": [914, [718, -106], [102, [610, 239]], 389]}, {"lst": [217, [944, 736], [5, [-854, 186]], -578]}, {"lst": [-557, [531, -176], [602, [519, -947]], -833]}, {"lst": [-796, [-714, 347], [-211, [922, -840]], -910]}, {"lst": [-963, [411, -786], [-140, [-648, -526]], -205]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}, {"numbers": [-1, -2, -3, -4, -5]}, {"numbers": [0, 0, 0, 0, 0]}, {"numbers": [1, -1, 2, -2, 3, -3]}, {"numbers": [999999999999999999999999999999]}, {"numbers": [-999999999999999999999999999999]}, {"numbers": [0.1, 1e-30]}, {"numbers": [-0.1, -1e-30]}, {"numbers": [1, "2", 3]}, {"numbers": []}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "5"}, {"n": "-1"}, {"n": "999"}, {"n": "1000"}, {"n": "-999"}, {"n": "-1000"}, {"n": "2147483647"}, {"n": "-2147483648"}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [5, 4, 3, 2, 1]}, {"arr": [1, 1, 1, 1, 1]}, {"arr": [1, 3, 2, 4, 5]}, {"arr": []}, {"arr": [1]}, {"arr": [1, 2, 2, 3, 4]}, {"arr": [5, 5, 3, 2, 1]}, {"arr": [1, 2, 3, 2, 1]}, {"arr": [1, 2147483647, -2147483648]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": "[]", "sublist": "[]"}, {"main_list": "[1, 2, 3]", "sublist": "[2, 3]"}, {"main_list": "[1, 2, 3, 4, 5]", "sublist": "[3, 4, 5]"}, {"main_list": "[1]", "sublist": "[1]"}, {"main_list": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "sublist": "[6, 7, 8]"}, {"main_list": "[1, 2, 3]", "sublist": "[4, 5]"}, {"main_list": "[]", "sublist": "[1]"}, {"main_list": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]", "sublist": "[15, 16, 17, 18, 19, 20]"}, {"main_list": "[1, 2]", "sublist": "[1, 2, 3]"}, {"main_list": "[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]", "sublist": "[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]"}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [5, 4, 3, 2, 1]}, {"arr": [1]}, {"arr": []}, {"arr": [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}, {"arr": [-1, -2, -3, -4, -5]}, {"arr": [2147483647, -2147483648, 0]}, {"arr": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"arr": [999999999, 999999999, 999999999, 999999999, 999999999]}, {"arr": [1, 3, 2, 4, 6, 5, 8, 7, 9, 10]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "2"}, {"n": "3"}, {"n": "4"}, {"n": "5"}, {"n": "8"}, {"n": "10"}, {"n": "12"}, {"n": "-1"}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "hello world", "delimiters": [" ", ","]}, {"text": "a,b,c", "delimiters": [","]}, {"text": "test1;test2;test3", "delimiters": [";"]}, {"text": "", "delimiters": [" ", ",", ";"]}, {"text": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", "delimiters": ["x"]}, {"text": "a.b.c", "delimiters": ["."]}, {"text": "hello|world|test", "delimiters": ["|"]}, {"text": "test", "delimiters": []}, {"text": "complex$split#example", "delimiters": ["$", "#"]}, {"text": "another example", "delimiters": [" ", "x", "y", "z"]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": "abc", "patterns": ["xyz"]}, {"sequence": "aaa", "patterns": ["xxx"]}, {"sequence": "abc", "patterns": ["aba"]}, {"sequence": "", "patterns": [""]}, {"sequence": "a", "patterns": ["x", "y", "z"]}, {"sequence": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", "patterns": ["yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"]}, {"sequence": "abc", "patterns": []}, {"sequence": "abc", "patterns": ["abc", "def", "xyz"]}, {"sequence": "112233", "patterns": ["aabbcc", "abcabc"]}, {"sequence": "abab", "patterns": ["cdcd", "cdec"]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{"tuple_list": [[2, 4, 6], [3, 6, 9], [1, 2, 3]], "k": 2}, {"tuple_list": [[0, 0, 0], [10, 20, 30], [7, 14, 21]], "k": 5}, {"tuple_list": [], "k": 3}, {"tuple_list": [[1, 2, 3]], "k": 0}, {"tuple_list": [[-4, -8, -12], [5, 10, 15]], "k": -2}, {"tuple_list": [[1.5, 3.0, 4.5]], "k": 1}, {"tuple_list": [["a", "b", "c"], [1, 2, 3]], "k": 1}, {"tuple_list": [[999999999999999999, 999999999999999998]], "k": 1}, {"tuple_list": [[], [1, 2], [3, 4, 5]], "k": 2}, {"tuple_list": [[1], [2], [3], [4], [5], [6], [7], [8], [9], [10]], "k": 1}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": "5", "width": "3"}, {"length": "0", "width": "10"}, {"length": "10", "width": "0"}, {"length": "0", "width": "0"}, {"length": "1", "width": "1"}, {"length": "999", "width": "1"}, {"length": "1", "width": "999"}, {"length": "-5", "width": "3"}, {"length": "5", "width": "-3"}, {"length": "-1", "width": "-1"}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": 1234567532}, {"num": 1234568184}, {"num": 1234567678}, {"num": 1234568034}, {"num": 1234567828}, {"num": 1234567210}, {"num": 1234568541}, {"num": 1234568137}, {"num": 1234568259}, {"num": 1234567369}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "5"}, {"n": "10"}, {"n": "100"}, {"n": "-1"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "1000"}, {"n": "1001"}, {"n": "2147483647"}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "etst"}, {"word": "test2"}, {"word": "tst"}, {"word": "tiest"}, {"word": "tes"}, {"word": "tJest"}, {"word": "tesut"}, {"word": "tst"}, {"word": "Stest"}, {"word": "stte"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "5"}, {"n": "100"}, {"n": "-1"}, {"n": "2147483647"}, {"n": "-2147483648"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "abc"}, {"n": "3.14"}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{"tuple1": "()", "tuple2": "()"}, {"tuple1": "(1, 2, 3)", "tuple2": "('a', 'b', 'c')"}, {"tuple1": "(1,)", "tuple2": "('a', 'b')"}, {"tuple1": "(1, 2)", "tuple2": "('a',)"}, {"tuple1": "('x' * 1000,)", "tuple2": "('y' * 1000,)"}, {"tuple1": "(None,)", "tuple2": "(None,)"}, {"tuple1": "([],)", "tuple2": "({},)"}, {"tuple1": "(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)", "tuple2": "('a',)"}, {"tuple1": "(1,)", "tuple2": "('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j')"}, {"tuple1": "(1, 2, 3, 4, 5)", "tuple2": "('a', 'b', 'c', 'd', 'e')"}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": "1.0"}, {"radius": "0.0"}, {"radius": "-1.0"}, {"radius": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"radius": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"radius": "0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"}, {"radius": "NaN"}, {"radius": "Infinity"}, {"radius": "-Infinity"}, {"radius": "1.7976931348623157e+308"}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "cba"}, {"s": "ab"}, {"s": "ab"}, {"s": "acb"}, {"s": "cba"}, {"s": "ac"}, {"s": "ac"}, {"s": "ac"}, {"s": "acb"}, {"s": "ab"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": "1"}, {"n": "2"}, {"n": "5"}, {"n": "10"}, {"n": "0"}, {"n": "-1"}, {"n": "1000"}, {"n": "999"}, {"n": "1000000"}, {"n": "2147483647"}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": "1.0"}, {"radius": "0.0"}, {"radius": "-1.0"}, {"radius": "999999999.0"}, {"radius": "-999999999.0"}, {"radius": "0.0000000001"}, {"radius": "NaN"}, {"radius": "Infinity"}, {"radius": "-Infinity"}, {"radius": "1.7976931348623157e+308"}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"n": "1"}, {"n": "2"}, {"n": "0"}, {"n": "-1"}, {"n": "-100"}, {"n": "999999999"}, {"n": "-999999999"}, {"n": "1000000000"}, {"n": "2147483647"}, {"n": "-2147483648"}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": {"a": -17}, "dict2": {"b": 2}, "dict3": {"c": 3, "SsjMX": "OgLGcm"}}, {"dict1": {"a": 1}, "dict2": {"b": 2}, "dict3": {"c": 3}}, {"dict1": {"a": 1, "goA5C": "4ZIzeQ1u6"}, "dict2": {"b": 2, "eUfEl": "Rn17DHTtrCP"}, "dict3": {"c": 3, "oHEoakeoJxng": "pwloWrcmIIVt3EG"}}, {"dict1": {"a": 1}, "dict2": {"bK": 2}, "dict3": {"c": 3}}, {"dict1": {"a": 1, "WUSBq": "NxS"}, "dict2": {"b": 2, "7Qg52enLjmAnqSF": "rIckmL7GN3raBHsb"}, "dict3": {"c": 3}}, {"dict1": {"a": -832}, "dict2": {"b": 2}, "dict3": {"c": 872}}, {"dict1": {"a": 1}, "dict2": {"b": 2}, "dict3": {"c": 3, "l": "coJaGoZb9zPNTq6r"}}, {"dict1": {"a": 1}, "dict2": {"b": -603}, "dict3": {"c": 3, "7h6C9VxjVv": "SEqeQ"}}, {"dict1": {"a": -757}, "dict2": {"b": 2}, "dict3": {"c": 3, "cXTCmiBzLG6e": "zZb5Jhv2hfGWBFVH9"}}, {"dict1": {"a": 1, "33w36OESE1Hq9odgE4": "asHVZsVqDzt3Vh0V7"}, "dict2": {"b": 2}, "dict3": {"c": -406}}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": [374, -651, -634, 882, -344, -477, -482, 164, 294, -405]}, {"elements": [358, -390, 842, 968, -619, 128, -205, -345, -881, 33]}, {"elements": [-511, 551, -609, 170, 804, 687, 910, -217, 560, 487]}, {"elements": [841, 812, -969, 389, 417, -376, -496, -43, -505, -406]}, {"elements": [-370, 208, 922, -280, 86, 837, -422, -260, -445, -495]}, {"elements": [-694, 4, -513, 132, 178, 140, 260, 691, -879, 548]}, {"elements": [25, -226, 265, 65, 571, -764, 780, -588, 11, 22]}, {"elements": [-654, 103, 900, -104, -651, 403, -597, 622, 611, -613]}, {"elements": [-647, -458, -448, 948, 960, -679, 434, 725, 510, 807]}, {"elements": [961, -304, 463, -18, 776, 261, -307, -265, -404, 452]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": "1234"}, {"n": "4321"}, {"n": "1000"}, {"n": "9999"}, {"n": "0"}, {"n": "-5"}, {"n": "10"}, {"n": "21"}, {"n": "221"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "b ihlauvyxroTfj dzhmenu o os weqp toegr kc "}, {"sentence": "The quick brown fox jumps over the ulazy dog"}, {"sentence": "uhqy  eocvjegi bz rfdh aotpelxmn owr T osuk"}, {"sentence": "The quick brown fx jumps over the lazy dog"}, {"sentence": " inoxa e fTpre  ywoezubu lsgthc okhojdmvrq "}, {"sentence": "rureme d ooqkhl xj wi t oyscbgvuThe azp fno"}, {"sentence": "The quick brownfox jumps over the lazy dog"}, {"sentence": "The quick brown fox jmps over the lazy dog"}, {"sentence": "The quick brown fox jupmps over the lazy dog"}, {"sentence": "The uick brown fox jumps over the lazy dog"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"substring": "test"}, {"substring": ""}, {"substring": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"}, {"substring": "a"}, {"substring": "test123"}, {"substring": "!@#$%^&*()"}, {"substring": "test\\ntest"}, {"substring": "test'test"}, {"substring": "test\"test"}, {"substring": "test test"}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"n": 121}, {"n": 1313}, {"n": 123}, {"n": 0}, {"n": 99}, {"n": 100}, {"n": 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999}, {"n": -1}, {"n": -121}, {"n": 1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": "2"}, {"a": "0"}, {"a": "-1"}, {"a": "1000000000"}, {"a": "0.5"}, {"a": "-1000000000"}, {"a": "1"}, {"a": "999999999"}, {"a": "0.00000000000000000000000000000000000000000000000001"}, {"a": "-999999999"}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": "[1, 2, 3, 4, 5]"}, {"records": "[-5, -3, -1, 0, 2]"}, {"records": "[0]"}, {"records": "[5, 4, 3, 2, 1]"}, {"records": "[1, 1, 1, 1, 1]"}, {"records": "[]"}, {"records": "[9223372036854775807, -9223372036854775808]"}, {"records": "[null, 1, 2]"}, {"records": "[\"a\", \"b\", \"c\"]"}, {"records": "[1.5, 2.3, 0.7]"}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5], "target": 10}, {"nums": [1, 4, 4], "target": 4}, {"nums": [1, 1, 1, 1, 1, 1, 1, 1], "target": 7}, {"nums": [10], "target": 10}, {"nums": [1, 2, 3, 4, 5], "target": 100}, {"nums": [], "target": 5}, {"nums": [5, 1, 3, 5, 10, 7, 4, 9, 2, 8], "target": 15}, {"nums": [0, 0, 0, 0, 0], "target": 1}, {"nums": [-1, -2, -3, 10, -4], "target": 6}, {"nums": [1, 2, 3, 4, 5], "target": -5}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": "1"}, {"n": "0"}, {"n": "-1"}, {"n": "2147483647"}, {"n": "9223372036854775807"}, {"n": "2.5"}, {"n": "1.7976931348623158e+308"}, {"n": "NaN"}, {"n": "Infinity"}, {"n": "-Infinity"}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": [["x", "oy", "z"], ["Jy", "z4", "uw"], ["zq", "w", "vp"]]}, {"lst": [["x", "dy", "z"], ["Cy", "ez", "wh"], ["z", "Xw", "v"]]}, {"lst": [["x0", "y", "z"], ["3y", "z", "w"], ["z", "w", "v"]]}, {"lst": [["x", "y", "zs"], ["y", "2z", "wy"], ["zR", "w", "v"]]}, {"lst": [["x", "y", "z"], ["ya", "z", "wa"], ["z", "mw", "v"]]}, {"lst": [["x", "Gy", "z"], ["y", "z", "Lw"], ["z", "w", "v"]]}, {"lst": [["x", "y", "z"], ["y", "z", "w"], ["xz", "Fw", "pv"]]}, {"lst": [["6x", "qy", "z"], ["y", "zq", "wf"], ["z", "w", "v"]]}, {"lst": [["x", "y", "zz"], ["y", "Uz", "dw"], ["z", "w", "v5"]]}, {"lst": [["x", "y", "z"], ["y", "z", "w"], ["z", "w", "vR"]]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [1, 2, 3]}, {"numbers": [0]}, {"numbers": [1, 0, 3]}, {"numbers": [-1, -2, -3]}, {"numbers": [1, -1, 2, -2]}, {"numbers": [1000000, 1000000, 1000000]}, {"numbers": [0.1, 0.1, 0.1]}, {"numbers": [1]}, {"numbers": []}, {"numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": "0"}, {"decimal_num": "1"}, {"decimal_num": "10"}, {"decimal_num": "-5"}, {"decimal_num": "2147483647"}, {"decimal_num": "-2147483648"}, {"decimal_num": "9999999999999999999999999999999999999999"}, {"decimal_num": "-9999999999999999999999999999999999999999"}, {"decimal_num": "18446744073709551615"}, {"decimal_num": "null"}]}
{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": [[0]], "m": 0, "n": 0}, {"cost": [[1, 2], [3, 4]], "m": 1, "n": 1}, {"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 2}, {"cost": [[0, 0, 0], [0, 0, 0], [0, 0, 0]], "m": 2, "n": 2}, {"cost": [[999, 999], [999, 999]], "m": 1, "n": 1}, {"cost": [[1]], "m": -1, "n": 0}, {"cost": [[1]], "m": 0, "n": -1}, {"cost": [[1, 2], [3, 4]], "m": 5, "n": 5}, {"cost": [], "m": 0, "n": 0}, {"cost": [[1]], "m": 1000, "n": 1000}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": "()", "test_tup2": "()"}, {"test_tup1": "(1, 2, 3)", "test_tup2": "(2, 3, 4)"}, {"test_tup1": "(1, 1, 1)", "test_tup2": "(1, 2, 3)"}, {"test_tup1": "('a', 'b', 'c')", "test_tup2": "('x', 'y', 'z')"}, {"test_tup1": "(1, 2, 3, 4, 5)", "test_tup2": "(3, 4, 5, 6, 7)"}, {"test_tup1": "(None, True, False)", "test_tup2": "(True, 0, 1)"}, {"test_tup1": "([1, 2], {'a': 1})", "test_tup2": "([1, 2], {'b': 2})"}, {"test_tup1": "(1.1, 2.2, 3.3)", "test_tup2": "(2.2, 3.3, 4.4)"}, {"test_tup1": "(1,)", "test_tup2": "(1,)"}, {"test_tup1": "(999999999999999999999, 'x' * 100)", "test_tup2": "('x' * 100, 'y' * 100)"}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [2, 3, 5, 7, 11]}, {"numbers": [4, 6, 8, 9, 10]}, {"numbers": [1, 0, -1, -5, -10]}, {"numbers": [999983, 999979, 999961, 999959, 999953]}, {"numbers": [2147483647, 2147483646, 2147483645, 2147483644, 2147483643]}, {"numbers": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]}, {"numbers": [100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]}, {"numbers": []}, {"numbers": [1.5, 2.7, 3.14, 4.99, 5.0]}, {"numbers": [999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}, {"numbers": []}, {"numbers": [5]}, {"numbers": [-1, -2, -3, -4, -5]}, {"numbers": [1, 1, 1, 1, 1]}, {"numbers": [2147483647, -2147483648, 0]}, {"numbers": [1.5, 2.5, 3.5]}, {"numbers": [999999999999999999, -999999999999999999]}, {"numbers": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"numbers": [1, "2", 3]}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": "2"}, {"n": "4"}, {"n": "6"}, {"n": "0"}, {"n": "-2"}, {"n": "100"}, {"n": "999"}, {"n": "1"}, {"n": "3"}, {"n": "-1"}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": "0", "b": "0"}, {"a": "1", "b": "0"}, {"a": "3", "b": "1"}, {"a": "7", "b": "3"}, {"a": "15", "b": "7"}, {"a": "255", "b": "127"}, {"a": "2147483647", "b": "2147483646"}, {"a": "0", "b": "1"}, {"a": "18446744073709551615", "b": "18446744073709551614"}, {"a": "4294967295", "b": "4294967294"}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "The quick brown fox jumps ovr the lazy dog"}, {"text": "The quick brown fox jumps over the lzy dog"}, {"text": "The quick brown fox jumps over the slazy dog"}, {"text": "The quick brown fox jumps over the lazy dogt"}, {"text": "nui wgxu c mfepkq y oer oezjTbhodl a trhvso"}, {"text": "lo hxd ofmpotresjwo nbruz yuehiqeTg ka v c "}, {"text": "rlj  sukcTv rzfxo d yaeot qghbmen opihw eou"}, {"text": "The quick brown fox jumps over 0the lazy dog"}, {"text": "The quick brown fox jumps ojver the lazy dog"}, {"text": " yhs keTo deahzum qbglouprjw onf iectvxr o "}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [944.4934051267251, -654.3174283399671, 371.6423489795743, -548.3839350965841, 139.28846737387676]}, {"numbers": [-372.38164518090116, -832.2784102609626, 952.1841636119095, 426.44832306450735, 485.6756379810747]}, {"numbers": [725.7918581613094, 879.2562305878439, -422.6783744471719, 459.3658422884689, 572.9136519735218]}, {"numbers": [368.84344581411096, 175.30309302115165, -698.7177673760787, -883.7245785112038, -390.6097363078379]}, {"numbers": [-94.60996331073613, 208.3109908128738, 525.9017962907587, 994.2189293289136, -416.79844816958246]}, {"numbers": [-583.7656316808491, -460.3475810419992, -412.97221178812083, -62.22464784651913, 523.7486596242568]}, {"numbers": [287.4388677789225, -924.7056541772438, 538.4865960525426, 357.166495139468, 466.74371356128995]}, {"numbers": [198.2053835527836, 279.5177634834142, -551.1358661381284, -815.5903572830828, -477.62115824312616]}, {"numbers": [-699.1599931385338, -37.57822834812828, -674.2427250778815, -13.386882806540484, 542.8114390380388]}, {"numbers": [767.1391268328882, 191.76067784927955, 933.9951260403327, -569.4722207637866, -115.72183874048608]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": "aTbab"}, {"s": "baba"}, {"s": "aabb"}, {"s": "abba"}, {"s": "aba"}, {"s": "bab"}, {"s": "abyab"}, {"s": "aabb"}, {"s": "baab"}, {"s": "aba"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": "[1, 2, 3]"}, {"dataset": "[]"}, {"dataset": "[5]"}, {"dataset": "[3, 1, 4, 1, 5, 9, 2, 6]"}, {"dataset": "[9223372036854775807, -9223372036854775808]"}, {"dataset": "[1.1, 2.2, 3.3]"}, {"dataset": "[\"a\", \"b\", \"c\"]"}, {"dataset": "[null, null]"}, {"dataset": "[{}, {}]"}, {"dataset": "[[], []]"}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "terst_string", "char": "t"}, {"s": "test_tring", "char": "t"}, {"s": "jtest_string", "char": "tf"}, {"s": "test_tring", "char": "t"}, {"s": "test_strinpg", "char": "t"}, {"s": "_retstngsit", "char": "t"}, {"s": "tet_string", "char": "t"}, {"s": "teststring", "char": "ot"}, {"s": "isntg_trtes", "char": "t"}, {"s": "tst_string", "char": "t"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}, {"matrix": "[[0, 0, 0], [0, 0, 0], [0, 0, 0]]"}, {"matrix": "[[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]"}, {"matrix": "[[999999999999999999, 999999999999999999], [1, 2]]"}, {"matrix": "[[], [], []]"}, {"matrix": "[[1], [1, 2], [1, 2, 3]]"}, {"matrix": "[[9223372036854775807, 9223372036854775807], [-9223372036854775808, -9223372036854775808]]"}, {"matrix": "[[1.5, 2.5, 3.5], [0.1, 0.2, 0.3]]"}, {"matrix": "[[\"1\", \"2\", \"3\"], [\"4\", \"5\", \"6\"]]"}, {"matrix": "[[None, None], [True, False], [1, 2]]"}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "date": 2}, "n": 496}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2, "X15w7TzzYtDaNi6": "FY0F19gMP61IeDPRCIk"}, "n": -819}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2, "F5FxzmR6ASro5pEz": "qAV6wPbltVSwm8"}, "n": -876}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5}, "n": -851}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5}, "n": -669}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2, "4ZUzdt": "7ygp24M"}, "n": 833}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5}, "n": -301}, {"word_dict": {"apple": 5, "cherry": 5, "date": 2, "bnnaaa": 3}, "n": -49}, {"word_dict": {"banana": 3, "cherry": 5, "date": 2}, "n": -664}, {"word_dict": {"apple": 784, "banana": 3, "cherry": 5, "date": 2}, "n": -151}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": [3.0, 4.0], "height": 5.0}, {"base_triangle": [0.0, 4.0], "height": 5.0}, {"base_triangle": [3.0, 0.0], "height": 5.0}, {"base_triangle": [0.0, 0.0], "height": 5.0}, {"base_triangle": [3.0, 4.0], "height": 0.0}, {"base_triangle": [-3.0, 4.0], "height": 5.0}, {"base_triangle": [3.0, -4.0], "height": 5.0}, {"base_triangle": [-3.0, -4.0], "height": 5.0}, {"base_triangle": [3.0, 4.0], "height": -5.0}, {"base_triangle": ["1.7976931348623157E+308", "1.7976931348623157E+308"], "height": "1.7976931348623157E+308"}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "HAelloWorld"}, {"s": "HeloWorld"}, {"s": "HelloWorl"}, {"s": "HelloWord"}, {"s": "elloWorld"}, {"s": "OHelloWorld"}, {"s": "HellloWorld"}, {"s": "HelloWorldz"}, {"s": "HollWrldoe"}, {"s": "HlloWorld"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_orld_test_case_example"}, {"text": "hello_worldtest_case_example"}, {"text": "edwlels_o_sem_atllcpo_xheater"}, {"text": "hello_world_test_case_exampXle"}, {"text": "etlxh_otmocdlelsswaeel___aerp"}, {"text": "hellod_world_test_case_example"}, {"text": "hKello_world_test_case_example"}, {"text": "rspaec_o_e__edtlweahlltsxleom"}, {"text": "hello_world_test_case_wexample"}, {"text": "oree_altsewop_saetllce__xdmlh"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": 5.0}, {"side_length": 3.5}, {"side_length": 0.0}, {"side_length": -1.0}, {"side_length": "1.7976931348623157E+308"}, {"side_length": "-1.7976931348623157E+308"}, {"side_length": 1e-308}, {"side_length": -1e-308}, {"side_length": "1.000000000000000000000000000E+308"}, {"side_length": "-1.000000000000000000000000000E+308"}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "hkello world", "str2": "haeiou"}, {"str1": "helloworld", "str2": "aeiu"}, {"str1": "eloor dlwhl", "str2": "aeou"}, {"str1": "ewlood llrh", "str2": "aiou"}, {"str1": "helloworld", "str2": "aeiouS"}, {"str1": "ello world", "str2": "aeiu"}, {"str1": "ewlhdloro l", "str2": "iueao"}, {"str1": "ood lwrlelh", "str2": "aeiou8"}, {"str1": "ello world", "str2": "aeoui"}, {"str1": "lelowhlod r", "str2": "Saeiou"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5]}, {"nums": [1, 2, 3, 2, 4]}, {"nums": []}, {"nums": [1]}, {"nums": [1, 1]}, {"nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1]}, {"nums": [0, 0, 0, 0, 0]}, {"nums": [-1, 1, -1, 2, 3]}, {"nums": [999999999999999999, 999999999999999999]}, {"nums": [1.1, 2.2, 1.1, 3.3]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": "1"}, {"n": "7"}, {"n": "23"}, {"n": "0"}, {"n": "-1"}, {"n": "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "null"}, {"n": "1.5"}, {"n": "true"}, {"n": "woodall"}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": 5, "m": 3}, {"n": 0, "m": 10}, {"n": -5, "m": 4}, {"n": 2147483647, "m": 2}, {"n": -2147483648, "m": 2}, {"n": 100, "m": 0}, {"n": 1, "m": 1000}, {"n": 0, "m": 0}, {"n": 1, "m": -5}, {"n": 999999999, "m": 999999999}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [763, 945, 911, 285, -184, 155]}, {"arr": [93, -10, 30, 966, -778, 0]}, {"arr": [-892, -261, 879, 929, 914, -93]}, {"arr": [-701, 840, -652, 940, 569, 764]}, {"arr": [-505, -430, 421, -284, -840, -554]}, {"arr": [911, 775, -976, 948, 452, 69]}, {"arr": [-928, 511, 31, 924, -148, 543]}, {"arr": [290, 993, -154, -119, 658, -281]}, {"arr": [8, -621, 151, 938, 799, 610]}, {"arr": [-827, -482, -633, 27, 844, -256]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}, {"lists": "[[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]"}, {"lists": "[[0, 0, 0], [0, 0, 0], [0, 0, 0]]"}, {"lists": "[[999999999, 999999999], [1, 2, 3]]"}, {"lists": "[[], [1, 2, 3], [4, 5]]"}, {"lists": "[[1, 2, 3]]"}, {"lists": "[[]]"}, {"lists": "[[9223372036854775807, 1], [0, 0]]"}, {"lists": "[[-9223372036854775808, -1], [0, 0]]"}, {"lists": "[[1.5, 2.5, 3.5], [4.1, 5.1, 6.1]]"}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "1001"}, {"binary_str": "1100"}, {"binary_str": "1z010"}, {"binary_str": "101h0"}, {"binary_str": "110"}, {"binary_str": "1010"}, {"binary_str": "1010B"}, {"binary_str": "1010"}, {"binary_str": "0011"}, {"binary_str": "M1010"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [300, 767, 608, 16, 241]}, {"arr": [-630, -66, 1000, 155, -966]}, {"arr": [563, 100, 676, 750, 763]}, {"arr": [-299, -936, -865, -936, -87]}, {"arr": [843, -785, -5, -406, -417]}, {"arr": [236, -416, 209, -971, 655]}, {"arr": [-334, 115, 633, -217, -270]}, {"arr": [-326, 567, 580, -906, -534]}, {"arr": [-22, 733, -611, -20, 624]}, {"arr": [-63, -577, 744, 211, -558]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{"tuple_list": "[]"}, {"tuple_list": "[()]"}, {"tuple_list": "[(1,)]"}, {"tuple_list": "[(1, 2)]"}, {"tuple_list": "[(1, 2, 3)]"}, {"tuple_list": "[(1, 2), (3, 4)]"}, {"tuple_list": "[(1, 2), (3,)]"}, {"tuple_list": "[(1, 2), (3, 4, 5)]"}, {"tuple_list": "[('a', 'b'), ('c', 'd')]"}, {"tuple_list": "[(None, None), (None, None)]"}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["abc123", "45def6", "gh7i8j9"]}, {"strings": ["hello", "world", "123"]}, {"strings": ["", "", ""]}, {"strings": ["a1b2c3d4e5f6g7h8i9j0"]}, {"strings": ["1234567890"]}, {"strings": ["xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"]}, {"strings": ["!@#$%^&*()"]}, {"strings": ["test1", "test2", "test3", "test4", "test5", "test6", "test7", "test8", "test9", "test10"]}, {"strings": ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]}, {"strings": ["mixed123!@#", "456alpha789", "symbols$%^&*()"]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": "5", "k": "2"}, {"n": "0", "k": "0"}, {"n": "1", "k": "1"}, {"n": "-1", "k": "1"}, {"n": "10", "k": "-5"}, {"n": "1000000", "k": "500000"}, {"n": "999999999", "k": "999999998"}, {"n": "0", "k": "5"}, {"n": "5", "k": "10"}, {"n": "18446744073709551615", "k": "9223372036854775807"}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [-982, 249, -162, 839, -914, -936, -718]}, {"arr": [-705, -841, -950, -348, 806, -255, 968]}, {"arr": [-646, -118, 633, 760, 170, -601, 290]}, {"arr": [-347, 44, 586, 929, 115, -45, -775]}, {"arr": [447, 970, 967, 521, 345, -770, -983]}, {"arr": [-732, 571, -241, -856, 564, 472, -268]}, {"arr": [-766, 455, -583, -898, -715, 332, 416]}, {"arr": [-226, 206, -835, -344, -343, 844, 196]}, {"arr": [-865, 280, 622, 329, -155, -366, -341]}, {"arr": [-101, 872, -987, 270, -394, 982, 775]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "abcdag"}, {"s": "adbac"}, {"s": "adcab"}, {"s": "baadc"}, {"s": "abda"}, {"s": "bdcaa"}, {"s": "a2bcda"}, {"s": "caadb"}, {"s": "abcdan"}, {"s": "abcdMa"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": [[1, 2, 3], [2, 3, 4], [3, 4, 5]], "k": 2}, {"numbers": [], "k": 1}, {"numbers": [[], [], []], "k": 3}, {"numbers": [[1, 1, 1], [2, 2], [3]], "k": 0}, {"numbers": [[1]], "k": 5}, {"numbers": [[999999999, -999999999, 0]], "k": 2}, {"numbers": [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], "k": -1}, {"numbers": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], "k": 1}, {"numbers": [[1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1], [1]], "k": 1}, {"numbers": [[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]], "k": 1000}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"n": "2"}, {"n": "100"}, {"n": "1"}, {"n": "0"}, {"n": "-1"}, {"n": "2147483647"}, {"n": "9223372036854775807"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "6"}, {"n": "123456789012345678901234567890"}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": "0"}, {"decimal_num": "1"}, {"decimal_num": "10"}, {"decimal_num": "-5"}, {"decimal_num": "2147483647"}, {"decimal_num": "-2147483648"}, {"decimal_num": "9999999999999999999999999999999999999999"}, {"decimal_num": "-9999999999999999999999999999999999999999"}, {"decimal_num": "1.5"}, {"decimal_num": "abc"}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [2, 3, 4, 5, 7]}, {"arr": [1, 2, 4, 5, 6]}, {"arr": [1, 3, 4, 5, 6]}, {"arr": []}, {"arr": [1]}, {"arr": [2]}, {"arr": [1, 2, 3, 5, 6, 7, 8, 9, 10]}, {"arr": [10, 11, 12, 13, 15, 16, 17]}, {"arr": [0, 1, 2, 3, 4, 5, 6, 7, 9]}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 1}, {"n": 5}, {"n": 10}, {"n": 0}, {"n": -1}, {"n": -100}, {"n": 2147483647}, {"n": -2147483648}, {"n": 1000000}, {"n": -1000000}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": 1, "denominator": 2, "n": 1}, {"numerator": 1, "denominator": 3, "n": 5}, {"numerator": 22, "denominator": 7, "n": 10}, {"numerator": 0, "denominator": 5, "n": 3}, {"numerator": 5, "denominator": 0, "n": 1}, {"numerator": 1, "denominator": 7, "n": 100}, {"numerator": 2147483647, "denominator": 1, "n": 1}, {"numerator": 1, "denominator": 2147483647, "n": 50}, {"numerator": 1, "denominator": 1, "n": 0}, {"numerator": 999999999, "denominator": 999999999, "n": 1000}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [920, "appleZ", -940, "banrana", -933, "cheErry"]}, {"mixed_list": [-55, "ajpple", 724, "anaban", 7, "cSherry"]}, {"mixed_list": [18, "leppa", -20, "nabnaa", -847, "cherrym"]}, {"mixed_list": [-398, "aple", 347, "banana6", -675, "chery"]}, {"mixed_list": [273, "appTle", -994, "baanan", -494, "chrry"]}, {"mixed_list": [885, "Sapple", 429, "banaa", 885, "chrry"]}, {"mixed_list": [85, "apdple", 334, "fbanana", -293, "cerry"]}, {"mixed_list": [394, "a4pple", 33, "banan", 150, "chrry"]}, {"mixed_list": [681, "appe", 875, "ban5ana", -989, "cgherry"]}, {"mixed_list": [-533, "ppale", 604, "bnana", 281, "cherr"]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [815, -556, 182, 934, 742]}, {"numbers": [708, -166, 118, -61, -471]}, {"numbers": [-13, 113, 408, 459, 559]}, {"numbers": [912, 234, 659, 967, 528]}, {"numbers": [527, 735, -425, 544, 1006]}, {"numbers": [13, 605, 396, 106, 563]}, {"numbers": [-364, -271, -372, -591, 238]}, {"numbers": [-433, 128, 246, 681, 270]}, {"numbers": [-807, -820, 496, -895, -534]}, {"numbers": [-126, -300, -638, 833, 192]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "aabcbc"}, {"s": "aabbc"}, {"s": "aabbc"}, {"s": "aabbcc1"}, {"s": "cbaacb"}, {"s": "aabcc"}, {"s": "bbaacc"}, {"s": "aabbc"}, {"s": "qaabbcc"}, {"s": "aabcc"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [2, 4, 6, 8, 10]}, {"numbers": [1, 3, 5, 7, 9]}, {"numbers": [0]}, {"numbers": [-2, -4, -6, -8]}, {"numbers": [2147483647, -2147483648]}, {"numbers": [2.5, 3.7, 4.0]}, {"numbers": [null]}, {"numbers": ["2", "4", "6"]}, {"numbers": []}, {"numbers": [999999999999999999999999999999]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [1, 1, 2, 2, 3, 3]}, {"arr": []}, {"arr": [5, 5, 5, 5, 5]}, {"arr": [-1, -1, 2, 2, -3]}, {"arr": [0, 0, 0, 0, 0]}, {"arr": [999999999, 999999999, -999999999, -999999999]}, {"arr": [1, 2, 3, 1, 2, 3, 1, 2, 3]}, {"arr": [1]}, {"arr": [1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "pphex  _lillwrdtoeete_lu_astcsoanme"}, {"text": "ia ae eotpseplhdc_lmno_xsurlete_ltw"}, {"text": "hello_world test_case examle_input"}, {"text": "hello_world test_case example_inpEut"}, {"text": "_ae _xtehremst_ leoditluapcwleonpls"}, {"text": "hello_world test_Lcase example_input"}, {"text": "hello_word test_case example_input"}, {"text": "hello_world test_case exampe_input"}, {"text": "hello_world test_case eGxample_input"}, {"text": "hello_world test_case exampe_input"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "hello", "string": "hello world"}, {"word": "test", "string": "testing 123"}, {"word": "a", "string": "a"}, {"word": "", "string": "anything"}, {"word": "special.chars", "string": "special.chars here"}, {"word": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", "string": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"}, {"word": "[", "string": "["}, {"word": ".*", "string": ".*anything"}, {"word": "\\", "string": "\\test"}, {"word": "^", "string": "^beginning"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24]}, {"numbers": [0, 5, 10]}, {"numbers": [-12, 18, -24]}, {"numbers": [1]}, {"numbers": [2147483647, 2147483647]}, {"numbers": [0, 0, 0]}, {"numbers": [1, 0, 1]}, {"numbers": [-2147483648, -2147483648]}, {"numbers": [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50]}, {"numbers": [17, 19, 23, 29, 31]}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [960, -518, 803, -301, -675]}, {"numbers": [-134, -850, 409, -392, -327]}, {"numbers": [670, -458, -662, 47, 337]}, {"numbers": [112, 855, 670, 487, 499]}, {"numbers": [898, -726, 896, 646, -165]}, {"numbers": [631, -251, 475, 761, -904]}, {"numbers": [185, 721, -649, -685, -37]}, {"numbers": [-657, 166, 736, -617, -237]}, {"numbers": [-970, 858, 423, -992, 353]}, {"numbers": [67, -518, -817, -805, 246]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"a": 5, "b": 10}, {"a": 10, "b": 5}, {"a": 0, "b": 0}, {"a": -5, "b": -3}, {"a": 1000000, "b": 1000005}, {"a": 1, "b": 100}, {"a": 15, "b": 25}, {"a": 2147483647, "b": 2147483647}, {"a": -2147483648, "b": -2147483640}, {"a": 999999999, "b": 1000000000}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "255"}, {"n": "2147483647"}, {"n": "4294967295"}, {"n": "18446744073709551615"}, {"n": "-1"}, {"n": "-2147483648"}, {"n": "9223372036854775807"}, {"n": "170141183460469231731687303715884105727"}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": "[[1, 2], [3, 4]]"}, {"matrix": "[]"}, {"matrix": "[[], [1, 2]]"}, {"matrix": "[[1], [2, 3], [4, 5, 6]]"}, {"matrix": "[[1], [2]]"}, {"matrix": "[[1, 2, 3], [4, 5], [6]]"}, {"matrix": "[[1], [], [2]]"}, {"matrix": "[[1, 2], [3, 4], [5, 6]]"}, {"matrix": "[[1], [2], [3], [4]]"}, {"matrix": "[[1, 2, 3], [4], [5, 6, 7]]"}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": []}, {"lists": [[1]]}, {"lists": [[1, 2], [3]]}, {"lists": [[], [1]]}, {"lists": [[1, 2, 3], [4, 5], [6]]}, {"lists": [[1], [2], [3], [4], [5]]}, {"lists": [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]}, {"lists": [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10]]}, {"lists": [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]}, {"lists": [[1, 2, 3], [4], [5, 6, 7, 8, 9]]}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": "5", "side2": "5", "side3": "5"}, {"side1": "0", "side2": "0", "side3": "0"}, {"side1": "-1", "side2": "-1", "side3": "-1"}, {"side1": "9999999999999999999999999999999999999999", "side2": "9999999999999999999999999999999999999999", "side3": "9999999999999999999999999999999999999999"}, {"side1": "1", "side2": "1", "side3": "2"}, {"side1": "A", "side2": "A", "side3": "A"}, {"side1": "", "side2": "", "side3": ""}, {"side1": "null", "side2": "null", "side3": "null"}, {"side1": "1.5", "side2": "1.5", "side3": "1.5"}, {"side1": "true", "side2": "true", "side3": "true"}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": "5.0", "height": "3.0"}, {"base": "0.0", "height": "10.0"}, {"base": "10.0", "height": "0.0"}, {"base": "0.0", "height": "0.0"}, {"base": "-5.0", "height": "3.0"}, {"base": "5.0", "height": "-3.0"}, {"base": "-5.0", "height": "-3.0"}, {"base": "99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999", "height": "1.0"}, {"base": "1.0", "height": "99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"base": "NaN", "height": "5.0"}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "testd"}, {"s": "estt"}, {"s": "tset"}, {"s": "tet"}, {"s": "tet"}, {"s": "tet"}, {"s": "tset"}, {"s": "est"}, {"s": "est"}, {"s": "teswt"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [5, 4, 3, 2, 1]}, {"arr": [1, 1, 1, 1, 1]}, {"arr": [0]}, {"arr": []}, {"arr": [-5, -3, -1, 0, 2, 4]}, {"arr": [1000, -1000, 500, -500, 0]}, {"arr": [999999999, -999999999]}, {"arr": [1, 3, 2, 3, 1, 2, 3]}, {"arr": [2147483647, -2147483648]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": "1"}, {"r": "0"}, {"n": "1"}, {"a": "0", "r": "2", "n": "5"}, {"a": "-1", "r": "2", "n": "3"}, {"a": "1", "r": "-2", "n": "4"}, {"a": "1", "r": "1", "n": "1000000"}, {"a": "1", "r": "2", "n": "1000"}, {"a": "999999999", "r": "999999999", "n": "999999999"}, {"a": "0.1", "r": "0.1", "n": "100"}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"n": "123"}, {"n": "0"}, {"n": "1"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "-123"}, {"n": "18446744073709551615"}, {"n": "3.14"}, {"n": "abc"}, {"n": "null"}, {"n": "true"}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [1, 2, 3, 4, 5]}, {"digits": [0, 0, 0, 0]}, {"digits": [9, 9, 9, 9, 9]}, {"digits": [1]}, {"digits": [0]}, {"digits": [10, 20, 30]}, {"digits": [-1, -2, -3]}, {"digits": [9999999999, 8888888888]}, {"digits": [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"digits": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"a": "0", "b": "0"}, {"a": "1", "b": "1"}, {"a": "-1", "b": "-1"}, {"a": "1", "b": "-1"}, {"a": "-1", "b": "1"}, {"a": "2147483647", "b": "-2147483648"}, {"a": "-2147483648", "b": "2147483647"}, {"a": "0", "b": "-2147483648"}, {"a": "-2147483648", "b": "0"}, {"a": "9223372036854775807", "b": "-9223372036854775808"}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "5"}, {"n": "-1"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"n": "0.5"}, {"n": "-0.5"}, {"n": "2147483647"}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": [-336, -603, -173, -908, 968, 667, 818, -729]}, {"arr": [215, 80, 254, -310, 6, 597, -595, 71]}, {"arr": [-919, -236, -440, -246, -738, 611, -126, -45]}, {"arr": [447, -923, -454, 255, 364, -367, -16, 605]}, {"arr": [492, 262, 292, -801, 843, 890, 519, -626]}, {"arr": [-820, 828, 560, 954, 762, 427, 747, -168]}, {"arr": [890, 703, 949, 344, 786, 606, 914, 481]}, {"arr": [-269, 622, -859, 220, 655, 641, 87, 169]}, {"arr": [818, 981, -979, -649, 414, -307, 440, 735]}, {"arr": [-434, 855, -879, -948, -667, -764, -404, -587]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "110"}, {"s": "110"}, {"s": "101"}, {"s": "101"}, {"s": "11"}, {"s": "10"}, {"s": "101P"}, {"s": "110"}, {"s": "101S"}, {"s": "11"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}, {"numbers": [-5, -2, -10, -1]}, {"numbers": [0, 0, 0, 0]}, {"numbers": [100, 200, 50, 300]}, {"numbers": [3.14, 2.71, 1.41]}, {"numbers": [9999999999, 1, 9999999998]}, {"numbers": [-9999999999, -1, -9999999998]}, {"numbers": [0, -1, 1, -2, 2]}, {"numbers": [2147483647, -2147483648, 0]}, {"numbers": [1]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": "[[1, 2], [3, 4]]"}, {"pairs": "[[0, 0], [0, 0]]"}, {"pairs": "[[-1, -1], [1, 1]]"}, {"pairs": "[[1000, 1000], [-1000, -1000]]"}, {"pairs": "[[0, 0], [100, 100], [50, 50]]"}, {"pairs": "[[1, 1]]"}, {"pairs": "[]"}, {"pairs": "[[999999, 999999], [-999999, -999999]]"}, {"pairs": "[[1, 100], [100, 1], [50, 50]]"}, {"pairs": "[[0, 1000], [1000, 0], [500, 500]]"}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{"tuples_list": "[]"}, {"tuples_list": "[(\"a\", 1), (\"b\", 2), (\"c\", 3)]"}, {"tuples_list": "[(1, 2, 3), (4, 5, 6), (7, 8, 9)]"}, {"tuples_list": "[(\"x\",), (\"y\",), (\"z\",)]"}, {"tuples_list": "[(5,), (3,), (1,), (9,), (2,)]"}, {"tuples_list": "[(1, 2), (3, 4), (5, 6), (7, 8), (9, 10), (11, 12), (13, 14), (15, 16), (17, 18), (19, 20)]"}, {"tuples_list": "[(\"apple\", 5), (\"banana\", 2), (\"cherry\", 8)]"}, {"tuples_list": "[(10, \"z\"), (5, \"a\"), (8, \"m\"), (1, \"b\")]"}, {"tuples_list": "[(3.14, \"pi\"), (2.71, \"e\"), (1.41, \"sqrt2\")]"}, {"tuples_list": "[(\"single\",)]"}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [-211, [245, -766], [153, [288, -641]], -286]}, {"lst": [747, [-569, -497], [-703, [-65, 115]], 175]}, {"lst": [-851, [-35, 974], [158, [-420, -31]], 589]}, {"lst": [-402, [-780, 62], [685, [938, -269]], -328]}, {"lst": [-796, [63, -254], [110, [138, 975]], -452]}, {"lst": [-886, [-647, 755], [-526, [606, -620]], 611]}, {"lst": [963, [-90, 273], [41, [590, 389]], -193]}, {"lst": [-159, [494, 457], [-521, [-797, 457]], 55]}, {"lst": [433, [744, 704], [-13, [432, -844]], -850]}, {"lst": [-12, [-596, -499], [822, [-307, -182]], -898]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}, {"numbers": [-1, -2, -3, -4, -5]}, {"numbers": [0, 0, 0, 0, 0]}, {"numbers": [1, -1, 2, -2, 0]}, {"numbers": [999999999999999999999999999999]}, {"numbers": [-999999999999999999999999999999]}, {"numbers": [1.5, -2.7, 3.1, -4.9, 0.0]}, {"numbers": []}, {"numbers": [1]}, {"numbers": [1e-30, -1e-30]}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "5"}, {"n": "-1"}, {"n": "999"}, {"n": "1000"}, {"n": "-999"}, {"n": "32767"}, {"n": "-32768"}, {"n": "2147483647"}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [5, 4, 3, 2, 1]}, {"arr": [1, 1, 1, 1, 1]}, {"arr": [1, 3, 2, 4, 5]}, {"arr": []}, {"arr": [1]}, {"arr": [1, 2, 2, 3, 4]}, {"arr": [5, 5, 4, 3, 2]}, {"arr": [1, 2, 3, 2, 1]}, {"arr": [1, 1, 2, 2, 3]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": [1, 2, 3, 4, 5], "sublist": [2, 3]}, {"main_list": [], "sublist": []}, {"main_list": [1, 2, 3], "sublist": [4, 5]}, {"main_list": [1, 2, 3, 4, 5], "sublist": []}, {"main_list": [1, 1, 1, 1, 1], "sublist": [1, 1]}, {"main_list": [1], "sublist": [1, 2]}, {"main_list": [1, 2, 3, 1, 2, 3], "sublist": [1, 2, 3]}, {"main_list": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "sublist": [9, 10]}, {"main_list": [1], "sublist": [1]}, {"main_list": [1, 2, 3], "sublist": [1, 2, 3, 4]}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [208, 8, -871, 124, 772, -481, 380, -449, -399]}, {"arr": [-341, 762, 160, 56, 653, 137, -233, 643, 116]}, {"arr": [768, 481, 246, -673, -799, 486, 556, 28, -369]}, {"arr": [-936, -132, -542, -443, 564, -820, 556, -938, -979]}, {"arr": [-807, 597, 709, 258, -135, 220, 406, 175, 587]}, {"arr": [-132, -59, -906, 886, -300, 48, 947, 725, 207]}, {"arr": [-866, 194, 947, -925, 578, 424, -407, -359, 941]}, {"arr": [540, -629, -333, -883, 271, 813, 540, -555, 127]}, {"arr": [869, 445, -66, 89, 529, -522, 97, 696, 522]}, {"arr": [-821, -478, 111, 679, -263, 127, 658, 691, -91]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "2"}, {"n": "3"}, {"n": "4"}, {"n": "5"}, {"n": "-1"}, {"n": "2147483647"}, {"n": "-2147483648"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "hello,world;teVst|example", "delimiters": [",", ";", "u|"]}, {"text": "hello,world;test|exaSmple", "delimiters": [",W", ";j", "g|"]}, {"text": "hello,word;test|example", "delimiters": [",", "0;", "|"]}, {"text": "hello,word;test|example", "delimiters": [",", ";", "N|"]}, {"text": "helo,world;test|example", "delimiters": [",5", "E;", "Z|"]}, {"text": "l|tlptwed;hmeo,aeeosrllx", "delimiters": [",", "d;", "|"]}, {"text": "hello,world;test|examiple", "delimiters": [",", ";", "|"]}, {"text": "hello,world;test|exampsle", "delimiters": [",", ";", "|"]}, {"text": "hello,world;test|eample", "delimiters": [",", ";", "|H"]}, {"text": "s;eoltpwexleahdteolm,lr|", "delimiters": [",", ";", "|"]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": "abc", "patterns": ["xyz"]}, {"sequence": "aaa", "patterns": ["xxx"]}, {"sequence": "abc", "patterns": ["aba"]}, {"sequence": "a", "patterns": ["x"]}, {"sequence": "abab", "patterns": ["xyxy", "xxyy"]}, {"sequence": "abcabc", "patterns": ["xyzxyz", "xyzyxz"]}, {"sequence": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "patterns": ["xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"]}, {"sequence": "", "patterns": []}, {"sequence": "abc", "patterns": ["", "x", "xy", "xyz", "xyzw"]}, {"sequence": "112233", "patterns": ["aabbcc", "abcabc", "ababab"]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{"tuple_list": "[[2, 4, 6], [3, 6, 9], [1, 2, 3]]", "k": "2"}, {"tuple_list": "[[0, 0, 0], [5, 10, 15], [7, 14, 21]]", "k": "5"}, {"tuple_list": "[]", "k": "1"}, {"tuple_list": "[[1, 2, 3], [4, 5, 6]]", "k": "0"}, {"tuple_list": "[[-4, -8, -12], [3, -6, 9]]", "k": "-2"}, {"tuple_list": "[[999999999, 999999999], [888888888, 888888888]]", "k": "111111111"}, {"tuple_list": "[[0.5, 1.0, 1.5], [2.0, 3.0, 4.0]]", "k": "0.5"}, {"tuple_list": "[['a', 'b', 'c'], [1, 2, 3]]", "k": "1"}, {"tuple_list": "[[null, undefined], [NaN, Infinity]]", "k": "1"}, {"tuple_list": "[[], [[]], [[[]]]]", "k": "0"}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": "5", "width": "3"}, {"length": "1", "width": "1"}, {"length": "0", "width": "5"}, {"length": "5", "width": "0"}, {"length": "0", "width": "0"}, {"length": "-1", "width": "5"}, {"length": "5", "width": "-1"}, {"length": "-1", "width": "-1"}, {"length": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999", "width": "1"}, {"length": "1", "width": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": "12345"}, {"num": "24680"}, {"num": "13579"}, {"num": "0"}, {"num": "9999999999"}, {"num": "-12345"}, {"num": "123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"}, {"num": "1a2b3c"}, {"num": "null"}, {"num": "1.5"}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "5"}, {"n": "10"}, {"n": "100"}, {"n": "1000"}, {"n": "999999"}, {"n": "-1"}, {"n": "2147483647"}, {"n": "9223372036854775807"}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "te8st"}, {"word": "est"}, {"word": "etts"}, {"word": "tet"}, {"word": "estt"}, {"word": "tesst"}, {"word": "testF"}, {"word": "Gtest"}, {"word": "tesnt"}, {"word": "teGst"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "5"}, {"n": "100"}, {"n": "-1"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "2147483647"}, {"n": "-2147483648"}, {"n": "18446744073709551615"}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{"tuple1": "()", "tuple2": "()"}, {"tuple1": "(1, 2, 3)", "tuple2": "('a', 'b', 'c')"}, {"tuple1": "(1,)", "tuple2": "('a', 'b')"}, {"tuple1": "(1, 2)", "tuple2": "('a',)"}, {"tuple1": "('x' * 1000,)", "tuple2": "('y' * 1000,)"}, {"tuple1": "(None, True, False)", "tuple2": "(0, 1, -1)"}, {"tuple1": "([], {}, set())", "tuple2": "((), [], {})"}, {"tuple1": "(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)", "tuple2": "('a',)"}, {"tuple1": "(1,)", "tuple2": "('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j')"}, {"tuple1": "(complex(1, 2), float('inf'), float('-inf'))", "tuple2": "(object(), type, zip)"}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": "1.0"}, {"radius": "0.0"}, {"radius": "-1.0"}, {"radius": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"radius": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"radius": "1e308"}, {"radius": "-1e308"}, {"radius": "1e-308"}, {"radius": "0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"}, {"radius": "NaN"}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "a"}, {"s": "A"}, {"s": ""}, {"s": "ab"}, {"s": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}, {"s": "\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000\\u0000"}, {"s": "\\u00ff\\u00ff\\u00ff\\u00ff\\u00ff\\u00ff\\u00ff\\u00ff\\u00ff\\u00ff"}, {"s": "\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080\\u0080"}, {"s": "\\u0001\\u0002\\u0003\\u0004\\u0005\\u0006\\u0007\\u0008\\u0009\\u000a\\u000b\\u000c\\u000d\\u000e\\u000f\\u0010\\u0011\\u0012\\u0013\\u0014\\u0015\\u0016\\u0017\\u0018\\u0019\\u001a\\u001b\\u001c\\u001d\\u001e\\u001f\\u0020\\u0021\\u0022\\u0023\\u0024\\u0025\\u0026\\u0027\\u0028\\u0029\\u002a\\u002b\\u002c\\u002d\\u002e\\u002f\\u0030\\u0031\\u0032\\u0033\\u0034\\u0035\\u0036\\u0037\\u0038\\u0039\\u003a\\u003b\\u003c\\u003d\\u003e\\u003f\\u0040\\u0041\\u0042\\u0043\\u0044\\u0045\\u0046\\u0047\\u0048\\u0049\\u004a\\u004b\\u004c\\u004d\\u004e\\u004f\\u0050\\u0051\\u0052\\u0053\\u0054\\u0055\\u0056\\u0057\\u0058\\u0059\\u005a\\u005b\\u005c\\u005d\\u005e\\u005f\\u0060\\u0061\\u0062\\u0063\\u0064\\u0065\\u0066\\u0067\\u0068\\u0069\\u006a\\u006b\\u006c\\u006d\\u006e\\u006f\\u0070\\u0071\\u0072\\u0073\\u0074\\u0075\\u0076\\u0077\\u0078\\u0079\\u007a\\u007b\\u007c\\u007d\\u007e\\u007f"}, {"s": "\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100\\u0100"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": "1"}, {"n": "2"}, {"n": "5"}, {"n": "10"}, {"n": "0"}, {"n": "-1"}, {"n": "1000"}, {"n": "999"}, {"n": "1000000"}, {"n": "2147483647"}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": "1.0"}, {"radius": "0.0"}, {"radius": "-1.0"}, {"radius": "999999999.0"}, {"radius": "-999999999.0"}, {"radius": "0.000000000000001"}, {"radius": "NaN"}, {"radius": "Infinity"}, {"radius": "-Infinity"}, {"radius": "1.7976931348623157e+308"}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"n": "1"}, {"n": "2"}, {"n": "0"}, {"n": "-1"}, {"n": "100"}, {"n": "1000"}, {"n": "-100"}, {"n": "9999999999999999999999999999999999999999"}, {"n": "-9999999999999999999999999999999999999999"}, {"n": "18446744073709551615"}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": "{}"}, {"dict1": "{\"key\": \"value\"}"}, {"dict1": "{\"a\": 1, \"b\": 2}"}, {"dict1": "{\"__class__\": \"\"}"}, {"dict1": "{\"__builtins__\": {}}"}, {"dict1": "null"}, {"dict1": "{\"x\": "}, {"dict1": "{\"\\u0000\": \"test\"}"}, {"dict1": "{\"key\": \""}, {"dict1": "{\"a\": {\"b\": {\"c\": {}}}}"}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": ["appl", "bavnana", "aeplp", "rgenoa", "banaa", "aple"]}, {"elements": ["appe", "nabaan", "lpaep", "ornge", "anana", "appRle"]}, {"elements": ["appe", "banan", "appleZ", "naeogr", "anana", "aMpple"]}, {"elements": ["aple", "banna", "aple", "noreag", "baana", "epapl"]}, {"elements": ["paple", "banaa", "papel", "Iorange", "ba2nana", "alepp"]}, {"elements": ["epalp", "bnana", "ap4ple", "orage", "nnaaba", "apelp"]}, {"elements": ["aipple", "banan", "plaep", "oZrange", "bananae", "apNple"]}, {"elements": ["pleap", "banaa", "4apple", "gnraoe", "abnnaa", "lpeap"]}, {"elements": ["aple", "anana", "plaep", "goarne", "bnana", "applGe"]}, {"elements": ["pepal", "banna", "appole", "groane", "baana", "aZpple"]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": "12345"}, {"n": "54321"}, {"n": "10000"}, {"n": "99999"}, {"n": "0"}, {"n": "-1"}, {"n": "11111"}, {"n": "9876543210"}, {"n": "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"n": "321"}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "The quick brown fox jumps over the lazy dogi"}, {"sentence": "The quick brown fox jumps ov7er the lazy dog"}, {"sentence": "The quickbrown fox jumps over the lazy dog"}, {"sentence": "The quiNck brown fox jumps over the lazy dog"}, {"sentence": "The quick brown fox jumps over the azy dog"}, {"sentence": "The quick brown fox jumps oer the lazy dog"}, {"sentence": "The quick brown fox juhmps over the lazy dog"}, {"sentence": "The quick brown fox jumps over the Qlazy dog"}, {"sentence": "xkth  opq ulye iejcrugofnd sbeaoz o whvmr T"}, {"sentence": "The quick brown foxX jumps over the lazy dog"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"substring": "test"}, {"substring": ""}, {"substring": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"}, {"substring": "a"}, {"substring": "\\u0000"}, {"substring": "test123"}, {"substring": "!@#$%^&*()"}, {"substring": "null"}, {"substring": "undefined"}, {"substring": "True"}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"n": "123"}, {"n": "121"}, {"n": "1221"}, {"n": "12121"}, {"n": "99"}, {"n": "100"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "-100"}, {"n": "0"}, {"n": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": "2"}, {"a": "0"}, {"a": "-1"}, {"a": "1"}, {"a": "1000000"}, {"a": "0.5"}, {"a": "-0.5"}, {"a": "9999999999999999999999999999999999999999"}, {"a": "1e308"}, {"a": "0.0000000000000000000000000000000000000001"}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": "[1, 2, 3, 4, 5]"}, {"records": "[5, 4, 3, 2, 1]"}, {"records": "[3, 1, 4, 1, 5, 9]"}, {"records": "[0]"}, {"records": "[-10, -5, -20, -1]"}, {"records": "[1000000, -1000000, 500000]"}, {"records": "[1.5, 2.3, 0.7, 3.1]"}, {"records": "[]"}, {"records": "[null, 1, 2]"}, {"records": "[\"a\", \"b\", \"c\"]"}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5], "target": 10}, {"nums": [1, 2, 3, 4, 5], "target": 15}, {"nums": [1, 2, 3, 4, 5], "target": 0}, {"nums": [1, 2, 3, 4, 5], "target": -5}, {"nums": [1, 2, 3, 4, 5], "target": 100}, {"nums": [], "target": 5}, {"nums": [5, 1, 3, 5, 10, 7, 4, 9, 2, 8], "target": 15}, {"nums": [1, 4, 4], "target": 4}, {"nums": [1, 2, 3, 4, 5], "target": 11}, {"nums": [10, 5, 2, 6], "target": 8}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": "25"}, {"n": "0"}, {"n": "-1"}, {"n": "1"}, {"n": "1000000"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "2.5"}, {"n": "null"}, {"n": "true"}, {"n": "2147483647"}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": [[1, 2, 3], [2, 3, 4], [3, 4, 5]]}, {"lst": [["a", "b"], ["b", "c"], ["c", "d"]]}, {"lst": []}, {"lst": [[]]}, {"lst": [[], [], []]}, {"lst": [[1], [1], [1], [1], [1]]}, {"lst": [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]}, {"lst": [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]}, {"lst": [[1, 1, 1], [2, 2, 2], [3, 3, 3]]}, {"lst": [["x", "y", "z"], ["a", "b", "c"], ["1", "2", "3"]]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [1, 2, 3]}, {"numbers": [0, 5, 10]}, {"numbers": [-1, -2, -3]}, {"numbers": [1, 0, -1]}, {"numbers": [1000000, 1000000, 1000000]}, {"numbers": [0.1, 0.2, 0.3]}, {"numbers": [1]}, {"numbers": []}, {"numbers": [1, -1, 1, -1, 1, -1, 1, -1, 1, -1]}, {"numbers": [999999999, 999999999, 999999999, 999999999]}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": "0"}, {"decimal_num": "1"}, {"decimal_num": "255"}, {"decimal_num": "-1"}, {"decimal_num": "-255"}, {"decimal_num": "2147483647"}, {"decimal_num": "-2147483648"}, {"decimal_num": "9999999999999999999999999999999999999999"}, {"decimal_num": "-9999999999999999999999999999999999999999"}, {"decimal_num": "123456789012345678901234567890"}]}
{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": "[[1,2,3],[4,5,6],[7,8,9]]", "m": "2", "n": "2"}, {"cost": "[[0,0,0],[0,0,0],[0,0,0]]", "m": "2", "n": "2"}, {"cost": "[[1]]", "m": "0", "n": "0"}, {"cost": "[[999999999,999999999],[999999999,999999999]]", "m": "1", "n": "1"}, {"cost": "[[-1,-2,-3],[-4,-5,-6],[-7,-8,-9]]", "m": "2", "n": "2"}, {"cost": "[[1,2],[3,4]]", "m": "10", "n": "10"}, {"cost": "[[1,2],[3,4]]", "m": "-1", "n": "-1"}, {"cost": "[[9223372036854775807,9223372036854775807],[9223372036854775807,9223372036854775807]]", "m": "1", "n": "1"}, {"cost": "[[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25]]", "m": "4", "n": "4"}, {"cost": "[[1,2],[3,4]]", "m": "0", "n": "5"}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": "()", "test_tup2": "()"}, {"test_tup1": "(1, 2, 3)", "test_tup2": "(2, 3, 4)"}, {"test_tup1": "(1, 1, 1)", "test_tup2": "(1, 2, 3)"}, {"test_tup1": "('a', 'b', 'c')", "test_tup2": "('c', 'd', 'e')"}, {"test_tup1": "(None, True, False)", "test_tup2": "(True, 0, 1)"}, {"test_tup1": "([], {}, ())", "test_tup2": "({}, [], set())"}, {"test_tup1": "(1, '1', 1.0)", "test_tup2": "('1', 1, 1.0)"}, {"test_tup1": "(1, 2, 3, 4, 5)", "test_tup2": "(6, 7, 8, 9, 10)"}, {"test_tup1": "(1,)", "test_tup2": "(1,)"}, {"test_tup1": "(999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999,)", "test_tup2": "(999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999,)"}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [2, 3, 5, 7, 11]}, {"numbers": [4, 6, 8, 9, 10]}, {"numbers": [1]}, {"numbers": [0]}, {"numbers": [-1, -2, -5]}, {"numbers": [999983]}, {"numbers": [1000000]}, {"numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}, {"numbers": []}, {"numbers": [2147483647]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [258, 772, -981, -629, 6], "k": 119}, {"numbers": [280, -389, -221, 71, -803], "k": 492}, {"numbers": [-315, -479, 506, 175, 685], "k": -428}, {"numbers": [-543, 35, 185, -404, -738], "k": -298}, {"numbers": [249, -148, 398, 799, -686], "k": -570}, {"numbers": [862, -116, -747, -668, 590], "k": -390}, {"numbers": [31, -763, -267, 278, -816], "k": -6}, {"numbers": [-217, -89, -815, -564, 595], "k": 698}, {"numbers": [86, -650, 727, -660, -544], "k": -376}, {"numbers": [409, 613, 553, 623, 903], "k": -546}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": "0"}, {"n": "2"}, {"n": "4"}, {"n": "8"}, {"n": "1"}, {"n": "3"}, {"n": "-2"}, {"n": "100"}, {"n": "1000"}, {"n": "-100"}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": "0", "b": "0"}, {"a": "1", "b": "0"}, {"a": "0", "b": "1"}, {"a": "3", "b": "1"}, {"a": "7", "b": "3"}, {"a": "-1", "b": "-2"}, {"a": "2147483647", "b": "2147483646"}, {"a": "-2147483648", "b": "-2147483647"}, {"a": "18446744073709551615", "b": "18446744073709551614"}, {"a": "255", "b": "127"}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "Hello world"}, {"text": "cat dog elephant"}, {"text": "a b c d"}, {"text": "test"}, {"text": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"}, {"text": ""}, {"text": "!@#$%^&*()"}, {"text": "word1 word2 word3 word4"}, {"text": "multiple     spaces    between    words"}, {"text": "1234 56789 012345"}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}, {"numbers": []}, {"numbers": [0]}, {"numbers": [-1, -2, -3]}, {"numbers": [1000000, -1000000]}, {"numbers": [0.5, 1.5, 2.5]}, {"numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]}, {"numbers": [999999999999999999]}, {"numbers": ["1.7976931348623157E+308"]}, {"numbers": ["1", "2", "3"]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": "cabcba"}, {"s": "abcac"}, {"s": "abacabc"}, {"s": "acabc"}, {"s": "abcbc"}, {"s": "abacbc"}, {"s": "abcabcU"}, {"s": "kabcabc"}, {"s": "acbacb"}, {"s": "abcac"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": "[]"}, {"dataset": "[1]"}, {"dataset": "[1, 2, 3]"}, {"dataset": "[3, 1, 2]"}, {"dataset": "[1, 1, 1]"}, {"dataset": "[-1, 0, 1]"}, {"dataset": "[9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999]"}, {"dataset": "[null]"}, {"dataset": "[1, \"a\", 2]"}, {"dataset": "[[], [1], [1, 2]]"}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "legtcma lwtsatne hh rsetrcittrsipi tu ", "char": "t"}, {"s": "test string with multiple t charactrs", "char": "t"}, {"s": "esn tarittehhitplr mtgtlcsrtsw cu e ia", "char": "t"}, {"s": "test string withmultiple t characters", "char": "mt"}, {"s": "test string with multiple t charactes", "char": "jt"}, {"s": "test string ith multiple t characters", "char": "it"}, {"s": "test string withm multiple t characters", "char": "t"}, {"s": "ttta h itsesrtsgeahuwleirrc mc n pttil", "char": "0t"}, {"s": "thet pc ctiaiwtiuns rer tt emgrllshast", "char": "St"}, {"s": "test string with multiple t caracters", "char": "t"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}, {"matrix": "[]"}, {"matrix": "[[]]"}, {"matrix": "[[], [], []]"}, {"matrix": "[[0, 0, 0], [0, 0, 0], [0, 0, 0]]"}, {"matrix": "[[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]"}, {"matrix": "[[1, 2, 3], [100, 200, 300], [10, 20, 30]]"}, {"matrix": "[[9223372036854775807, 9223372036854775807], [-9223372036854775808, -9223372036854775808]]"}, {"matrix": "[[1.5, 2.5, 3.5], [4.5, 5.5, 6.5], [7.5, 8.5, 9.5]]"}, {"matrix": "[['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]"}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "cherry": 5}, "n": 2}, {"word_dict": {}, "n": 1}, {"word_dict": {"test": 1}, "n": 0}, {"word_dict": {"a": 10, "b": 10, "c": 10, "d": 10, "e": 10}, "n": 5}, {"word_dict": {"x": 100, "y": 50, "z": 25}, "n": -1}, {"word_dict": {"word1": 1}, "n": 100}, {"word_dict": {"a": 1, "b": 2, "c": 3, "d": 4, "e": 5, "f": 6, "g": 7, "h": 8, "i": 9, "j": 10}, "n": 3}, {"word_dict": {"null": 0, "zero": 0, "negative": -5}, "n": 2}, {"word_dict": {"very_long_key_name_that_exceeds_normal_length_but_still_valid_for_dictionary_keys_used_in_testing": 1}, "n": 1}, {"word_dict": {"duplicate": 3}, "n": 1}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": [153.48975989541896, -559.6240101165286], "height": 644.8274631345341}, {"base_triangle": [982.9561822786209, 529.344394424111], "height": 738.2416606293566}, {"base_triangle": [105.13604920217495, -687.7460676149565], "height": 982.1169181961136}, {"base_triangle": [-562.3776123746154, -815.9450884838459], "height": 442.4952932868898}, {"base_triangle": [242.60935244330267, 374.3222456441181], "height": -7.565358995990891}, {"base_triangle": [926.0655130602772, 150.8205936348411], "height": -171.45102854238905}, {"base_triangle": [-204.8882349971019, -282.67854114903423], "height": -28.269753449514383}, {"base_triangle": [131.9802090865569, -755.6132048513449], "height": -794.173211886774}, {"base_triangle": [-722.6377173619564, 348.8416549722001], "height": -498.0787333557414}, {"base_triangle": [387.9014986235029, 850.1379330138184], "height": -420.7615814856108}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "HelloWold"}, {"s": "llWdeoHolr"}, {"s": "HelloWSorld"}, {"s": "HeloWorld"}, {"s": "HelloWorfld"}, {"s": "HelloWoryld"}, {"s": "HeloWorld"}, {"s": "eWlllodorH"}, {"s": "loedHorWll"}, {"s": "orlHleldoW"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world test_case exmple_123"}, {"text": "se2rhw3ltl e lpet_oxdlecma1__aose"}, {"text": " 3e_atlxrlaop_le2lwctes1 dhso_eme"}, {"text": " lro e3he_sdol2st_wem_ecelx1patal"}, {"text": "sa_ltsep 3erm_e2 lcedwlela_xhoot1"}, {"text": "helo_world test_case example_123"}, {"text": "hello_world test_case nexample_123"}, {"text": "hhello_world test_case example_123"}, {"text": "pl a2tlmeedcetox_1 whalsole_ers_3"}, {"text": "hello_word test_case example_123"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": "5"}, {"side_length": "3.5"}, {"side_length": "0"}, {"side_length": "-5"}, {"side_length": "-3.5"}, {"side_length": "9999999999999999999999999999999999999999"}, {"side_length": "-9999999999999999999999999999999999999999"}, {"side_length": "0.0000000000000000000000000000000000000001"}, {"side_length": "-0.0000000000000000000000000000000000000001"}, {"side_length": "1.7976931348623157e+308"}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "hello worcld", "str2": "aeou"}, {"str1": "hello wold", "str2": "uaioe"}, {"str1": "hello Fworld", "str2": "aeiu"}, {"str1": "hellBo world", "str2": "aeEiou"}, {"str1": "helo world", "str2": "aYeiou"}, {"str1": "w elolrohdl", "str2": "aeio"}, {"str1": "helBlo world", "str2": "eauio"}, {"str1": "hello worl", "str2": "auieo"}, {"str1": "hellno world", "str2": "aiou"}, {"str1": "hwe doollrl", "str2": "aeiu"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5]}, {"nums": [1, 2, 3, 2, 4]}, {"nums": []}, {"nums": [1]}, {"nums": [1, 1]}, {"nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1]}, {"nums": [0, 0, 0, 0, 0]}, {"nums": [-1, 1, -1]}, {"nums": [999999999, -999999999, 0, 999999999]}, {"nums": [1.1, 2.2, 1.1]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": 1}, {"n": 7}, {"n": 23}, {"n": 0}, {"n": -1}, {"n": 2147483647}, {"n": -2147483648}, {"n": 999999999999999999}, {"n": -999999999999999999}, {"n": 1000000000000000000}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": 3, "m": 4}, {"n": 5, "m": 3}, {"n": 0, "m": 10}, {"n": -5, "m": 4}, {"n": 2147483647, "m": 2}, {"n": -2147483648, "m": 2}, {"n": 100, "m": 0}, {"n": 1, "m": 1000}, {"n": 1000000, "m": 1000}, {"n": 1, "m": -1}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [1, 2, 3, 2, 1]}, {"arr": []}, {"arr": [1]}, {"arr": [1, 1]}, {"arr": [null, null]}, {"arr": [1.1, 2.2, 1.1]}, {"arr": ["a", "b", "a"]}, {"arr": [true, false, true]}, {"arr": [{"key": "value"}, {"key": "value"}]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}, {"lists": "[[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]"}, {"lists": "[[], [1, 2], [3, 4, 5]]"}, {"lists": "[[1000000, 1000000, 1000000], [2000000, 2000000, 2000000]]"}, {"lists": "[[0, 0, 0], [0, 0, 0], [0, 0, 0]]"}, {"lists": "[[9223372036854775807, 1], [-9223372036854775808, -1]]"}, {"lists": "[[1.5, 2.5, 3.5], [4.1, 5.1, 6.1]]"}, {"lists": "[[], [], [], [], []]"}, {"lists": "[[\"1\", \"2\", \"3\"], [\"4\", \"5\", \"6\"]]"}, {"lists": "[[None, None], [True, False], [1, 2]]"}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "0110"}, {"binary_str": "010"}, {"binary_str": "1100"}, {"binary_str": "1001"}, {"binary_str": "010"}, {"binary_str": "0101"}, {"binary_str": "1100"}, {"binary_str": "k1010"}, {"binary_str": "p1010"}, {"binary_str": "100"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [1, 1, 2, 2, 3, 3]}, {"arr": [1]}, {"arr": [1, 1, 1, 1, 1]}, {"arr": [2, 3, 5, 7, 11]}, {"arr": [0, 1, 2, 3, 4]}, {"arr": [1000000, 1000000, 1000000]}, {"arr": [-1, -2, -3, -4, -5]}, {"arr": [2147483647, -2147483648, 0]}, {"arr": [1, 2, 1, 3, 2, 4, 5, 4, 6]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{"tuple_list": "[]"}, {"tuple_list": "[()]"}, {"tuple_list": "[(1,)]"}, {"tuple_list": "[(1, 2)]"}, {"tuple_list": "[(1, 2, 3)]"}, {"tuple_list": "[(1, 2), (3, 4)]"}, {"tuple_list": "[(1, 2), (3, 4, 5)]"}, {"tuple_list": "[('a', 'b'), ('c', 'd')]"}, {"tuple_list": "[(None, None), (None, None)]"}, {"tuple_list": "[([], []), ([], [])]"}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["1b2c3", "test46", "789q", "n_digits_here"]}, {"strings": ["a1bH2c3", "e5t6st4", "v789", "_e_gsrdiohtien"]}, {"strings": ["bc3a12", "t4st6e5", "7849", "rno_digits_here"]}, {"strings": ["a1b2c", "4t6e5ts", "79", "o_digits_here"]}, {"strings": ["aW1b2c3", "te56t4s", "78", "hsreditg_eino_"]}, {"strings": ["a1b52c3", "se64t5t", "z789", "eosgenitr_dhi_"]}, {"strings": ["aV1b2c3", "4s6et5t", "79", "ri_shtogid_ene"]}, {"strings": ["a12c3", "tes8t456", "79", "no_digitsy_here"]}, {"strings": ["ca2b13", "6s5e4tt", "78g9", "no_digis_here"]}, {"strings": ["a12c3", "56tset4", "789", "ieogtsehrnd__i"]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": "5", "k": "2"}, {"n": "0", "k": "0"}, {"n": "10", "k": "10"}, {"n": "-5", "k": "2"}, {"n": "5", "k": "-2"}, {"n": "1000", "k": "500"}, {"n": "1000", "k": "0"}, {"n": "1000", "k": "1000"}, {"n": "50", "k": "25"}, {"n": "100", "k": "101"}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [802, 737, 208, 886, -159, 751, -94]}, {"arr": [780, -189, 779, -493, 384, -714, 689]}, {"arr": [-964, 324, 456, 114, 45, 593, 594]}, {"arr": [-275, 443, 561, -117, 23, 436, -328]}, {"arr": [666, -687, -723, -849, -623, -164, -24]}, {"arr": [464, -144, 843, -341, 13, -951, 391]}, {"arr": [-899, 254, -523, 517, 679, 879, 556]}, {"arr": [-218, -17, -588, 111, -487, 443, -471]}, {"arr": [456, -276, 86, 159, 936, 464, 673]}, {"arr": [937, -293, -656, -897, 316, 138, 735]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "daacb"}, {"s": "awbcda"}, {"s": "bdaca"}, {"s": "bcda"}, {"s": "abcdFa"}, {"s": "abca"}, {"s": "caabd"}, {"s": "acbda"}, {"s": "acdba"}, {"s": "bcdaa"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": [[1, 2, 3], [2, 3, 4], [3, 4, 5]], "k": 2}, {"numbers": [[1]], "k": 1}, {"numbers": [[1, 1, 1], [2, 2], [3]], "k": 3}, {"numbers": [], "k": 5}, {"numbers": [[1, 2, 3, 4, 5]], "k": 0}, {"numbers": [[999999999, -999999999]], "k": 1}, {"numbers": [[1, 1], [1, 1], [1, 1]], "k": 1}, {"numbers": [[1], [2], [3], [4], [5]], "k": 10}, {"numbers": [[], [], []], "k": 2}, {"numbers": [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]], "k": -1}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"n": "17"}, {"n": "100"}, {"n": "1"}, {"n": "0"}, {"n": "-5"}, {"n": "2147483647"}, {"n": "999999999999"}, {"n": "2"}, {"n": "3"}, {"n": "1234567890"}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": "0"}, {"decimal_num": "1"}, {"decimal_num": "10"}, {"decimal_num": "-5"}, {"decimal_num": "2147483647"}, {"decimal_num": "-2147483648"}, {"decimal_num": "9999999999999999999999999999999999999999"}, {"decimal_num": "-9999999999999999999999999999999999999999"}, {"decimal_num": "1.5"}, {"decimal_num": "abc"}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"}, {"arr": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"}, {"arr": "[0, 1, 2, 3, 5, 6, 7, 8, 9, 10]"}, {"arr": "[1, 2, 3, 4, 5, 6, 8, 9, 10, 11]"}, {"arr": "[0, 1, 2, 4, 5, 6, 7, 8, 9, 10]"}, {"arr": "[]"}, {"arr": "[0]"}, {"arr": "[1]"}, {"arr": "[0, 2, 3, 4, 5, 6, 7, 8, 9, 10]"}, {"arr": "[0, 1, 2, 3, 4, 5, 6, 7, 8, 10]"}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 1}, {"n": 0}, {"n": -1}, {"n": 2147483647}, {"n": -2147483648}, {"n": 100}, {"n": 999}, {"n": 1000}, {"n": 65535}, {"n": 32768}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": 1, "denominator": 3, "n": 5}, {"numerator": 22, "denominator": 7, "n": 10}, {"numerator": 1, "denominator": 0, "n": 1}, {"numerator": 0, "denominator": 5, "n": 100}, {"numerator": 2147483647, "denominator": 1, "n": 1}, {"numerator": 1, "denominator": 2147483647, "n": 2147483647}, {"numerator": -1, "denominator": 3, "n": 5}, {"numerator": 1, "denominator": -7, "n": 10}, {"numerator": 0, "denominator": 0, "n": 0}, {"numerator": 1, "denominator": 2, "n": -1}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [-990, "appe", -695, "anaanb", 236, "rryehc"]}, {"mixed_list": [-130, "appl", -830, "abaann", 36, "chrry"]}, {"mixed_list": [-31, "aLpple", -478, "baana", -63, "ucherry"]}, {"mixed_list": [131, "aplep", 887, "dbanana", 685, "erryhc"]}, {"mixed_list": [572, "aple", -585, "bdanana", -160, "cher8ry"]}, {"mixed_list": [313, "eppla", 588, "baana", -29, "hyecrr"]}, {"mixed_list": [-233, "happle", -611, "banRana", -957, "herry"]}, {"mixed_list": [-984, "aple", 113, "bnanaa", -109, "hyrecr"]}, {"mixed_list": [-987, "epapl", -949, "byanana", 641, "cryrhe"]}, {"mixed_list": [-766, "pplea", 238, "banaZna", 170, "yechrr"]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [2, 1]}, {"numbers": [4, 3]}, {"numbers": [6, 5]}, {"numbers": [8, 7]}, {"numbers": [10, 9]}, {"numbers": [0, 1]}, {"numbers": [2, 0]}, {"numbers": []}, {"numbers": [2]}, {"numbers": [1]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "abbcc"}, {"s": "abbcc"}, {"s": "aabbcpc"}, {"s": "aabcc"}, {"s": "aacbcb"}, {"s": "aabbEcc"}, {"s": "cabbca"}, {"s": "aabcc"}, {"s": "caacbb"}, {"s": "awabbcc"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{"nested_list": [[924, 792, -695], ["a", "b", "c"], [712, "a", -413.45611533484873], []]}, {"nested_list": [[872, 851, -227], ["al", "b", "c"], [47, "aG", 499.2111309907448], []]}, {"nested_list": [[-50, -160, 152], ["a", "b", "c"], [-388, "ga", 571.9900933834888], []]}, {"nested_list": [[-724, -548, -701], ["a", "bI", "c"], [159, "a", -975.5104173790317], []]}, {"nested_list": [[44, -815, 671], ["a", "b", "cz"], [-245, "a4", 248.6295271634051], []]}, {"nested_list": [[-913, -326, -587], ["a", "b", "c"], [588, "a", 915.6009074938795], []]}, {"nested_list": [[884, 823, 956], ["a", "b", "c"], [-959, "a", -693.5074500018825], []]}, {"nested_list": [[-370, 957, -52], ["a", "b", "Rc"], [-298, "xa", -495.99867861197697], []]}, {"nested_list": [[-784, -622, -731], ["a", "b", "c4"], [-336, "a", -987.8093500333687], []]}, {"nested_list": [[-210, 574, 40], ["a", "b", "cy"], [-975, "az", -644.9958597363925], []]}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [-198, 956, -435, 883, -695, -182, -829, 355, -305, -85]}, {"numbers": [-116, -313, 305, -403, 171, 672, 234, -331, 690, 904]}, {"numbers": [-421, 901, -401, -877, -468, -132, -908, 606, -457, -464]}, {"numbers": [532, 996, -606, 105, -341, 587, 712, -550, 586, 291]}, {"numbers": [967, 337, 296, -371, 881, 994, 449, 266, -849, 75]}, {"numbers": [-701, 293, -315, -900, 424, 255, 733, -265, -146, -546]}, {"numbers": [-312, 740, 387, 618, -462, -969, 473, 487, 885, 575]}, {"numbers": [-364, -815, 577, 271, 406, -381, 759, 608, 847, -921]}, {"numbers": [309, 253, -49, -486, -327, -466, -576, -449, -514, 450]}, {"numbers": [469, 587, -84, -606, 100, -106, 831, -560, -365, 496]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [604, 995, 507, 161, -656, 244, -111]}, {"arr": [333, -869, -952, 552, -841, -631, 538]}, {"arr": [74, 543, -592, 917, -904, -344, -494]}, {"arr": [-279, -731, -27, -146, 544, 340, 144]}, {"arr": [-396, -94, -285, -376, 682, 9, -337]}, {"arr": [-623, 995, 607, -430, -755, -870, 907]}, {"arr": [-905, 734, -877, -97, 424, 493, -243]}, {"arr": [-345, 247, 198, -481, 216, 781, -425]}, {"arr": [293, 380, -222, 623, -938, -792, 72]}, {"arr": [369, 355, 697, -805, 894, 559, 351]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world"}, {"text": "test_case_example"}, {"text": "a_b"}, {"text": "xyz_abc"}, {"text": "no_underscore"}, {"text": "UPPER_CASE"}, {"text": "mixedCase_underscore"}, {"text": "single"}, {"text": ""}, {"text": "multiple_underscores_in_one_string_test_case"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "tet", "string": "test stXring"}, {"word": "tes7t", "string": "test sring"}, {"word": "stet", "string": "test tring"}, {"word": "tet", "string": "igttnrsst e"}, {"word": "tecst", "string": "tgterss nti"}, {"word": "tset", "string": "test stri8ng"}, {"word": "tst", "string": "ssrttneig t"}, {"word": "tst", "string": "tiest string"}, {"word": "tes", "string": "n gettsstir"}, {"word": "tst", "string": "gstseinr tt"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24]}, {"numbers": [7, 13, 29]}, {"numbers": [0, 0, 0]}, {"numbers": [-12, 18, -24]}, {"numbers": [1]}, {"numbers": []}, {"numbers": [2147483647, 2147483647]}, {"numbers": [-2147483648, -2147483648]}, {"numbers": [0, 15, 0]}, {"numbers": [1000000000, 2000000000, 3000000000]}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}, {"numbers": [1, 1, 2, 3, 4]}, {"numbers": []}, {"numbers": [5]}, {"numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1]}, {"numbers": [999999999999999999, 999999999999999999]}, {"numbers": [1.1, 1.1, 2.2]}, {"numbers": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"numbers": [-1, -1, 1, 1]}, {"numbers": [1, 2, 3, 2, 1]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"a": 5, "b": 10}, {"a": 10, "b": 5}, {"a": 0, "b": 0}, {"a": -5, "b": 10}, {"a": 1, "b": 1000}, {"a": 999, "b": 1000}, {"a": 0, "b": 1}, {"a": 1, "b": 2}, {"a": 1000000000, "b": 1000000001}, {"a": 15, "b": 20}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "255"}, {"n": "2147483647"}, {"n": "4294967295"}, {"n": "18446744073709551615"}, {"n": "-1"}, {"n": "-2147483648"}, {"n": "9223372036854775807"}, {"n": "170141183460469231731687303715884105727"}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}, {"matrix": "[]"}, {"matrix": "[[], [], []]"}, {"matrix": "[[1], [2, 3], [4, 5, 6]]"}, {"matrix": "[[1], [2], [3]]"}, {"matrix": "[[1, 2], [3, 4], [5, 6]]"}, {"matrix": "[[1], [2], [3, 4, 5]]"}, {"matrix": "[[1, 2, 3], [4], [5, 6, 7]]"}, {"matrix": "[[1], [2, 3], [4]]"}, {"matrix": "[[1, 2], [3], [4, 5]]"}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": "[[1, 2], [3, 4, 5], [6]]"}, {"lists": "[[], [1], [1, 2]]"}, {"lists": "[[1, 2, 3]]"}, {"lists": "[[], [], []]"}, {"lists": "[[1], [2], [3], [4], [5]]"}, {"lists": "[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]"}, {"lists": "[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]]"}, {"lists": "[[1], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]]"}, {"lists": "[[1, 2, 3, 4, 5], [6, 7], [8, 9, 10, 11], [12]]"}, {"lists": "[[1, 2, 3], [4, 5], [6, 7, 8, 9], [10, 11, 12], [13, 14]]"}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": "1", "side2": "1", "side3": "1"}, {"side1": "0", "side2": "0", "side3": "0"}, {"side1": "-1", "side2": "-1", "side3": "-1"}, {"side1": "9999999999999999999999999999999999999999", "side2": "9999999999999999999999999999999999999999", "side3": "9999999999999999999999999999999999999999"}, {"side1": "1.1", "side2": "1.1", "side3": "1.1"}, {"side1": "A", "side2": "A", "side3": "A"}, {"side1": "", "side2": "", "side3": ""}, {"side1": "1", "side2": "1", "side3": "2"}, {"side1": "0.0000000000000000000000000000000000000001", "side2": "0.0000000000000000000000000000000000000001", "side3": "0.0000000000000000000000000000000000000001"}, {"side1": "null", "side2": "null", "side3": "null"}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": 5.0, "height": 3.0}, {"base": 0.0, "height": 10.0}, {"base": -5.0, "height": 3.0}, {"base": 3.0, "height": -10.0}, {"base": "1.7976931348623157E+308", "height": "1.7976931348623157E+308"}, {"base": "2.2250738585072014E-308", "height": "2.2250738585072014E-308"}, {"base": "NaN", "height": 5.0}, {"base": 5.0, "height": "NaN"}, {"base": "Infinity", "height": 10.0}, {"base": 10.0, "height": "Infinity"}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "tset"}, {"s": "test"}, {"s": "ttse"}, {"s": "stte"}, {"s": "est"}, {"s": "ttes"}, {"s": "etst"}, {"s": "tAest"}, {"s": "teskt"}, {"s": "est"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": []}, {"arr": [5, 5, 5, 5, 5]}, {"arr": [-10, -5, 0, 5, 10]}, {"arr": [1000000, -1000000]}, {"arr": [0]}, {"arr": [2147483647, -2147483648]}, {"arr": [1, 3, 2, 3, 1]}, {"arr": [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]}, {"arr": [1, 2, 1, 2, 1, 2]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": "1"}, {"r": "0"}, {"n": "1"}, {"a": "0", "r": "2", "n": "5"}, {"a": "-1", "r": "2", "n": "3"}, {"a": "1", "r": "-2", "n": "4"}, {"a": "1", "r": "2", "n": "0"}, {"a": "1", "r": "1", "n": "1000000000"}, {"a": "999999999", "r": "999999999", "n": "999999999"}, {"a": "-999999999", "r": "-999999999", "n": "999999999"}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"n": "123"}, {"n": "0"}, {"n": "1"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "-123"}, {"n": "18446744073709551616"}, {"n": "3.14"}, {"n": "abc"}, {"n": "null"}, {"n": "2147483647"}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [1, 2, 3, 4, 5]}, {"digits": [0, 0, 0, 0]}, {"digits": [9, 9, 9, 9, 9]}, {"digits": [1, 34, 3, 98, 9, 76, 45, 4]}, {"digits": [999, 99, 9]}, {"digits": [121, 12]}, {"digits": [830, 8308]}, {"digits": [0]}, {"digits": [10, 2]}, {"digits": [3, 30, 34, 5, 9]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"a": "0", "b": "0"}, {"a": "1", "b": "1"}, {"a": "-1", "b": "-1"}, {"a": "2147483647", "b": "-2147483648"}, {"a": "-1", "b": "1"}, {"a": "0", "b": "-1"}, {"a": "0", "b": "1"}, {"a": "9223372036854775807", "b": "-9223372036854775808"}, {"a": "-9223372036854775808", "b": "9223372036854775807"}, {"a": "18446744073709551615", "b": "-1"}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "2"}, {"n": "-1"}, {"n": "-2147483648"}, {"n": "2147483647"}, {"n": "9223372036854775807"}, {"n": "-9223372036854775808"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": []}, {"arr": [1]}, {"arr": [1, 2, 3, 4, 5]}, {"arr": [1, 1, 1, 1, 1]}, {"arr": [1, 2, 2, 3, 4, 4, 5]}, {"arr": [1, 2, 3, 2, 1]}, {"arr": [1, 1, 2, 2, 3, 3]}, {"arr": [1, 2, 1, 2, 1, 2]}, {"arr": [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]}, {"arr": [2147483647, -2147483648, 0, 1, -1]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "10g1"}, {"s": "1i01"}, {"s": "110"}, {"s": "110"}, {"s": "01"}, {"s": "110"}, {"s": "11"}, {"s": "10"}, {"s": "10"}, {"s": "110"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [716, 873, -572, 243, -649]}, {"numbers": [122, 726, -606, -428, 663]}, {"numbers": [-569, -542, -179, -169, -525]}, {"numbers": [261, 594, 746, -928, 257]}, {"numbers": [-80, -561, -31, 836, 509]}, {"numbers": [-349, 409, -947, 254, -145]}, {"numbers": [-335, 549, 74, -983, -237]}, {"numbers": [-188, -878, 540, -351, 571]}, {"numbers": [571, -88, -685, 194, 372]}, {"numbers": [409, 179, 983, 475, -219]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": "[[1, 2], [3, 4], [5, 6]]"}, {"pairs": "[[0, 0], [0, 0]]"}, {"pairs": "[[1000000, 1000000], [-1000000, -1000000]]"}, {"pairs": "[[0, 0]]"}, {"pairs": "[]"}, {"pairs": "[[1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1], [1, 1]]"}, {"pairs": "[[999999999, 999999999], [-999999999, -999999999]]"}, {"pairs": "[[1.5, 2.5], [3.5, 4.5]]"}, {"pairs": "[[\"a\", \"b\"], [\"c\", \"d\"]]"}, {"pairs": "[null, [1, 2]]"}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{"tuples_list": "[]"}, {"tuples_list": "[(\"a\", 1), (\"b\", 2), (\"c\", 3)]"}, {"tuples_list": "[(1, 2, 3), (4, 5, 6), (7, 8, 9)]"}, {"tuples_list": "[(\"x\",), (\"y\",), (\"z\",)]"}, {"tuples_list": "[(1,), (2,), (3,)]"}, {"tuples_list": "[(1, 2), (3, 4), (5, 6)]"}, {"tuples_list": "[(1, 2), (3, 4), (5, 6)]", "sort_index": "1"}, {"tuples_list": "[(1, 2), (3, 4), (5, 6)]", "sort_index": "0"}, {"tuples_list": "[(1, 2), (3, 4), (5, 6)]", "sort_index": "2"}, {"tuples_list": "[(1, 2), (3, 4), (5, 6)]", "reverse": "true"}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [462, [657, -286], [-955, [-579, 490]], -133]}, {"lst": [681, [747, -142], [545, [452, 15]], -872]}, {"lst": [-130, [-611, -423], [944, [810, 190]], 65]}, {"lst": [-725, [-39, 981], [-455, [846, 809]], -410]}, {"lst": [-353, [158, -526], [106, [236, -13]], 160]}, {"lst": [741, [639, -123], [333, [248, -4]], 32]}, {"lst": [705, [-721, -565], [842, [-164, -411]], -647]}, {"lst": [716, [779, -403], [-984, [776, 456]], 884]}, {"lst": [-649, [482, 11], [-315, [-448, 671]], 443]}, {"lst": [-993, [-932, -953], [486, [558, 327]], 122]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}, {"numbers": [-1, -2, -3, -4, -5]}, {"numbers": [0, 0, 0, 0, 0]}, {"numbers": [1, -1, 2, -2, 3, -3]}, {"numbers": [999999999999999999999999999999]}, {"numbers": [-999999999999999999999999999999]}, {"numbers": [0.1, 1e-30]}, {"numbers": [-0.1, -1e-30]}, {"numbers": [1, "2", 3]}, {"numbers": [null, "undefined", true, false]}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "5"}, {"n": "10"}, {"n": "-1"}, {"n": "-2147483648"}, {"n": "2147483647"}, {"n": "1000"}, {"n": "999"}, {"n": "50"}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [5, 4, 3, 2, 1]}, {"arr": [1, 1, 1, 1, 1]}, {"arr": [1, 3, 2, 4, 5]}, {"arr": []}, {"arr": [1]}, {"arr": [1, 2, 2, 3, 4]}, {"arr": [5, 5, 4, 3, 2]}, {"arr": [1, 2, 3, 2, 1]}, {"arr": [1, 2, 3, 4, 3]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": [1, 2, 3], "sublist": [2]}, {"main_list": [], "sublist": []}, {"main_list": [1, 2, 3, 4, 5], "sublist": [3, 4]}, {"main_list": [1, 2, 3], "sublist": [4]}, {"main_list": ["a", "b", "c"], "sublist": ["b", "c"]}, {"main_list": [1, 1, 1, 2, 2, 2], "sublist": [1, 1, 2]}, {"main_list": [1], "sublist": [1, 2]}, {"main_list": [1, 2, 3, 4, 5], "sublist": []}, {"main_list": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "sublist": [9, 10]}, {"main_list": [1, 2, 3], "sublist": [1, 2, 3, 4]}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [5, 4, 3, 2, 1]}, {"arr": [1]}, {"arr": []}, {"arr": [3, 3, 3, 3, 3]}, {"arr": [1, 3, 2, 5, 4]}, {"arr": [999999999, -999999999, 0]}, {"arr": [2.5, 1.1, 4.8, 3.3]}, {"arr": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]}, {"arr": [2147483647, -2147483648, 0, 1, -1]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "2"}, {"n": "3"}, {"n": "4"}, {"n": "-1"}, {"n": "2147483647"}, {"n": "-2147483648"}, {"n": "1000000000"}, {"n": "-1000000000"}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "hello,world", "delimiters": [","]}, {"text": "a.b.c", "delimiters": ["."]}, {"text": "x", "delimiters": ["x"]}, {"text": "", "delimiters": [","]}, {"text": "test", "delimiters": []}, {"text": "a|b|c", "delimiters": ["|"]}, {"text": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", "delimiters": ["x"]}, {"text": "abc", "delimiters": ["", ""]}, {"text": "special.regex*chars", "delimiters": [".", "*", "+", "?", "^", "$", "(", ")", "[", "]", "{", "}", "|", "\\"]}, {"text": "a.b.c", "delimiters": ["."]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": [-902, -607, 591, 98], "patterns": [["Ay", "B", "yA", "B"], ["X", "zY", "XH", "Y"]]}, {"sequence": [110, 563, -314, 889], "patterns": [["A", "B", "A", "B"], ["X", "Y", "X", "YV"]]}, {"sequence": [59, 796, 117, -398], "patterns": [["A", "jB", "EA", "BF"], ["X", "Y", "X", "Y"]]}, {"sequence": [766, -230, 443, 981], "patterns": [["A", "7B", "Ag", "B"], ["X", "Y", "X", "YK"]]}, {"sequence": [-994, 829, 845, 47], "patterns": [["kA", "nB", "SA", "tB"], ["Xz", "Y", "X", "Y"]]}, {"sequence": [-924, 541, -452, 733], "patterns": [["A", "B", "A", "B"], ["Xb", "Y", "XM", "YZ"]]}, {"sequence": [-203, -168, -406, -972], "patterns": [["bA", "B", "A", "4B"], ["X", "uY", "X", "YX"]]}, {"sequence": [594, -280, 974, -10], "patterns": [["A", "B", "IA", "B"], ["X", "KY", "3X", "Y"]]}, {"sequence": [646, 221, 839, 825], "patterns": [["AR", "B", "A", "B"], ["Xv", "Y", "XA", "YN"]]}, {"sequence": [915, -791, 723, -211], "patterns": [["eA", "dB", "A", "qB"], ["X", "Y", "RX", "Y"]]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{"tuple_list": "[]", "k": "1"}, {"tuple_list": "[(2, 4, 6), (1, 3, 5), (8, 10, 12)]", "k": "2"}, {"tuple_list": "[(0, 0, 0), (0, 0)]", "k": "0"}, {"tuple_list": "[(-4, -8, -12), (3, 6, 9)]", "k": "-2"}, {"tuple_list": "[(1000000, 2000000), (999999, 1999999)]", "k": "1000000"}, {"tuple_list": "[(1,), (2,), (3,)]", "k": "1"}, {"tuple_list": "[(1.5, 3.0), (2.5, 5.0)]", "k": "0.5"}, {"tuple_list": "[()]", "k": "1"}, {"tuple_list": "[('a', 'b'), (1, 2)]", "k": "1"}, {"tuple_list": "[(9223372036854775807, 18446744073709551614)]", "k": "9223372036854775807"}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": "5", "width": "3"}, {"length": "1", "width": "1"}, {"length": "0", "width": "5"}, {"length": "5", "width": "0"}, {"length": "0", "width": "0"}, {"length": "-1", "width": "5"}, {"length": "5", "width": "-1"}, {"length": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999", "width": "1"}, {"length": "1", "width": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"length": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999", "width": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": "12345"}, {"num": "24680"}, {"num": "13579"}, {"num": "0"}, {"num": "-12345"}, {"num": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"num": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"num": "18446744073709551615"}, {"num": "1.5"}, {"num": "12a34"}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": "5"}, {"n": "0"}, {"n": "1"}, {"n": "100"}, {"n": "999"}, {"n": "1000"}, {"n": "2147483647"}, {"n": "-1"}, {"n": "-2147483648"}, {"n": "99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "tSest"}, {"word": "tset"}, {"word": "etts"}, {"word": "etest"}, {"word": "tes"}, {"word": "testh"}, {"word": "estt"}, {"word": "tst"}, {"word": "tst"}, {"word": "est"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "5"}, {"n": "100"}, {"n": "-1"}, {"n": "-100"}, {"n": "2147483647"}, {"n": "-2147483648"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{"tuple1": "()", "tuple2": "()"}, {"tuple1": "(1, 2, 3)", "tuple2": "('a', 'b', 'c')"}, {"tuple1": "(1,)", "tuple2": "('a', 'b')"}, {"tuple1": "(1, 2)", "tuple2": "('a',)"}, {"tuple1": "('x' * 1000,)", "tuple2": "('y' * 1000,)"}, {"tuple1": "(None,)", "tuple2": "(None,)"}, {"tuple1": "(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)", "tuple2": "('a',)"}, {"tuple1": "('',)", "tuple2": "('',)"}, {"tuple1": "(1, 2.5, 'mixed')", "tuple2": "(True, [], {})"}, {"tuple1": "(1, 2, 3, 4, 5)", "tuple2": "('a', 'b', 'c', 'd', 'e')"}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": "1.0"}, {"radius": "0.0"}, {"radius": "-1.0"}, {"radius": "999999999.0"}, {"radius": "-999999999.0"}, {"radius": "1e-10"}, {"radius": "1e308"}, {"radius": "NaN"}, {"radius": "Infinity"}, {"radius": "-Infinity"}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "ac"}, {"s": "abc"}, {"s": "ab"}, {"s": "bc"}, {"s": "Oabc"}, {"s": "aibc"}, {"s": "bc"}, {"s": "abcJ"}, {"s": "a9bc"}, {"s": "ab"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": "1"}, {"n": "2"}, {"n": "5"}, {"n": "10"}, {"n": "0"}, {"n": "-1"}, {"n": "10000"}, {"n": "999999"}, {"n": "2147483647"}, {"n": "-2147483648"}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": "1.0"}, {"radius": "0.0"}, {"radius": "-1.0"}, {"radius": "99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"radius": "1e308"}, {"radius": "1e-308"}, {"radius": "NaN"}, {"radius": "Infinity"}, {"radius": "-Infinity"}, {"radius": "0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"n": "1"}, {"n": "2"}, {"n": "0"}, {"n": "-1"}, {"n": "100"}, {"n": "1000"}, {"n": "-100"}, {"n": "2147483647"}, {"n": "-2147483648"}, {"n": "999999999"}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": "{}", "dict2": "{}", "dict3": "{}"}, {"dict1": "{\"key1\": \"value1\"}", "dict2": "{\"key2\": \"value2\"}", "dict3": "{\"key3\": \"value3\"}"}, {"dict1": "{\"a\": 1, \"b\": 2}", "dict2": "{\"c\": 3, \"d\": 4}", "dict3": "{\"e\": 5, \"f\": 6}"}, {"dict1": "{\"same\": \"first\"}", "dict2": "{\"same\": \"second\"}", "dict3": "{\"same\": \"third\"}"}, {"dict1": "{\"nested\": {\"inner\": \"value\"}}", "dict2": "{\"flat\": \"data\"}", "dict3": "{\"another\": \"item\"}"}, {"dict1": "{\"list\": [1, 2, 3]}", "dict2": "{\"tuple\": (4, 5, 6)}", "dict3": "{\"set\": {7, 8, 9}}"}, {"dict1": "{\"null\": null}", "dict2": "{\"bool\": true}", "dict3": "{\"number\": 42}"}, {"dict1": "{\"empty\": \"\"}", "dict2": "{\"long\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"}", "dict3": "{\"special\": \"!@#$%^&*()\"}"}, {"dict1": "{\"deep\": {\"level1\": {\"level2\": {\"level3\": \"value\"}}}}", "dict2": "{\"array\": [{\"obj\": 1}, {\"obj\": 2}]}", "dict3": "{\"mixed\": [1, \"two\", {\"three\": 3}]}"}, {"dict1": "{\"unicode\": \"こんにちは\"}", "dict2": "{\"escape\": \"line1\\nline2\\ttab\"}", "dict3": "{\"quotes\": \"He said, \\\"Hello!\\\"\"}"}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": [1, 2, 3, 4, 5]}, {"elements": [1, 1, 1, 1, 1]}, {"elements": []}, {"elements": [null, null, null]}, {"elements": ["a", "b", "a", "c", "b", "a"]}, {"elements": [1, "1", 1.0, "1.0"]}, {"elements": [{"key": "value"}, {"key": "value"}, {"key": "different"}]}, {"elements": [[1, 2], [1, 2], [3, 4]]}, {"elements": [true, false, true, true, false]}, {"elements": [1.1, 2.2, 1.1, 3.3, 2.2, 1.1]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": "12345"}, {"n": "54321"}, {"n": "1000"}, {"n": "9999"}, {"n": "0"}, {"n": "-1"}, {"n": "10"}, {"n": "21"}, {"n": "332"}, {"n": "987654321"}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "The quick brown fox jumps over th lazy dog"}, {"sentence": "hvr oudaowuopqex ejok bstmlh cgeizy Tr n f "}, {"sentence": "sd  vo ykluo tgiho nwurrebpf zhqm oaexej Tc"}, {"sentence": "The quick brwn fox jumps over the lazy dog"}, {"sentence": "The quicku brown fox jumps over the lazy dog"}, {"sentence": "rj ohmyifghxee r scpboTtvneo k u zouaqwd l "}, {"sentence": "The quiIck brown fox jumps over the lazy dog"}, {"sentence": "The uick brown fox jumps over the lazy dog"}, {"sentence": "The quick brown fox jumps over the lay dog"}, {"sentence": "The quick brown fox jumps over the lzy dog"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"substring": "test", "string_list": ["iegsttn", "exmple", "tgnsir"]}, {"substring": "teest", "string_list": ["testVing", "exampl", "strin"]}, {"substring": "testa", "string_list": ["testng", "ampxlee", "gstrni"]}, {"substring": "est", "string_list": ["teesting", "expemal", "sting"]}, {"substring": "tste", "string_list": ["tes1ting", "xepaeml", "sting"]}, {"substring": "est", "string_list": ["tesPting", "xample", "nigtsr"]}, {"substring": "tEest", "string_list": ["esting", "examOple", "strig"]}, {"substring": "tst", "string_list": ["testHing", "exampe", "strig"]}, {"substring": "tst", "string_list": ["tsting", "xample", "stzring"]}, {"substring": "tes", "string_list": ["testng", "xmaeple", "sring"]}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"n": 1063}, {"n": 521}, {"n": 870}, {"n": 892}, {"n": -780}, {"n": -316}, {"n": 51}, {"n": -622}, {"n": 481}, {"n": 942}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": "2"}, {"a": "0"}, {"a": "-1"}, {"a": "1000000000"}, {"a": "0.5"}, {"a": "-1000000000"}, {"a": "1"}, {"a": "999999999"}, {"a": "0.00000000000000000000000000000000000000000000000001"}, {"a": "-999999999"}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": "[1, 2, 3, 4, 5]"}, {"records": "[5, 4, 3, 2, 1]"}, {"records": "[3, 1, 4, 1, 5]"}, {"records": "[0]"}, {"records": "[-5, -2, -10, -1]"}, {"records": "[999999999, -999999999]"}, {"records": "[3.14, 2.71, 1.41]"}, {"records": "[]"}, {"records": "[null, 1, 2]"}, {"records": "[\"a\", \"b\", \"c\"]"}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5], "target": 10}, {"nums": [1, 4, 4], "target": 4}, {"nums": [1, 1, 1, 1, 1, 1, 1, 1], "target": 7}, {"nums": [100], "target": 50}, {"nums": [5, 1, 3, 5, 10, 7, 4, 9, 2, 8], "target": 15}, {"nums": [1, 2, 3], "target": 100}, {"nums": [], "target": 5}, {"nums": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "target": 1}, {"nums": [-1, -2, -3, 10, -4, -5], "target": 6}, {"nums": [2147483647, 1], "target": 2147483647}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": "25"}, {"n": "0"}, {"n": "-1"}, {"n": "1"}, {"n": "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "2"}, {"n": "100"}, {"n": "99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "6.5"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": [["px", "y", "z"], ["Ea", "1b", "c"], ["x", "y", "qz"]]}, {"lst": [["x", "y", "zY"], ["a", "b", "c"], ["x", "y", "z"]]}, {"lst": [["ax", "y", "zr"], ["a", "ob", "c"], ["xT", "y", "zO"]]}, {"lst": [["xx", "y", "zt"], ["aF", "b", "c"], ["7x", "y", "z"]]}, {"lst": [["xC", "y", "z"], ["a", "b", "c"], ["xa", "y", "kz"]]}, {"lst": [["gx", "y", "z"], ["Na", "b", "cq"], ["xa", "y", "z"]]}, {"lst": [["x7", "y", "z"], ["aA", "b", "c"], ["x", "yH", "z"]]}, {"lst": [["x", "y", "Tz"], ["a", "bb", "cT"], ["x", "y", "z"]]}, {"lst": [["xO", "y", "z"], ["a", "bD", "c"], ["x1", "yQ", "z"]]}, {"lst": [["x", "y", "z1"], ["a", "2b", "1c"], ["x", "yq", "z"]]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [1, 2, 3]}, {"numbers": []}, {"numbers": [0, 5, 10]}, {"numbers": [1000000, 1000000, 1000000]}, {"numbers": [-1, -2, -3]}, {"numbers": [0.1, 0.2, 0.3]}, {"numbers": [1]}, {"numbers": [999999999, 999999999, 999999999]}, {"numbers": [1, 0, 1]}, {"numbers": [-1000000, 1000000, -1000000]}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": "0"}, {"decimal_num": "1"}, {"decimal_num": "42"}, {"decimal_num": "-42"}, {"decimal_num": "2147483647"}, {"decimal_num": "-2147483648"}, {"decimal_num": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"decimal_num": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"decimal_num": "18446744073709551615"}, {"decimal_num": "-9223372036854775808"}]}
{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 2}, {"cost": [[0, 0, 0], [0, 0, 0], [0, 0, 0]], "m": 2, "n": 2}, {"cost": [[1]], "m": 0, "n": 0}, {"cost": [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]], "m": 2, "n": 2}, {"cost": [[999999999, 999999999], [999999999, 999999999]], "m": 1, "n": 1}, {"cost": [[1, 2], [3, 4]], "m": -1, "n": 1}, {"cost": [[1, 2], [3, 4]], "m": 1, "n": -1}, {"cost": [[1, 2], [3, 4]], "m": 10, "n": 1}, {"cost": [[1, 2], [3, 4]], "m": 1, "n": 10}, {"cost": [], "m": 0, "n": 0}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": "()", "test_tup2": "()"}, {"test_tup1": "(1, 2, 3)", "test_tup2": "(2, 3, 4)"}, {"test_tup1": "(1, 1, 1)", "test_tup2": "(1, 2, 3)"}, {"test_tup1": "('a', 'b', 'c')", "test_tup2": "('c', 'd', 'e')"}, {"test_tup1": "(1, 2, 3, 4, 5)", "test_tup2": "(6, 7, 8, 9, 10)"}, {"test_tup1": "(1,)", "test_tup2": "(1,)"}, {"test_tup1": "([1, 2], [3, 4])", "test_tup2": "([1, 2], [5, 6])"}, {"test_tup1": "(None, True, False)", "test_tup2": "(None, 0, 1)"}, {"test_tup1": "(1.1, 2.2, 3.3)", "test_tup2": "(2.2, 3.3, 4.4)"}, {"test_tup1": "('x' * 1000, 'y' * 1000)", "test_tup2": "('x' * 1000, 'z' * 1000)"}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [2, 3, 5, 7, 11]}, {"numbers": [1, 4, 6, 8, 9]}, {"numbers": [0, 1, -1, -2, -3]}, {"numbers": [9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999]}, {"numbers": [1.5, 2.5, 3.7, 4.2]}, {"numbers": [2147483647, 2147483648, 4294967295, 4294967296]}, {"numbers": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]}, {"numbers": [1]}, {"numbers": [2]}, {"numbers": [4]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [87, -69, 1001, 12, -392, -920], "k": 0}, {"numbers": [295, 359, 770, 22, -411, -779], "k": -570}, {"numbers": [6, 831, -46, -689, -758, -244], "k": -688}, {"numbers": [-751, 479, 0, -43, -368, -424], "k": 154}, {"numbers": [-330, -778, -595, -515, 354, 752], "k": -579}, {"numbers": [-971, 776, 425, 120, 234, 136], "k": -345}, {"numbers": [255, 883, -462, 467, 260, 823], "k": -490}, {"numbers": [-449, 737, 875, 182, 56, -290], "k": -886}, {"numbers": [410, 564, 64, -150, 105, 212], "k": -73}, {"numbers": [-978, -512, 609, 238, 428, -537], "k": -338}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": "0"}, {"n": "2"}, {"n": "4"}, {"n": "8"}, {"n": "-2"}, {"n": "100"}, {"n": "999"}, {"n": "1000"}, {"n": "1"}, {"n": "3"}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": "0", "b": "0"}, {"a": "1", "b": "0"}, {"a": "3", "b": "1"}, {"a": "7", "b": "3"}, {"a": "15", "b": "7"}, {"a": "2147483647", "b": "2147483646"}, {"a": "-1", "b": "-2"}, {"a": "0", "b": "18446744073709551615"}, {"a": "255", "b": "127"}, {"a": "1000", "b": "1001"}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "The quick brown fox jumps ver the lazy dog"}, {"text": "Thequick brown fox jumps over the lazy dog"}, {"text": "The quick brown fox jumUps over the lazy dog"}, {"text": "The quick brown foxjumps over the lazy dog"}, {"text": "The quick brownfox jumps over the lazy dog"}, {"text": "The quick bown fox jumps over the lazy dog"}, {"text": "crwp shimzh ekljye  ubovotxogqeTdofnua  r  "}, {"text": "The quickW brown fox jumps over the lazy dog"}, {"text": " isvcjrhueeo d hnot   Tpyk oueqozxbwmgf arl"}, {"text": " zf trwuroilToe  nqmc x bsekhu phjvya doego"}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [756.5645337380677, 832.1986649045402, 879.337818141948, -730.5275988459846, -331.21706079522505]}, {"numbers": [-9.571193568097897, 422.62980977465895, -291.21887688994855, 361.0156498828658, -994.8033333263692]}, {"numbers": [-963.1209669748363, -308.38379112755024, -697.035543323845, -769.5807968410724, 913.0113614105853]}, {"numbers": [-550.4255960786004, -521.9115238748357, -136.67216740036406, -839.5018924158269, -144.06733913486732]}, {"numbers": [-558.4468955009155, 383.281169740535, 912.3733962685112, 386.39785269281447, -60.47081182147997]}, {"numbers": [907.6512259011192, 336.76084696277076, -439.01155605284305, 736.5889098744608, -127.26420717950123]}, {"numbers": [-364.0527744533747, 824.3743725075901, -672.044527874833, 156.47258988120916, 988.5074928116983]}, {"numbers": [344.90941787032966, -464.4065901456065, 147.0819911204394, 311.18466246818707, -744.0135734834403]}, {"numbers": [-657.6387754909277, -364.6553743374983, -299.5273876487073, -773.3514420591745, 279.80716471129244]}, {"numbers": [-396.17861286595155, 545.0188701540305, 987.1930963570323, 381.2398987464426, 694.3394996129819]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": ""}, {"s": "a"}, {"s": "aa"}, {"s": "ab"}, {"s": "abc"}, {"s": "aaa"}, {"s": "aba"}, {"s": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"}, {"s": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"}, {"s": "abcabc"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": "[]", "n": "0"}, {"dataset": "[1, 2, 3]", "n": "2"}, {"dataset": "[5, 1, 8, 3, 9, 2]", "n": "3"}, {"dataset": "[-5, -2, -10, -1]", "n": "2"}, {"dataset": "[1]", "n": "1"}, {"dataset": "[1, 2, 3, 4, 5]", "n": "10"}, {"dataset": "[3.14, 2.71, 1.41, 1.73]", "n": "2"}, {"dataset": "[9223372036854775807, -9223372036854775808]", "n": "1"}, {"dataset": "[null, 1, 2]", "n": "2"}, {"dataset": "[1, 2, 3]", "n": "-1"}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "tststring", "char": "t"}, {"s": "theststring", "char": "8t"}, {"s": "tetstring", "char": "t6"}, {"s": "teststrivng", "char": "t"}, {"s": "cteststring", "char": "tS"}, {"s": "teststing", "char": "t"}, {"s": "tesBtstring", "char": "t"}, {"s": "tReststring", "char": "t"}, {"s": "nrtsisettg", "char": "t"}, {"s": "tetstring", "char": "t"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}, {"matrix": "[[0, 0, 0], [0, 0, 0], [0, 0, 0]]"}, {"matrix": "[[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]"}, {"matrix": "[[999999999, 999999999], [1, 1]]"}, {"matrix": "[[], [], []]"}, {"matrix": "[[0]]"}, {"matrix": "[[9223372036854775807, 9223372036854775807], [-9223372036854775808, -9223372036854775808]]"}, {"matrix": "[[1.5, 2.5, 3.5], [0.1, 0.2, 0.3]]"}, {"matrix": "[[\"1\", \"2\", \"3\"], [\"4\", \"5\", \"6\"]]"}, {"matrix": "[[None, None], [True, False]]"}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "daet": 1}, "n": 811}, {"word_dict": {"apple": 739, "banana": 3, "cherry": 5, "date": 1}, "n": 451}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 308}, "n": 536}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5}, "n": -635}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 46}, "n": -718}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": -567}, "n": -859}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5}, "n": -306}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 1, "IYHgfAL3": "tyODMe"}, "n": 544}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 1, "5C3U5iBVPsg0JO2km": "HnA2EzD0byiLpvc"}, "n": 869}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 1, "MGi8xdd": "OAJaoRcTlUvlX2E326Y"}, "n": 603}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": [3.0, 4.0], "height": 5.0}, {"base_triangle": [0.0, 4.0], "height": 5.0}, {"base_triangle": [3.0, 0.0], "height": 5.0}, {"base_triangle": [0.0, 0.0], "height": 5.0}, {"base_triangle": [3.0, 4.0], "height": 0.0}, {"base_triangle": [-3.0, 4.0], "height": 5.0}, {"base_triangle": [3.0, -4.0], "height": 5.0}, {"base_triangle": [-3.0, -4.0], "height": 5.0}, {"base_triangle": [100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000], "height": 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000}, {"base_triangle": [1e-308, 1e-308], "height": 1e-308}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "HetlloWorld"}, {"s": "drWlolHole"}, {"s": "HleorllWdo"}, {"s": "oodleHlWlr"}, {"s": "HelloWorl"}, {"s": "RHelloWorld"}, {"s": "HelloWorl8d"}, {"s": "oroldlHleW"}, {"s": "HelloWorl"}, {"s": "rWleooHlld"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world test_cae another_example_string"}, {"text": "hello_worhld test_case another_example_string"}, {"text": "tseitr_shpaeo_ow eenlre_smel_l ntxtoagrlhcad"}, {"text": "hello_world test_ase another_example_string"}, {"text": "hello_world test_case another_exmple_string"}, {"text": "hello_world test_cgase another_example_string"}, {"text": "hello_world test_cas another_example_string"}, {"text": "elir_med_ ganrsee oswlteottr_xoanhltch_lpsae"}, {"text": "helGlo_world test_case another_example_string"}, {"text": "hello_world test_case another_eample_string"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": 5.0}, {"side_length": 3.5}, {"side_length": 0.0}, {"side_length": -1.0}, {"side_length": "1.7976931348623157E+308"}, {"side_length": "-1.7976931348623157E+308"}, {"side_length": "2.2250738585072014E-308"}, {"side_length": "-2.2250738585072014E-308"}, {"side_length": "3.4028234663852886E+38"}, {"side_length": "-3.4028234663852886E+38"}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "hello", "str2": "lo"}, {"str1": "test", "str2": ""}, {"str1": "", "str2": "abc"}, {"str1": "", "str2": ""}, {"str1": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "str2": "a"}, {"str1": "abc123", "str2": "123"}, {"str1": "special!@#$%", "str2": "!@#$"}, {"str1": "spaces here", "str2": " "}, {"str1": "unicode café", "str2": "é"}, {"str1": "mixedCASE", "str2": "CASE"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5]}, {"nums": [1, 2, 3, 2, 4]}, {"nums": []}, {"nums": [1]}, {"nums": [1, 1]}, {"nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1]}, {"nums": [0, 0, 0, 0, 0]}, {"nums": [-1, 1, -1]}, {"nums": [999999999, 999999999]}, {"nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607, 608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618, 619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629, 630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668, 669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785, 786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 800, 801, 802, 803, 804, 805, 806, 807, 808, 809, 810, 811, 812, 813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823, 824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 856, 857, 858, 859, 860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870, 871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892, 893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 930, 931, 932, 933, 934, 935, 936, 937, 938, 939, 940, 941, 942, 943, 944, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970, 971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981, 982, 983, 984, 985, 986, 987, 988, 989, 990, 991, 992, 993, 994, 995, 996, 997, 998, 999, 1000]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": 1}, {"n": 7}, {"n": 23}, {"n": 0}, {"n": -1}, {"n": -2147483648}, {"n": 2147483647}, {"n": 999999999}, {"n": 1.5}, {"n": "1"}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": "3", "m": "4"}, {"n": "5", "m": "3"}, {"n": "0", "m": "10"}, {"n": "10", "m": "0"}, {"n": "-5", "m": "4"}, {"n": "5", "m": "-3"}, {"n": "2147483647", "m": "2"}, {"n": "1", "m": "1000"}, {"n": "1000000", "m": "1000"}, {"n": "-2147483648", "m": "2"}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [1, 2, 3, 2, 1]}, {"arr": []}, {"arr": [1]}, {"arr": [1, 1]}, {"arr": [null, null]}, {"arr": [1.1, 2.2, 1.1]}, {"arr": [9999999999, 9999999999]}, {"arr": [-1, -2, -1]}, {"arr": ["a", "b", "a"]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6]]}, {"lists": [[], [], []]}, {"lists": [[-1, -2, -3], [-4, -5]]}, {"lists": [[1000000, 1000000], [2000000, 2000000]]}, {"lists": [[0, 0, 0], [0]]}, {"lists": [[1], [2], [3], [4], [5]]}, {"lists": [[-10, 5, -3], [8, -2, 4]]}, {"lists": [[999999999, 1], [-999999999, -1]]}, {"lists": [[1.5, 2.5], [3.7, 4.3]]}, {"lists": [[], [1], [], [2, 3], []]}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "0101"}, {"binary_str": "101"}, {"binary_str": "1100"}, {"binary_str": "1k010"}, {"binary_str": "110"}, {"binary_str": "100"}, {"binary_str": "100"}, {"binary_str": "010"}, {"binary_str": "010"}, {"binary_str": "1f010"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [1, 1, 2, 2, 3, 3]}, {"arr": [1]}, {"arr": [1, 1, 1, 1, 1]}, {"arr": [0, 1, 2, 3, 4]}, {"arr": [10, 20, 30, 10, 20, 40]}, {"arr": [-1, -2, -3, -1, -2]}, {"arr": [100, 200, 300, 400, 500]}, {"arr": [2, 3, 5, 7, 11, 13]}, {"arr": [1, 2, 3, 2, 4, 3, 5]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{"tuple_list": "[]"}, {"tuple_list": "[()]"}, {"tuple_list": "[(1,)]"}, {"tuple_list": "[(1, 2)]"}, {"tuple_list": "[(1, 2, 3)]"}, {"tuple_list": "[(1,), (2, 3)]"}, {"tuple_list": "[(1, 2), (3,)]"}, {"tuple_list": "[(1, 2), (3, 4), (5, 6)]"}, {"tuple_list": "[(1, 2, 3), (4, 5, 6)]"}, {"tuple_list": "[(1, 2), (3, 4, 5)]"}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["a1bD2c3", "H4def5", "7ghi6j7k8", "mnoB9p0q", "rstyuvwxyz"]}, {"strings": ["a12c3", "4Xdef5", "i7j68khg", "op9mqn0", "rstuvwxy"]}, {"strings": ["a1b2c34", "4f5de", "ghi6j7k98", "q09pomn", "tvuxzyrsw"]}, {"strings": ["a1ba2c3", "4ef5", "ghi6jT7k8", "mno9Pp0q", "yxvutswzr"]}, {"strings": ["1b2c3", "4ef5", "gi8j6kh7", "9q0pnom", "rxuzwystv"]}, {"strings": ["21abc3", "4def", "gi6j7k8", "om09npq", "Trstuvwxyz"]}, {"strings": ["a1b2c", "d5f4e", "gk76ji8h", "9pn0qmo", "rsteuvwxyz"]}, {"strings": ["a1b2nc3", "B4def5", "h76kij8g", "qnpmo90", "ztxsvrywu"]}, {"strings": ["2bca13", "d5fe4", "h6gk8j7i", "mq9np0o", "xtyusrzvw"]}, {"strings": ["a1hb2c3", "4df5", "g7i8hk6j", "omnp09q", "rsuvwxyz"]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": "5", "k": "2"}, {"n": "0", "k": "0"}, {"n": "10", "k": "10"}, {"n": "-5", "k": "2"}, {"n": "5", "k": "-2"}, {"n": "1000", "k": "500"}, {"n": "0", "k": "5"}, {"n": "5", "k": "0"}, {"n": "999999", "k": "499999"}, {"n": "1", "k": "2"}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 3, 1, 3]}, {"arr": [5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5]}, {"arr": [0]}, {"arr": [-1, -1, -2]}, {"arr": [1.5, 2.5, 1.5]}, {"arr": [999999999999999999, 1, 999999999999999999]}, {"arr": []}, {"arr": [1, 1, 1]}, {"arr": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1]}, {"arr": ["a", "b", "c", "b", "c", "a", "c"]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "abcd"}, {"s": "aZbcda"}, {"s": "acabd"}, {"s": "abcd"}, {"s": "abcdFa"}, {"s": "abcd"}, {"s": "Tabcda"}, {"s": "abca"}, {"s": "7abcda"}, {"s": "acadb"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "k": 3}, {"numbers": [[1, 1, 1], [2, 2, 2], [3, 3, 3]], "k": 2}, {"numbers": [[], [], []], "k": 1}, {"numbers": [[1]], "k": 0}, {"numbers": [[1, 1, 2, 2, 3, 3, 4, 4, 5, 5]], "k": 5}, {"numbers": [[999999999, -999999999]], "k": 1}, {"numbers": [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], "k": -1}, {"numbers": [[1, 2, 3, 1, 2, 3, 1, 2, 3]], "k": 100}, {"numbers": [[1], [1, 2], [1, 2, 3], [1, 2, 3, 4]], "k": 2}, {"numbers": [[1, 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4]], "k": 4}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"n": "2"}, {"n": "100"}, {"n": "1"}, {"n": "0"}, {"n": "-1"}, {"n": "2147483647"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "2"}, {"n": "3"}, {"n": "4"}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": "0"}, {"decimal_num": "1"}, {"decimal_num": "255"}, {"decimal_num": "-1"}, {"decimal_num": "-255"}, {"decimal_num": "2147483647"}, {"decimal_num": "-2147483648"}, {"decimal_num": "9999999999999999999999999999999999999999"}, {"decimal_num": "-9999999999999999999999999999999999999999"}, {"decimal_num": "1.5"}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]"}, {"arr": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 11]"}, {"arr": "[0, 1, 2, 4, 5, 6, 7, 8, 9, 10]"}, {"arr": "[]"}, {"arr": "[0]"}, {"arr": "[1]"}, {"arr": "[0, 2, 3, 4, 5, 6, 7, 8, 9, 10]"}, {"arr": "[0, 1, 2, 3, 4, 5, 6, 7, 8, 10]"}, {"arr": "[2, 3, 4, 5, 6, 7, 8, 9, 10, 12]"}, {"arr": "[0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 10]"}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 1}, {"n": 5}, {"n": 10}, {"n": 0}, {"n": -1}, {"n": -100}, {"n": 2147483647}, {"n": -2147483648}, {"n": 1000000}, {"n": -1000000}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": "1", "denominator": "2", "n": "1"}, {"numerator": "1", "denominator": "3", "n": "5"}, {"numerator": "22", "denominator": "7", "n": "10"}, {"numerator": "0", "denominator": "5", "n": "3"}, {"numerator": "1", "denominator": "0", "n": "1"}, {"numerator": "1", "denominator": "7", "n": "100"}, {"numerator": "2147483647", "denominator": "1", "n": "1"}, {"numerator": "1", "denominator": "2147483647", "n": "50"}, {"numerator": "999999999", "denominator": "999999999", "n": "1"}, {"numerator": "1", "denominator": "999999999", "n": "1000"}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [-923, "lpepa", -436, "anana", -520, "jcherry"]}, {"mixed_list": [-775, "ap3ple", -491, "nanbaa", -885, "herry"]}, {"mixed_list": [11, "aple", -293, "banan0a", -167, "cdherry"]}, {"mixed_list": [165, "pple", 514, "aanabn", -871, "cherryN"]}, {"mixed_list": [-109, "appTle", -97, "banan", -635, "chery"]}, {"mixed_list": [138, "appl", -805, "banna", 246, "hcerry"]}, {"mixed_list": [-923, "apVple", -969, "abanan", 329, "rechry"]}, {"mixed_list": [-954, "Uapple", -177, "banna", -430, "hyrrec"]}, {"mixed_list": [-337, "appHle", -371, "bapnana", 236, "ecrhry"]}, {"mixed_list": [-17, "apiple", 144, "ananba", 91, "cherrCy"]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [2, 1]}, {"numbers": [4, 3]}, {"numbers": [6, 5]}, {"numbers": [8, 7]}, {"numbers": [10, 9]}, {"numbers": [0, 1]}, {"numbers": [2, 0]}, {"numbers": []}, {"numbers": [2]}, {"numbers": [1]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "aaNbbcc"}, {"s": "abbcc"}, {"s": "acabcb"}, {"s": "aabbc"}, {"s": "abbcc"}, {"s": "aabcc"}, {"s": "aabbc"}, {"s": "aabzbcc"}, {"s": "aabbccg"}, {"s": "abbcc"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{"nested_list": [[92, 468, 176], ["at", "b", "cu"], [-422, "an", -266.09857354457154], []]}, {"nested_list": [[865, -326, 417], ["ua", "bH", "Oc"], [-748, "a", -821.0129705831321], []]}, {"nested_list": [[-752, 609, 855], ["a", "b", "c"], [760, "a", 781.5909898137452], []]}, {"nested_list": [[277, 118, 498], ["a", "b", "c"], [-178, "a", -983.2765566964302], []]}, {"nested_list": [[123, -633, 735], ["a", "Bb", "c"], [877, "a", 30.401739460591443], []]}, {"nested_list": [[-97, -740, -266], ["a", "b", "c"], [567, "a", 175.39599516089834], []]}, {"nested_list": [[243, 955, -89], ["a", "hb", "c"], [86, "a0", 1.5001034799527133], []]}, {"nested_list": [[364, -428, -307], ["ma", "eb", "c"], [-221, "a", -751.6944870667721], []]}, {"nested_list": [[956, 688, 795], ["a", "Ub", "c5"], [886, "a6", -70.64543292286999], []]}, {"nested_list": [[795, -515, -791], ["da", "b", "c"], [752, "aj", -322.2863941607121], []]}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [557, -601, -837, 44, 433, 716, 667, 261, 389, -221]}, {"numbers": [587, -907, 393, 585, -254, 61, -704, 402, 715, 604]}, {"numbers": [701, 167, 702, 619, 181, -291, -537, -525, 590, -870]}, {"numbers": [481, -473, 751, -148, -810, -864, 517, -899, -705, -569]}, {"numbers": [862, -502, 1, 309, 346, -233, -965, -409, -343, 655]}, {"numbers": [-237, 206, 902, 198, -39, -68, -834, -238, 723, -525]}, {"numbers": [-194, -565, 589, 251, 79, 532, 883, -318, 174, 517]}, {"numbers": [712, 859, -975, 431, -6, 493, -281, -831, 866, 333]}, {"numbers": [93, -49, 420, 658, 792, 885, 894, -8, 1002, -372]}, {"numbers": [68, -630, -299, 771, 559, -329, 206, 368, -576, 477]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [1, 1, 2, 2, 3, 3]}, {"arr": [5, 5, 5, 5, 5]}, {"arr": [0, 0, 0, 0, 0]}, {"arr": [-1, -1, 2, 2, -3, -3]}, {"arr": [999999999, 999999999, -999999999, -999999999]}, {"arr": [1]}, {"arr": [1, 1]}, {"arr": []}, {"arr": [0.5, 0.5, 1.5, 1.5]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hpello_world test_case example_string"}, {"text": "hello_worl test_case example_string"}, {"text": "hello_world test_case example_sring"}, {"text": "hello_world test_case example_tring"}, {"text": "xetwhmdal_eprso_e_nta cse eltlsgilro"}, {"text": "hello_world test_case example_st5ring"}, {"text": "telegdltloxermehecoasis natw_l_ _rsp"}, {"text": "riesxl twegnoaleoalspresle__dch_t mt"}, {"text": "hello_world test_case ex6ample_string"}, {"text": "hello_worl test_case example_string"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "tesgt", "string": "test stbring"}, {"word": "ztest", "string": "sgsrttnite "}, {"word": "stet", "string": "test svtring"}, {"word": "tet", "string": "stitne sgtr"}, {"word": "tes9t", "string": "test strMing"}, {"word": "vtest", "string": "sersnttit g"}, {"word": "ttse", "string": "test sring"}, {"word": "tes", "string": "ttsg tseirn"}, {"word": "est", "string": "st rtinsegt"}, {"word": "tets", "string": "r sttgtiesn"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24]}, {"numbers": [7, 13, 29]}, {"numbers": [0, 0, 0]}, {"numbers": [1, 0, 5]}, {"numbers": [-12, 18, -24]}, {"numbers": [2147483647, 2147483647]}, {"numbers": [-2147483648, -2147483648]}, {"numbers": [1]}, {"numbers": []}, {"numbers": [1000000000000000000, 2000000000000000000]}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [33, -350, -566, 784, 986]}, {"numbers": [752, -510, 158, 200, 246]}, {"numbers": [888, -316, -777, -566, 846]}, {"numbers": [-720, -75, 592, -103, 1004]}, {"numbers": [-357, 664, 166, -471, 747]}, {"numbers": [1001, 71, 3, -706, -936]}, {"numbers": [256, 445, -932, 566, -934]}, {"numbers": [613, 577, 160, 352, -866]}, {"numbers": [651, -558, -774, 316, -184]}, {"numbers": [-808, 308, 60, 156, -586]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"a": 5, "b": 10}, {"a": 10, "b": 5}, {"a": 0, "b": 0}, {"a": -5, "b": -3}, {"a": 1000000, "b": 1000005}, {"a": 1, "b": 100}, {"a": 99, "b": 100}, {"a": 2147483647, "b": 2147483647}, {"a": -2147483648, "b": -2147483647}, {"a": 0, "b": 1}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "255"}, {"n": "65535"}, {"n": "2147483647"}, {"n": "4294967295"}, {"n": "18446744073709551615"}, {"n": "-1"}, {"n": "-2147483648"}, {"n": "9223372036854775807"}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}, {"matrix": "[]"}, {"matrix": "[[], [], []]"}, {"matrix": "[[1], [2, 3], [4, 5, 6]]"}, {"matrix": "[[1], [2], [3]]"}, {"matrix": "[[1, 2], [3], [4, 5, 6]]"}, {"matrix": "[[null], [null, null], [null, null, null]]"}, {"matrix": "[[9223372036854775807, -9223372036854775808], [0, 0, 0]]"}, {"matrix": "[[1.1, 2.2, 3.3], [4.4, 5.5], [6.6]]"}, {"matrix": "[['a', 'b', 'c'], ['d', 'e'], ['f', 'g', 'h']]"}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": "[]"}, {"lists": "[[]]"}, {"lists": "[[1], [2, 3]]"}, {"lists": "[[1, 2, 3], [4, 5], [6]]"}, {"lists": "[[], [1], [2, 3]]"}, {"lists": "[[1]]"}, {"lists": "[[1, 2], [3], [4, 5, 6], [7]]"}, {"lists": "[[1, 2, 3, 4, 5]]"}, {"lists": "[[], [], []]"}, {"lists": "[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]"}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": -929, "side2": 575, "side3": -902}, {"side1": 911, "side2": 899, "side3": -752}, {"side1": 810, "side2": -649, "side3": 582}, {"side1": -523, "side2": 186, "side3": -193}, {"side1": -383, "side2": -856, "side3": -366}, {"side1": -339, "side2": -791, "side3": -406}, {"side1": 377, "side2": -958, "side3": 343}, {"side1": 871, "side2": -307, "side3": -44}, {"side1": 142, "side2": 438, "side3": -317}, {"side1": 288, "side2": 419, "side3": -439}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": 5.0, "height": 3.0}, {"base": 0.0, "height": 10.0}, {"base": 10.0, "height": 0.0}, {"base": -5.0, "height": 3.0}, {"base": 5.0, "height": -3.0}, {"base": "1.7976931348623157E+308", "height": 2.0}, {"base": 2.0, "height": "1.7976931348623157E+308"}, {"base": "5", "height": 3.0}, {"base": 5.0, "height": "3"}, {"base": null, "height": 3.0}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "crreaac"}, {"s": "r2acecar"}, {"s": "rraceca"}, {"s": "ccarrae"}, {"s": "rreaacc"}, {"s": "raceca"}, {"s": "rcaacre"}, {"s": "racecOar"}, {"s": "crcaera"}, {"s": "arcarce"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [5, 4, 3, 2, 1]}, {"arr": [1, 1, 1, 1, 1]}, {"arr": [0]}, {"arr": [-5, -4, -3, -2, -1]}, {"arr": [1000, -1000]}, {"arr": [2147483647, -2147483648]}, {"arr": [1, 3, 2, 3, 1, 2, 3]}, {"arr": []}, {"arr": [999999999, -999999999]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": "1"}, {"r": "0"}, {"n": "1"}, {"a": "0", "r": "2", "n": "5"}, {"a": "-1", "r": "2", "n": "10"}, {"a": "1", "r": "-2", "n": "8"}, {"a": "9999999999999999999", "r": "9999999999999999999", "n": "9999999999999999999"}, {"a": "0.1", "r": "0.1", "n": "1000"}, {"a": "-9999999999999999999", "r": "-9999999999999999999", "n": "50"}, {"a": "1", "r": "1", "n": "0"}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"n": "123"}, {"n": "0"}, {"n": "-1"}, {"n": "9999999999999999999999999999999999999999"}, {"n": "18446744073709551615"}, {"n": "1"}, {"n": "37"}, {"n": "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"n": "abc"}, {"n": "1.5"}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [420, 685, 707, 732, 63]}, {"digits": [-847, -245, -767, -750, 913]}, {"digits": [-589, 608, 853, -412, 411]}, {"digits": [-712, 825, -547, -282, 516]}, {"digits": [-483, -403, -284, -672, 593]}, {"digits": [102, -263, 342, 880, -317]}, {"digits": [455, 196, -625, 887, -72]}, {"digits": [886, -243, 737, 941, -77]}, {"digits": [-75, 214, -296, 126, 638]}, {"digits": [-373, -869, 139, -210, 877]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"a": "0", "b": "0"}, {"a": "1", "b": "1"}, {"a": "-1", "b": "-1"}, {"a": "2147483647", "b": "-2147483648"}, {"a": "-2147483648", "b": "2147483647"}, {"a": "0", "b": "-1"}, {"a": "-1", "b": "0"}, {"a": "1", "b": "-1"}, {"a": "-1", "b": "1"}, {"a": "9223372036854775807", "b": "-9223372036854775808"}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "2"}, {"n": "10"}, {"n": "-1"}, {"n": "-10"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"n": "abc"}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": [124, -498, 274, 865, 729, 340, 551]}, {"arr": [-212, -205, -339, 400, -964, -590, 519]}, {"arr": [-989, -704, 837, 649, -332, 826, -431]}, {"arr": [-537, -234, -979, 965, -11, -431, 718]}, {"arr": [-187, -956, 608, -255, 628, 715, -429]}, {"arr": [-852, -866, -823, -222, 93, 902, -62]}, {"arr": [921, -2, -96, 633, -858, 391, -225]}, {"arr": [-993, 814, 556, 617, 753, 251, -502]}, {"arr": [-718, -477, 135, 233, 39, -546, -576]}, {"arr": [735, -766, -572, 122, -949, 99, -39]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "11010"}, {"s": "1G01010"}, {"s": "011010"}, {"s": "11010"}, {"s": "1010H10"}, {"s": "10110"}, {"s": "1010a10"}, {"s": "101s010"}, {"s": "10110"}, {"s": "10010"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}, {"numbers": [-5, -3, -1, 0, 2]}, {"numbers": [100, 50, 25, 75, 10]}, {"numbers": [0, 0, 0, 0, 0]}, {"numbers": [1]}, {"numbers": []}, {"numbers": [999999999999999999, -999999999999999999, 0]}, {"numbers": [1.5, 2.3, 0.1, -1.2]}, {"numbers": [2147483647, -2147483648, 0]}, {"numbers": [1, "2", 3]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": "[[1, 2], [3, 4]]"}, {"pairs": "[[0, 0], [0, 0]]"}, {"pairs": "[[-10, -20], [30, 40]]"}, {"pairs": "[[1, 1]]"}, {"pairs": "[]"}, {"pairs": "[[999999999, 999999999], [-999999999, -999999999]]"}, {"pairs": "[[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7], [8, 8], [9, 9]]"}, {"pairs": "[[\"1\", \"2\"], [\"3\", \"4\"]]"}, {"pairs": "[[null, null], [null, null]]"}, {"pairs": "[[], [1, 2], [3, 4, 5]]"}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{"tuples_list": "[]", "sort_index": "null", "reverse": "false"}, {"tuples_list": "[[1, 2], [3, 1], [2, 3]]", "sort_index": "null", "reverse": "false"}, {"tuples_list": "[[1, 2], [3, 1], [2, 3]]", "sort_index": "1", "reverse": "true"}, {"tuples_list": "[[1]]", "sort_index": "0", "reverse": "false"}, {"tuples_list": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "sort_index": "2", "reverse": "false"}, {"tuples_list": "[[1, 2], [3, 4]]", "sort_index": "-1", "reverse": "false"}, {"tuples_list": "[[1, 2], [3, 4]]", "sort_index": "5", "reverse": "false"}, {"tuples_list": "[[9223372036854775807, -9223372036854775808], [0, 0]]", "sort_index": "0", "reverse": "false"}, {"tuples_list": "[[]]", "sort_index": "null", "reverse": "false"}, {"tuples_list": "[[null, 1], [2, null]]", "sort_index": "0", "reverse": "false"}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [1, 2, 3]}, {"lst": []}, {"lst": [[1, 2], [3, 4]]}, {"lst": [[[1]], [2, [3, 4]]]}, {"lst": [1, [2, [3, [4, [5]]]]]}, {"lst": [0, 0, 0]}, {"lst": [-1, 1, -2, 2]}, {"lst": [1, "2", 3]}, {"lst": [999999999999999999, 1]}, {"lst": [[[[[[[[[[1]]]]]]]]]]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}, {"numbers": [-1, -2, -3, -4, -5]}, {"numbers": [0, 0, 0, 0, 0]}, {"numbers": [1, -1, 2, -2, 0]}, {"numbers": [9999999999999999999999999999999999999999]}, {"numbers": [-9999999999999999999999999999999999999999]}, {"numbers": [0.1, 1e-41]}, {"numbers": [-0.1, -1e-41]}, {"numbers": [1, "2", 3]}, {"numbers": []}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "5"}, {"n": "-1"}, {"n": "999"}, {"n": "1000"}, {"n": "-999"}, {"n": "2147483647"}, {"n": "-2147483648"}, {"n": "50"}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [5, 4, 3, 2, 1]}, {"arr": [1, 1, 1, 1, 1]}, {"arr": [1, 3, 2, 4, 5]}, {"arr": []}, {"arr": [1]}, {"arr": [1, 2, 2, 3, 4]}, {"arr": [5, 5, 4, 3, 2]}, {"arr": [1, 2, 3, 2, 1]}, {"arr": [1, 1, 2, 2, 3]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": [503, -544, -489, -497, 62], "sublist": [218, 348, -670]}, {"main_list": [-159, 570, -704, 86, 725], "sublist": [-797, -175, -777]}, {"main_list": [578, -348, -196, 77, 997], "sublist": [-325, -924, 954]}, {"main_list": [-301, -362, -656, -31, -362], "sublist": [519, -579, 743]}, {"main_list": [204, -982, 230, 829, 533], "sublist": [-726, -111, -760]}, {"main_list": [878, 857, -715, 985, 41], "sublist": [580, 296, 679]}, {"main_list": [559, 101, -668, -7, -214], "sublist": [244, 460, 422]}, {"main_list": [-800, 842, -118, 709, 174], "sublist": [714, -431, 101]}, {"main_list": [459, 1000, -378, -59, 372], "sublist": [-841, 156, 401]}, {"main_list": [723, 520, -952, 615, -240], "sublist": [493, 732, -692]}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [5, 4, 3, 2, 1]}, {"arr": [1]}, {"arr": []}, {"arr": [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}, {"arr": [1, 1, 1, 1, 1]}, {"arr": [999999999, -999999999, 0]}, {"arr": [1, 3, 2]}, {"arr": [2147483647, -2147483648, 0, 1, -1]}, {"arr": [2, 2, 1, 1, 3, 3]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "2"}, {"n": "3"}, {"n": "4"}, {"n": "-1"}, {"n": "2147483647"}, {"n": "-2147483648"}, {"n": "1000000000"}, {"n": "999999999"}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "hello,world;test|exampleH", "delimiters": ["w,", "2;", "|"]}, {"text": "helo,world;test|example", "delimiters": [",5", ";", "|"]}, {"text": "hello,world;tesMt|example", "delimiters": ["v,", "U;", "|"]}, {"text": "e|llt,txwleplaes;eohdorm", "delimiters": [",", ";", "|"]}, {"text": "hello,worldX;test|example", "delimiters": [",", ";", "|"]}, {"text": "hello,wold;test|example", "delimiters": [",0", ";", "|"]}, {"text": "hello,wold;test|example", "delimiters": [",", ";", "|k"]}, {"text": "lelloaprxhtmeel;|estodw,", "delimiters": [",", ";", "|"]}, {"text": "hoed,aprels|elelm;ttloxw", "delimiters": ["b,", "z;", "|"]}, {"text": "heallo,world;test|example", "delimiters": ["X,", ";", "4|"]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": ["ae", "b5", "b", "a"], "patterns": [["A", "B", "B", "A"], ["XP", "Y", "Z", "Xw"]]}, {"sequence": ["a", "b", "b", "a"], "patterns": [["A", "B", "B", "Af"], ["X", "BY", "Z", "X"]]}, {"sequence": ["a", "b", "bn", "a"], "patterns": [["A", "B", "JB", "A"], ["X", "Y", "Zn", "XG"]]}, {"sequence": ["a", "b", "b", "a"], "patterns": [["A", "BU", "B", "A"], ["X", "YK", "FZ", "X"]]}, {"sequence": ["a", "b", "b", "a"], "patterns": [["A", "B", "Bh", "A"], ["OX", "Y", "ZG", "PX"]]}, {"sequence": ["a", "b", "b", "at"], "patterns": [["CA", "B", "B", "A"], ["X", "Y", "Z", "X"]]}, {"sequence": ["a", "bZ", "b", "a"], "patterns": [["Aq", "Bf", "B", "RA"], ["X", "Y", "pZ", "TX"]]}, {"sequence": ["a", "vb", "ib", "a"], "patterns": [["A", "B", "B", "A"], ["7X", "Y", "Z", "X"]]}, {"sequence": ["La", "b", "b", "ay"], "patterns": [["3A", "BX", "B", "NA"], ["X", "Y", "Z", "XA"]]}, {"sequence": ["a", "b", "b", "a"], "patterns": [["A", "B", "B", "A"], ["X", "Y", "Z3", "LX"]]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{"tuple_list": "[]", "k": "1"}, {"tuple_list": "[(2, 4, 6), (3, 6, 9), (1, 2, 3)]", "k": "2"}, {"tuple_list": "[(0, 0, 0)]", "k": "1"}, {"tuple_list": "[(-10, -20), (15, 25)]", "k": "5"}, {"tuple_list": "[(100, 200, 300)]", "k": "0"}, {"tuple_list": "[()]", "k": "1"}, {"tuple_list": "[(999999999999999999, 888888888888888888)]", "k": "111111111111111111"}, {"tuple_list": "[(1.5, 3.0), (2.0, 4.5)]", "k": "0.5"}, {"tuple_list": "[('a', 'b'), (1, 2)]", "k": "1"}, {"tuple_list": "[(1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,), (10,), (11,), (12,), (13,), (14,), (15,), (16,), (17,), (18,), (19,), (20,), (21,), (22,), (23,), (24,), (25,), (26,), (27,), (28,), (29,), (30,), (31,), (32,), (33,), (34,), (35,), (36,), (37,), (38,), (39,), (40,), (41,), (42,), (43,), (44,), (45,), (46,), (47,), (48,), (49,), (50,)]", "k": "1"}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": "5", "width": "3"}, {"length": "1", "width": "1"}, {"length": "0", "width": "5"}, {"length": "5", "width": "0"}, {"length": "-1", "width": "3"}, {"length": "3", "width": "-1"}, {"length": "999999999", "width": "1"}, {"length": "1", "width": "999999999"}, {"length": "2147483647", "width": "2147483647"}, {"length": "1000000000", "width": "1000000000"}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": "12345"}, {"num": "24680"}, {"num": "13579"}, {"num": "0"}, {"num": "-12345"}, {"num": "99999999999999999999999999999999999999999999999999"}, {"num": "00000000000000000000000000000000000000000000000000"}, {"num": "18446744073709551615"}, {"num": "1.5"}, {"num": "123abc"}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": "1"}, {"n": "2"}, {"n": "3"}, {"n": "10"}, {"n": "100"}, {"n": "0"}, {"n": "-1"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"n": "18446744073709551615"}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "test"}, {"word": "test4"}, {"word": "tst"}, {"word": "etts"}, {"word": "sett"}, {"word": "teIst"}, {"word": "test6"}, {"word": "testp"}, {"word": "tes"}, {"word": "tPest"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "5"}, {"n": "100"}, {"n": "-1"}, {"n": "-100"}, {"n": "2147483647"}, {"n": "-2147483648"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{"tuple1": "()", "tuple2": "()"}, {"tuple1": "(1, 2, 3)", "tuple2": "('a', 'b', 'c')"}, {"tuple1": "(1,)", "tuple2": "('a', 'b')"}, {"tuple1": "(1, 2)", "tuple2": "('a',)"}, {"tuple1": "('x' * 1000,)", "tuple2": "('y' * 1000,)"}, {"tuple1": "(None,)", "tuple2": "(None,)"}, {"tuple1": "(1, 2, 3, 4, 5)", "tuple2": "('a', 'b')"}, {"tuple1": "(1, 2)", "tuple2": "('a', 'b', 'c', 'd', 'e')"}, {"tuple1": "('',)", "tuple2": "('',)"}, {"tuple1": "(1, 'mixed', None, 3.14)", "tuple2": "('a', 2, 'c', 'd')"}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": "1.0"}, {"radius": "0.0"}, {"radius": "-1.0"}, {"radius": "99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"radius": "-99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"radius": "1e308"}, {"radius": "-1e308"}, {"radius": "1e-308"}, {"radius": "NaN"}, {"radius": "Infinity"}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "a"}, {"s": "A"}, {"s": "0"}, {"s": ""}, {"s": "ab"}, {"s": "abc"}, {"s": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"}, {"s": ""}, {"s": "ÿÿÿ"}, {"s": "\u0001\u0002\u0003\u0004\u0005"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": "1"}, {"n": "2"}, {"n": "5"}, {"n": "10"}, {"n": "0"}, {"n": "-1"}, {"n": "1000000"}, {"n": "999999"}, {"n": "2147483647"}, {"n": "-2147483648"}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": "1.0"}, {"radius": "0.0"}, {"radius": "-1.0"}, {"radius": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"radius": "1e308"}, {"radius": "1e-308"}, {"radius": "NaN"}, {"radius": "Infinity"}, {"radius": "-Infinity"}, {"radius": "0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"n": "1"}, {"n": "2"}, {"n": "5"}, {"n": "0"}, {"n": "-1"}, {"n": "2147483647"}, {"n": "-2147483648"}, {"n": "999999999999999999999999999999"}, {"n": "-999999999999999999999999999999"}, {"n": "1000000000000000000000000000000"}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": {"a": 1, "XoFN6kTG0xox1uG2Q7E": "iIt29JStpp3"}, "dict2": {"b": 2}, "dict3": {"c": 3}}, {"dict1": {"a": 1}, "dict2": {"2b": 2}, "dict3": {"cN": 3}}, {"dict1": {"a": 1}, "dict2": {"b": 2, "YjFRkizeY": "0WICZrZnL06Flbcu"}, "dict3": {"c": 3, "btC": "h4k8YHkYWEI3O"}}, {"dict1": {"a": 1}, "dict2": {"bf": 2}, "dict3": {"c": -238}}, {"dict1": {"a": 1, "XMfZNCJPzID4EL": "wLn2mPuETpl4a4"}, "dict2": {"b": 2, "tcOvc7HY1xW": "xbiaZV"}, "dict3": {"c": 3, "aIOyV9Zf": "faeeV6Ca2LiY8JwkR"}}, {"dict1": {"a": 12}, "dict2": {"b": -880}, "dict3": {"c": 3}}, {"dict1": {"a": 1}, "dict2": {"Jb": 2}, "dict3": {"c": 3, "DStYPk88": "crK7u3IOCW6dlR"}}, {"dict1": {"a": 1, "zdZG2JISzNc7wjOFPFXF": "AD8"}, "dict2": {"b4": 2}, "dict3": {"c": 3}}, {"dict1": {"a": 1}, "dict2": {"b4": 2}, "dict3": {"c": 3, "e": "zqNUbTcf4zQDA"}}, {"dict1": {"a": 1}, "dict2": {"b": 2}, "dict3": {"cm": 3}}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": [1, 2, 3, 4, 5]}, {"elements": [1, 1, 1, 1, 1]}, {"elements": []}, {"elements": ["a", "b", "a", "c", "b", "a"]}, {"elements": [null, null, null]}, {"elements": [{"key": "value"}, {"key": "value"}]}, {"elements": [1, "1", 1, "1"]}, {"elements": [999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999]}, {"elements": [[1, 2], [1, 2], [3, 4]]}, {"elements": [true, false, true, true, false]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": "12345"}, {"n": "54321"}, {"n": "1000"}, {"n": "9999"}, {"n": "0"}, {"n": "-1"}, {"n": "10"}, {"n": "21"}, {"n": "332"}, {"n": "987654321"}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "The uick brown fox jumps over the lazy dog"}, {"sentence": "yqvcu sproujnmor to dbzeTa  hxfhke w  ogeli"}, {"sentence": "The quick brown fox jaumps over the lazy dog"}, {"sentence": "ohie jcumvo redxofe oaz  gtkyTws hl q burnp"}, {"sentence": "The quick broVwn fox jumps over the lazy dog"}, {"sentence": "The quicvk brown fox jumps over the lazy dog"}, {"sentence": "ko bqh Tpto  ey gsan xir vejwoulzhrcu mdfeo"}, {"sentence": "vg szfekwrqnbu l phaim xTuh rot oy eoceojd "}, {"sentence": "oThe quick brown fox jumps over the lazy dog"}, {"sentence": "o   uasdTh mro nhlgebpixr oqtywvoz uk feecj"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"substring": "stet", "string_list": ["gsettni", "exampl", "eomd"]}, {"substring": "ttes", "string_list": ["tnetisg", "examnple", "emo"]}, {"substring": "testB", "string_list": ["eitstgn", "eample", "eodm"]}, {"substring": "testd", "string_list": ["testin", "amxeepl", "dmo"]}, {"substring": "tepst", "string_list": ["testinge", "eaemxpl", "dmo"]}, {"substring": "te5st", "string_list": ["sgientt", "elaepxm", "edmo"]}, {"substring": "Wtest", "string_list": ["isgettn", "exampcle", "demoZ"]}, {"substring": "etts", "string_list": ["esting", "exgample", "dmo"]}, {"substring": "tesOt", "string_list": ["tjesting", "eample", "demob"]}, {"substring": "tst", "string_list": ["testin", "pexaelm", "dmo"]}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"n": "123"}, {"n": "121"}, {"n": "12321"}, {"n": "100"}, {"n": "999"}, {"n": "101"}, {"n": "12345678901234567890"}, {"n": "-100"}, {"n": "0"}, {"n": "999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": "2"}, {"a": "0"}, {"a": "-1"}, {"a": "1000000000"}, {"a": "0.5"}, {"a": "2", "b": "3"}, {"a": "0", "b": "0"}, {"a": "-1", "b": "0.5"}, {"a": "1000000000", "b": "1000000000"}, {"a": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": "[5, 2, 8, 1, 9]"}, {"records": "[0]"}, {"records": "[-10, -5, -20, -1]"}, {"records": "[3.5, 1.2, 8.9, 0.1]"}, {"records": "[100, 200, 50, 300, 25]"}, {"records": "[1, 1, 1, 1, 1]"}, {"records": "[9223372036854775807, -9223372036854775808]"}, {"records": "[]"}, {"records": "[null, 5, 2]"}, {"records": "[\"abc\", \"def\", \"xyz\"]"}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5], "target": 10}, {"nums": [1, 4, 4], "target": 4}, {"nums": [1, 1, 1, 1, 1, 1, 1, 1], "target": 7}, {"nums": [], "target": 5}, {"nums": [5], "target": 5}, {"nums": [1, 2, 3], "target": 100}, {"nums": [10, 5, 2, 6], "target": 8}, {"nums": [1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000], "target": 2147483647}, {"nums": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], "target": 1}, {"nums": [-1, -2, -3, 10, -5, 2, 3], "target": 5}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": "1"}, {"n": "0"}, {"n": "-1"}, {"n": "2"}, {"n": "100"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "1.5"}, {"n": "null"}, {"n": "true"}, {"n": "2147483647"}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": []}, {"lst": [[]]}, {"lst": [[], [], []]}, {"lst": [[1, 2, 3], [2, 3, 4], [3, 4, 5]]}, {"lst": [["a", "b"], ["b", "c"], ["c", "d"]]}, {"lst": [[null, null, null], [null, null]]}, {"lst": [[true, false], [false, true]]}, {"lst": [[1.1, 2.2], [2.2, 3.3]]}, {"lst": [["x", "x", "x"], ["y", "y"], ["z"]]}, {"lst": [[{"key": "value"}], [{"key": "value"}]]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [2, 3, 4]}, {"numbers": [1]}, {"numbers": [0, 5, 10]}, {"numbers": [1000000, 1000000, 1000000]}, {"numbers": [-1, -2, -3]}, {"numbers": [0.5, 0.5, 0.5]}, {"numbers": [1, 0, 1]}, {"numbers": [999999999, 999999999, 999999999]}, {"numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}, {"numbers": [-999999999, -999999999, -999999999]}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": "0"}, {"decimal_num": "1"}, {"decimal_num": "255"}, {"decimal_num": "-128"}, {"decimal_num": "2147483647"}, {"decimal_num": "-2147483648"}, {"decimal_num": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"decimal_num": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"decimal_num": "18446744073709551615"}, {"decimal_num": "-18446744073709551616"}]}
{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": "[[1,2,3],[4,5,6],[7,8,9]]", "m": "2", "n": "2"}, {"cost": "[[0,0,0],[0,0,0],[0,0,0]]", "m": "2", "n": "2"}, {"cost": "[[1]]", "m": "0", "n": "0"}, {"cost": "[[999999999,999999999],[999999999,999999999]]", "m": "1", "n": "1"}, {"cost": "[[-1,-2,-3],[-4,-5,-6],[-7,-8,-9]]", "m": "2", "n": "2"}, {"cost": "[[1,2],[3,4],[5,6],[7,8]]", "m": "3", "n": "1"}, {"cost": "[[1,2,3,4,5]]", "m": "0", "n": "4"}, {"cost": "[[2147483647,2147483647],[2147483647,2147483647]]", "m": "1", "n": "1"}, {"cost": "[[-2147483648,-2147483648],[-2147483648,-2147483648]]", "m": "1", "n": "1"}, {"cost": "[[1,2],[3,4]]", "m": "5", "n": "5"}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": [75, 191, 323, -206], "test_tup2": [-315, -199, 443, 752]}, {"test_tup1": [939, -892, 337, 289], "test_tup2": [-468, -238, -180, -693]}, {"test_tup1": [0, -653, -133, 1], "test_tup2": [472, 91, 266, -604]}, {"test_tup1": [721, -739, 370, -722], "test_tup2": [24, 787, -930, 840]}, {"test_tup1": [549, 809, 709, -23], "test_tup2": [762, 312, -499, -137]}, {"test_tup1": [283, -104, 154, 895], "test_tup2": [-700, 773, 502, 680]}, {"test_tup1": [-471, -881, -436, -835], "test_tup2": [-50, -913, 524, 332]}, {"test_tup1": [789, -326, -669, 716], "test_tup2": [-674, 475, -56, 414]}, {"test_tup1": [789, -936, 567, -53], "test_tup2": [-343, -343, -868, -470]}, {"test_tup1": [272, -513, -434, -820], "test_tup2": [921, -331, -529, -131]}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [-194, -717, 490, -480, -869, -149, -372, 895, 892, 279, 208]}, {"numbers": [807, -813, 777, 995, 740, 450, 623, 375, 989, 992, 87]}, {"numbers": [133, -925, -130, 758, 755, -633, -546, 450, -729, 489, 901]}, {"numbers": [-958, 567, 968, -884, -487, -701, -723, 486, -773, -558, -301]}, {"numbers": [-557, 247, 803, -28, 438, 568, -200, 795, -778, -390, -980]}, {"numbers": [-4, -988, 914, -843, -557, -415, -452, 996, -121, 82, -6]}, {"numbers": [-957, 878, 37, 413, 575, -619, 916, 865, 44, -870, 667]}, {"numbers": [206, -902, -888, 351, -436, -520, 409, 113, -151, 719, -451]}, {"numbers": [508, 511, 478, -910, 450, 236, 985, 362, 223, -108, -539]}, {"numbers": [496, 272, -917, 116, 734, -358, 225, -354, 582, -484, -630]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [-228, 70, 773, 76, -429, 989], "k": 318}, {"numbers": [191, -417, 492, -351, 473, -724], "k": 850}, {"numbers": [-522, -755, 393, 180, 871, 576], "k": -9}, {"numbers": [-668, -43, 252, -784, -289, 669], "k": 981}, {"numbers": [838, -984, 259, 296, -494, 996], "k": 379}, {"numbers": [24, 583, -110, 529, 113, 432], "k": 741}, {"numbers": [125, -841, -550, -553, -459, -403], "k": 389}, {"numbers": [235, 994, 995, 225, -657, 940], "k": -637}, {"numbers": [-222, -377, -318, -509, -614, 910], "k": -152}, {"numbers": [-764, -60, 968, 743, -724, -919], "k": -872}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": "0"}, {"n": "2"}, {"n": "4"}, {"n": "8"}, {"n": "-2"}, {"n": "-4"}, {"n": "1000"}, {"n": "999"}, {"n": "1"}, {"n": "6"}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": "0", "b": "0"}, {"a": "1", "b": "0"}, {"a": "3", "b": "1"}, {"a": "7", "b": "3"}, {"a": "15", "b": "7"}, {"a": "-1", "b": "-2"}, {"a": "2147483647", "b": "2147483646"}, {"a": "0", "b": "18446744073709551615"}, {"a": "255", "b": "127"}, {"a": "1000", "b": "1001"}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "The quick brown fox juYmps over the lazy dog"}, {"text": "The quick brown fox jumps overC the lazy dog"}, {"text": "oTea  ee ijxoourrybhd tlg phuqwmcks o nfz v"}, {"text": "The quick brown fox jumps overd the lazy dog"}, {"text": "uu osTna bgkfhe xemh rdjotw rloyqp c ev ioz"}, {"text": " Tn  dkemhtufousworrbz ijaoxeqo   pv gyelch"}, {"text": "The quick brown fox jumps ove the lazy dog"}, {"text": "The quick brown fox jumps over thelazy dog"}, {"text": "he quick brown fox jumps over the lazy dog"}, {"text": "The quick brown fox jumps over he lazy dog"}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [-390.96960352212113, -448.2021803896057, 28.286642997532454, -295.9011226157493, 813.6270738726394]}, {"numbers": [827.2253947076367, 540.1523503339972, -75.13943077730357, -467.25826622492787, 520.0655409535393]}, {"numbers": [-916.9611792418259, 213.0713861855604, -240.9111513425438, 268.2248894235004, 477.6101980710289]}, {"numbers": [282.1700627456162, 408.8611092855501, -994.5103179619549, 496.6509629004504, 431.7139439904995]}, {"numbers": [-73.47613678350694, -933.631531686518, 475.83265015551024, 331.3969043724653, 297.1913022998144]}, {"numbers": [279.58218244763316, -550.6620472720922, -104.88106268623858, 734.1924263578978, 666.3825954250547]}, {"numbers": [284.4276551266473, -868.8879236434976, -995.5241042641588, 552.1892229196319, 243.43715366597803]}, {"numbers": [-969.5855911746472, 703.5508649219314, 55.76493839582713, -904.3729303978532, 669.3064429334288]}, {"numbers": [-629.0384822283436, 990.1944944361464, 745.1683497874878, -281.9628384061614, 797.5407243285829]}, {"numbers": [629.6630444510683, -99.00675071003923, 798.5905547880886, -982.4313582803923, 672.5796623753356]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": "bab"}, {"s": "aab"}, {"s": "aObab"}, {"s": "ababM"}, {"s": "aabb"}, {"s": "aba"}, {"s": "bab"}, {"s": "bab"}, {"s": "abb"}, {"s": "abaGb"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": "[]"}, {"dataset": "[1]"}, {"dataset": "[1, 2, 3]"}, {"dataset": "[3, 1, 2]"}, {"dataset": "[-1, -2, -3]"}, {"dataset": "[1.5, 2.5, 0.5]"}, {"dataset": "[999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999]"}, {"dataset": "[\"a\", \"b\", \"c\"]"}, {"dataset": "[null, null, null]"}, {"dataset": "[{\"a\": 1}, {\"b\": 2}]"}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "test string with multiEple t characters", "char": "2t"}, {"s": "test string with multiple 9t characters", "char": "t"}, {"s": "test string with multiple t caracters", "char": "t"}, {"s": "test string with 8multiple t characters", "char": "t"}, {"s": "test string with mulgtiple t characters", "char": "t"}, {"s": "test striQng with multiple t characters", "char": "t"}, {"s": "test string with multiple t haracters", "char": "t"}, {"s": " sletlstagr itsh erwt pniuamt ehtrcitc", "char": "tz"}, {"s": "test string wth multiple t characters", "char": "t"}, {"s": "r eetlrsumstt gt natc ithlc wiatrehspi", "char": "tN"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}, {"matrix": "[]"}, {"matrix": "[[]]"}, {"matrix": "[[], [], []]"}, {"matrix": "[[1], [2], [3]]"}, {"matrix": "[[-1, -2, -3], [-4, -5, -6]]"}, {"matrix": "[[999999999999999999, 999999999999999999], [1, 2]]"}, {"matrix": "[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]"}, {"matrix": "[[9223372036854775807, 9223372036854775807], [1, 1]]"}, {"matrix": "[[-9223372036854775808, -9223372036854775808], [1, 1]]"}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "cherry": 5}, "n": 2}, {"word_dict": {}, "n": 1}, {"word_dict": {"test": 1}, "n": 0}, {"word_dict": {"a": 1000000, "b": 999999, "c": 999998}, "n": -1}, {"word_dict": {"word1": 10, "word2": 10, "word3": 10, "word4": 10, "word5": 10}, "n": 3}, {"word_dict": {"x": 0, "y": -5, "z": 10}, "n": 2}, {"word_dict": {"single": 1}, "n": 100}, {"word_dict": {"a": 1, "b": 2, "c": 3, "d": 4, "e": 5, "f": 6, "g": 7, "h": 8, "i": 9, "j": 10}, "n": 5}, {"word_dict": {"null": 0, "zero": 0, "negative": -1}, "n": 1}, {"word_dict": {"very_long_word_name_that_exceeds_normal_length_but_still_valid_for_processing": 100, "short": 50}, "n": 1}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": "(10, 5)", "height": "20"}, {"base_triangle": "(0, 5)", "height": "10"}, {"base_triangle": "(10, 0)", "height": "10"}, {"base_triangle": "(-5, 8)", "height": "15"}, {"base_triangle": "(10, -3)", "height": "12"}, {"base_triangle": "(1000000, 1000000)", "height": "1000000"}, {"base_triangle": "(0.1, 0.1)", "height": "0.1"}, {"base_triangle": "(999999999, 999999999)", "height": "999999999"}, {"base_triangle": "(1.7976931348623157e+308, 1.7976931348623157e+308)", "height": "1.7976931348623157e+308"}, {"base_triangle": "(null, 5)", "height": "10"}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "hello"}, {"s": "HELLO"}, {"s": "HelloWorld"}, {"s": "a"}, {"s": "A"}, {"s": ""}, {"s": "H1e2l3l4o"}, {"s": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"}, {"s": "H\\u0065llo"}, {"s": "!@#$%^&*()"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world"}, {"text": "test_case_example"}, {"text": "a_b"}, {"text": "x_y_z"}, {"text": "normal_input_with_underscores"}, {"text": "a"}, {"text": "A_B_C"}, {"text": "123_abc"}, {"text": "_start_underscore"}, {"text": "end_underscore_"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": 5.0}, {"side_length": 3.5}, {"side_length": 0.0}, {"side_length": -1.0}, {"side_length": "1.7976931348623157E+308"}, {"side_length": "-1.7976931348623157E+308"}, {"side_length": "2.2250738585072014E-308"}, {"side_length": "-2.2250738585072014E-308"}, {"side_length": "NaN"}, {"side_length": "Infinity"}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "hello word", "str2": "aueiou"}, {"str1": "llho rlowde", "str2": "aeio"}, {"str1": "rdhleol wol", "str2": "uaoie"}, {"str1": "lrdowhole l", "str2": "ieoau"}, {"str1": "dloelw rhlo", "str2": "aeioBu"}, {"str1": "hello wnorld", "str2": "aeioLu"}, {"str1": "helLlo world", "str2": "aiou"}, {"str1": "helo world", "str2": "aiou"}, {"str1": "o rdllowlhe", "str2": "aeou"}, {"str1": "r lhwloodel", "str2": "aeisou"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5]}, {"nums": [1, 2, 3, 2, 4]}, {"nums": []}, {"nums": [1]}, {"nums": [1, 1]}, {"nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1]}, {"nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]}, {"nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 1]}, {"nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 50]}, {"nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 100]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": "1"}, {"n": "7"}, {"n": "0"}, {"n": "-1"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "1.5"}, {"n": "abc"}, {"n": "null"}, {"n": "true"}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": 1, "m": 1}, {"n": 0, "m": 5}, {"n": -3, "m": 4}, {"n": 2147483647, "m": 2}, {"n": -2147483648, "m": 2}, {"n": 1000000, "m": 0}, {"n": 10, "m": 1000}, {"n": 0, "m": 0}, {"n": 1, "m": 100000}, {"n": -1, "m": 50000}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [1, 2, 3, 2, 1]}, {"arr": []}, {"arr": [1]}, {"arr": [1, 1]}, {"arr": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1]}, {"arr": [null, null]}, {"arr": [true, false, true]}, {"arr": [1.1, 2.2, 1.1]}, {"arr": ["a", "b", "c", "a"]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}, {"lists": "[[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]"}, {"lists": "[[0, 0, 0], [0, 0, 0], [0, 0, 0]]"}, {"lists": "[[999999999, 999999999], [-999999999, -999999999], [0, 0]]"}, {"lists": "[[1], [2], [3], [4], [5]]"}, {"lists": "[[], [], [1, 2, 3]]"}, {"lists": "[[9223372036854775807, 1], [-9223372036854775808, -1], [0, 0]]"}, {"lists": "[[1.5, 2.5, 3.5], [4.5, 5.5, 6.5], [7.5, 8.5, 9.5]]"}, {"lists": "[[], [1], [1, 2], [1, 2, 3], [1, 2, 3, 4]]"}, {"lists": "[[1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000]]"}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "101"}, {"binary_str": "110"}, {"binary_str": "1100"}, {"binary_str": "1010B"}, {"binary_str": "0011"}, {"binary_str": "101"}, {"binary_str": "010"}, {"binary_str": "1P010"}, {"binary_str": "1010y"}, {"binary_str": "1010g"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [1, 1, 2, 2, 3, 3]}, {"arr": [2, 3, 2, 4, 5, 4]}, {"arr": [10]}, {"arr": []}, {"arr": [0, 1, 2, 3, 4]}, {"arr": [-1, -2, -3, -4]}, {"arr": [1000000, 1000000, 1000000]}, {"arr": [1, 0, 2, 0, 3]}, {"arr": [1, 1, 1, 1, 1]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{"tuple_list": "[]"}, {"tuple_list": "[()]"}, {"tuple_list": "[(1,)]"}, {"tuple_list": "[(1, 2)]"}, {"tuple_list": "[(1, 2, 3)]"}, {"tuple_list": "[(1,), (2,)]"}, {"tuple_list": "[(1, 2), (3, 4)]"}, {"tuple_list": "[(1, 2, 3), (4, 5, 6)]"}, {"tuple_list": "[(1,), (2, 3)]"}, {"tuple_list": "[(1, 2), (3,)]"}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["a12c3", "4d5e6", "798ihjklg", "no", "23456", "pqr0tu"]}, {"strings": ["1bca32", "4d5e6fD", "ghi789jl", "mnoa", "425316", "pqr0tu"]}, {"strings": ["321bca", "d5e6f", "7g8lijhk9", "no", "12345", "pqqr0stu"]}, {"strings": ["a1b2c", "4de6f", "ghi789jl", "mn", "12p3456", "pq0stu"]}, {"strings": ["a1b2c3Y", "4db5e6f", "7ghi789jkl", "mno", "1p23456", "pqr0stuF"]}, {"strings": ["b13c2a", "5d4f6e", "ghi789Djkl", "dmno", "624315", "pqr0su"]}, {"strings": ["a1b2c3i", "4Wd5e6f", "ghi89jkl", "mnoP", "432516", "pqWr0stu"]}, {"strings": ["b2c1a3", "65de4f", "gi789jkl", "mo", "12356", "pqs0tur"]}, {"strings": ["a1b2c", "4d5ef", "gchi789jkl", "nom", "12456", "pqr0tu"]}, {"strings": ["b32ca1", "ed645f", "ghi789pjkl", "nmo", "12456", "pqr0st"]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": "5", "k": "2"}, {"n": "0", "k": "0"}, {"n": "10", "k": "10"}, {"n": "-5", "k": "2"}, {"n": "5", "k": "-2"}, {"n": "100", "k": "50"}, {"n": "1000", "k": "500"}, {"n": "999999999", "k": "499999999"}, {"n": "0", "k": "5"}, {"n": "5", "k": "0"}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [-206, 296, -681, 667, -260, 780, 391]}, {"arr": [941, -694, 352, 160, -382, -93, -600]}, {"arr": [-659, -847, -744, -914, 507, 659, 130]}, {"arr": [821, -561, 531, 571, 572, -812, 231]}, {"arr": [941, 668, 161, -162, -606, -339, 314]}, {"arr": [-162, -428, 753, -178, 977, 969, -603]}, {"arr": [850, -821, -110, 441, 750, -944, 342]}, {"arr": [-853, -876, 595, 384, 791, 911, -44]}, {"arr": [35, 458, -458, 828, -464, -287, 931]}, {"arr": [-197, 641, -384, -230, -652, -527, 273]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "abHc"}, {"s": "bc"}, {"s": "ab"}, {"s": "ab"}, {"s": "abcm"}, {"s": "ac"}, {"s": "ac"}, {"s": "cba"}, {"s": "cab"}, {"s": "bc"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": "[[1,2,3],[4,5,6],[7,8,9]]", "k": "3"}, {"numbers": "[[1,1,1],[2,2,2],[3,3,3]]", "k": "2"}, {"numbers": "[]", "k": "5"}, {"numbers": "[[1],[2],[3]]", "k": "0"}, {"numbers": "[[1,1,2,2,3,3,4,4,5,5]]", "k": "10"}, {"numbers": "[[999999999,999999999,999999999]]", "k": "1"}, {"numbers": "[[-1,-1,-2,-2,-3,-3]]", "k": "3"}, {"numbers": "[[1,2],[3,4],[5,6],[7,8],[9,10]]", "k": "-1"}, {"numbers": "[[0,0,0,0,0,0,0,0,0,0]]", "k": "1000"}, {"numbers": "[[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]", "k": "2147483647"}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"n": "17"}, {"n": "100"}, {"n": "1"}, {"n": "0"}, {"n": "-5"}, {"n": "2147483647"}, {"n": "999983"}, {"n": "2"}, {"n": "1000000000"}, {"n": "123456789"}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": "0"}, {"decimal_num": "1"}, {"decimal_num": "10"}, {"decimal_num": "-5"}, {"decimal_num": "2147483647"}, {"decimal_num": "-2147483648"}, {"decimal_num": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"decimal_num": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"decimal_num": "1.5"}, {"decimal_num": "abc"}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [2, 3, 4, 5, 7]}, {"arr": [1, 2, 4, 5, 6]}, {"arr": []}, {"arr": [1]}, {"arr": [2, 4, 5, 6, 7]}, {"arr": [1, 2, 3, 4, 6]}, {"arr": [0, 1, 2, 3, 5]}, {"arr": [10, 11, 12, 14, 15]}, {"arr": [1, 3, 4, 5, 6]}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 1}, {"n": 0}, {"n": -1}, {"n": 2147483647}, {"n": -2147483648}, {"n": 100}, {"n": 999}, {"n": 1000}, {"n": 65535}, {"n": 32768}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": 1}, {"denominator": 1}, {"n": 1}, {"numerator": 0, "denominator": 1, "n": 1}, {"numerator": 1, "denominator": 0, "n": 1}, {"numerator": 1, "denominator": 3, "n": 5}, {"numerator": 22, "denominator": 7, "n": 10}, {"numerator": 1, "denominator": 97, "n": 20}, {"numerator": 2147483647, "denominator": 1, "n": 1}, {"numerator": 1, "denominator": 2147483647, "n": 1000}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [1, 2, 3, "a", "b", "c"]}, {"mixed_list": []}, {"mixed_list": [5, 3, 1, 4, 2]}, {"mixed_list": ["zebra", "apple", "banana"]}, {"mixed_list": [1, "a", 2, "b", 3, "c"]}, {"mixed_list": [999999999999999999, -999999999999999999, 0]}, {"mixed_list": ["", " ", "  ", "   "]}, {"mixed_list": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]}, {"mixed_list": ["a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a"]}, {"mixed_list": [1.5, 2.7, "3.14", 4]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [2, 1]}, {"numbers": [4, 3]}, {"numbers": [6, 5]}, {"numbers": [8, 7]}, {"numbers": [10, 9]}, {"numbers": [0, 1]}, {"numbers": [2, 0]}, {"numbers": []}, {"numbers": [2]}, {"numbers": [1]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "aabbccO"}, {"s": "laabbcc"}, {"s": "aabEbcc"}, {"s": "babacc"}, {"s": "aabbcNc"}, {"s": "aabcc"}, {"s": "aabcc"}, {"s": "bccbaa"}, {"s": "aabcbc"}, {"s": "ccbaba"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{"nested_list": [[-981, -462, -626], ["a", "b", "c"], [104, "a", -360.06420113268746], []]}, {"nested_list": [[409, 435, 80], ["a", "bt", "c"], [-629, "a", -620.7495556336293], []]}, {"nested_list": [[834, 786, 641], ["ae", "b", "c"], [-143, "a", -15.446589401696542], []]}, {"nested_list": [[-61, 783, -670], ["a", "b", "Pc"], [-515, "ga", 897.1918819037919], []]}, {"nested_list": [[12, 303, 682], ["a", "bs", "c"], [877, "ya", -65.51555503987379], []]}, {"nested_list": [[-205, 527, 566], ["aT", "b", "c"], [-920, "a", -161.4464398210107], []]}, {"nested_list": [[428, -125, 259], ["ay", "b", "c"], [142, "a", 319.53785964991266], []]}, {"nested_list": [[324, 870, 258], ["a", "b", "c"], [-832, "wa", 166.12483694532307], []]}, {"nested_list": [[-315, -369, -169], ["la", "b", "c"], [-538, "a", 334.49022461155687], []]}, {"nested_list": [[-671, -603, -450], ["a", "bj", "c"], [-877, "a", 22.34034264335105], []]}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [-852, -594, 180, -716, -349, 249, -180, 570, -581, 569]}, {"numbers": [-917, -168, -240, -457, 981, 314, -779, -388, 406, 793]}, {"numbers": [154, -129, -771, -737, -390, -587, 193, -626, -864, -410]}, {"numbers": [-237, 637, -451, -227, 683, -763, 592, -77, -427, -750]}, {"numbers": [972, 390, 573, 402, 342, -5, 751, -561, -576, -492]}, {"numbers": [734, 619, -626, -599, -601, 726, -158, -242, -488, 179]}, {"numbers": [-802, 236, -504, -404, 615, 203, 887, 483, 141, 117]}, {"numbers": [907, 305, 948, 835, 562, -627, 133, -637, -465, 455]}, {"numbers": [592, 550, -523, 265, 883, 379, 892, 790, 585, 808]}, {"numbers": [733, 789, 630, -666, 563, -779, -748, 558, 781, 19]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [1, 1, 2, 2, 3, 3]}, {"arr": []}, {"arr": [5]}, {"arr": [10, 10, 10, 10, 10]}, {"arr": [0, 0, 0, 0, 0]}, {"arr": [-1, -1, 2, 2, -3]}, {"arr": [999999999, 999999999, -999999999, -999999999]}, {"arr": [1, 2, 3, 2, 1, 3, 4, 5, 4]}, {"arr": [1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000, 1000000]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world"}, {"text": "test_case_example"}, {"text": "a_b"}, {"text": "valid_pattern"}, {"text": "no_underscore"}, {"text": "UPPER_CASE"}, {"text": "mixedCase_underscore"}, {"text": "multiple_underscores_here"}, {"text": "123_numbers"}, {"text": "special!chars"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "temst", "string": "ettsgin"}, {"word": "t0est", "string": "testinFg"}, {"word": "tet", "string": "tesing"}, {"word": "est", "string": "enttgis"}, {"word": "ttest", "string": "tesing"}, {"word": "tet", "string": "tes9ting"}, {"word": "est", "string": "testin7g"}, {"word": "sett", "string": "teysting"}, {"word": "tes", "string": "sigtnte"}, {"word": "teUst", "string": "tes5ting"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24]}, {"numbers": [0, 5, 10]}, {"numbers": [-12, 18, -24]}, {"numbers": [1]}, {"numbers": [2147483647, 2147483647]}, {"numbers": [-2147483648, -2147483648]}, {"numbers": [0, 0, 0]}, {"numbers": [1, 0, 1]}, {"numbers": [999999999, 888888888, 777777777]}, {"numbers": []}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}, {"numbers": [1, 1, 2, 3, 4]}, {"numbers": []}, {"numbers": [1]}, {"numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]}, {"numbers": [1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]}, {"numbers": [1.1, 2.2, 3.3, 4.4, 5.5]}, {"numbers": [1.1, 1.1, 2.2, 3.3]}, {"numbers": [9999999999, 9999999998, 9999999997, 9999999996, 9999999995]}, {"numbers": [9999999999, 9999999999, 9999999998, 9999999997]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"a": 5, "b": 10}, {"a": 10, "b": 5}, {"a": 0, "b": 0}, {"a": -5, "b": -3}, {"a": 100, "b": 105}, {"a": 1, "b": 1000}, {"a": 999, "b": 1000}, {"a": 0, "b": 1}, {"a": 2147483647, "b": 2147483647}, {"a": -2147483648, "b": -2147483647}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "255"}, {"n": "2147483647"}, {"n": "4294967295"}, {"n": "18446744073709551615"}, {"n": "-1"}, {"n": "-2147483648"}, {"n": "9223372036854775807"}, {"n": "170141183460469231731687303715884105727"}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]"}, {"matrix": "[]"}, {"matrix": "[[], [], []]"}, {"matrix": "[[1], [2, 3], [4, 5, 6]]"}, {"matrix": "[[1], [2], [3]]"}, {"matrix": "[[1, 2], [3, 4], [5, 6]]"}, {"matrix": "[[1], [2], [3], [4], [5], [6], [7], [8], [9], [10]]"}, {"matrix": "[[1, 2, 3, 4, 5], [6, 7], [8, 9, 10, 11]]"}, {"matrix": "[[1], [], [2]]"}, {"matrix": "[[1, 2], [], [3, 4]]"}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": [[413, -283, -166], [886, -148], [973, 897, -212, 952], [395]]}, {"lists": [[70, 200, 660], [-992, 49], [381, -72, 40, -411], [-636]]}, {"lists": [[-558, 914, 213], [-889, -964], [602, -886, 79, -71], [503]]}, {"lists": [[749, 525, -307], [856, 557], [-549, -934, 206, -790], [-450]]}, {"lists": [[-435, -948, -984], [58, 630], [-655, -944, -247, 712], [461]]}, {"lists": [[-978, 954, -828], [871, 301], [-62, -106, 693, 976], [93]]}, {"lists": [[-658, -61, 283], [716, -75], [-131, 273, 650, -593], [259]]}, {"lists": [[916, -16, 385], [442, 301], [204, -383, -259, -28], [-332]]}, {"lists": [[892, 799, 152], [655, 437], [772, 32, -759, 594], [328]]}, {"lists": [[-670, -911, -480], [-720, 393], [-509, 857, -42, 338], [-639]]}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": "1", "side2": "1", "side3": "1"}, {"side1": "0", "side2": "0", "side3": "0"}, {"side1": "-1", "side2": "-1", "side3": "-1"}, {"side1": "9999999999999999999999999999999999999999", "side2": "9999999999999999999999999999999999999999", "side3": "9999999999999999999999999999999999999999"}, {"side1": "1.1", "side2": "1.1", "side3": "1.1"}, {"side1": "A", "side2": "A", "side3": "A"}, {"side1": "", "side2": "", "side3": ""}, {"side1": "1", "side2": "1", "side3": "2"}, {"side1": "null", "side2": "null", "side3": "null"}, {"side1": "1", "side2": "2", "side3": "3"}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": "5.0", "height": "3.0"}, {"base": "0.0", "height": "10.0"}, {"base": "10.0", "height": "0.0"}, {"base": "0.0", "height": "0.0"}, {"base": "-5.0", "height": "3.0"}, {"base": "5.0", "height": "-3.0"}, {"base": "-5.0", "height": "-3.0"}, {"base": "99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999", "height": "1.0"}, {"base": "1.0", "height": "99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"base": "NaN", "height": "5.0"}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "rrcceaa"}, {"s": "racDecar"}, {"s": "racecr"}, {"s": "racecFar"}, {"s": "rcecar"}, {"s": "rraceac"}, {"s": "racecapr"}, {"s": "jracecar"}, {"s": "racecarj"}, {"s": "racecark"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": []}, {"arr": [5, 5, 5, 5, 5]}, {"arr": [-10, -5, 0, 5, 10]}, {"arr": [1000000, -1000000]}, {"arr": [0]}, {"arr": [2147483647, -2147483648]}, {"arr": [1, 3, 2, 3, 1]}, {"arr": [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]}, {"arr": [1, 2, 1, 2, 1, 2]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": "1"}, {"a": "0"}, {"a": "-1"}, {"a": "99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"a": "1", "r": "0"}, {"a": "1", "r": "1"}, {"a": "1", "r": "-1"}, {"a": "1", "r": "2", "n": "0"}, {"a": "1", "r": "2", "n": "1"}, {"a": "1", "r": "2", "n": "1000"}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"n": "123"}, {"n": "0"}, {"n": "1"}, {"n": "-1"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "abc"}, {"n": "null"}, {"n": "true"}, {"n": "1.5"}, {"n": ""}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [1, 2, 3, 4, 5]}, {"digits": [0, 0, 0, 0]}, {"digits": [9, 9, 9, 9, 9]}, {"digits": [1, 34, 3, 98, 9, 76, 45, 4]}, {"digits": [999, 99, 9]}, {"digits": [0]}, {"digits": [121, 12]}, {"digits": [830, 8308]}, {"digits": [10, 2]}, {"digits": [3, 30, 34, 5, 9]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"a": "0", "b": "0"}, {"a": "1", "b": "1"}, {"a": "-1", "b": "-1"}, {"a": "1", "b": "-1"}, {"a": "-1", "b": "1"}, {"a": "2147483647", "b": "-2147483648"}, {"a": "-2147483648", "b": "2147483647"}, {"a": "0", "b": "-2147483648"}, {"a": "-2147483648", "b": "0"}, {"a": "9223372036854775807", "b": "-9223372036854775808"}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "2"}, {"n": "-1"}, {"n": "2147483647"}, {"n": "-2147483648"}, {"n": "9999999999999999999999999999999999999999"}, {"n": "-9999999999999999999999999999999999999999"}, {"n": "0.5"}, {"n": "test"}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": [769, 706, 892, 861, 445, 357, -478, -701]}, {"arr": [-804, -581, 869, -923, 7, -364, 627, -684]}, {"arr": [422, -942, 56, -733, -942, 997, -518, 768]}, {"arr": [-764, -918, -571, 596, 669, 211, 45, 781]}, {"arr": [850, 517, -232, -110, 864, 859, -741, 964]}, {"arr": [152, 960, -852, -374, 821, -315, 560, -889]}, {"arr": [472, -578, 386, 909, -492, 264, -239, 858]}, {"arr": [-700, -337, 474, 751, -74, 230, -617, -610]}, {"arr": [678, -971, -540, 782, 209, 728, -402, -180]}, {"arr": [380, -961, 162, -182, -88, -139, 84, -927]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "110"}, {"s": "101e"}, {"s": "011"}, {"s": "l101"}, {"s": "01"}, {"s": "10"}, {"s": "011"}, {"s": "1021"}, {"s": "10"}, {"s": "110"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}, {"numbers": [-5, -2, 0, 3, 7]}, {"numbers": [100]}, {"numbers": [3.14, 2.71, 1.41]}, {"numbers": []}, {"numbers": [999999999999999999, -999999999999999999]}, {"numbers": [0, 0, 0, 0]}, {"numbers": [1, -1, 2, -2, 3, -3]}, {"numbers": [2147483647, -2147483648]}, {"numbers": [1.5, 2, 3.7, 4, 5.2]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": "[[1, 2], [3, 4]]"}, {"pairs": "[[0, 0], [0, 0]]"}, {"pairs": "[[-1, -1], [1, 1]]"}, {"pairs": "[[1000000, 1000000], [-1000000, -1000000]]"}, {"pairs": "[[0, 0]]"}, {"pairs": "[]"}, {"pairs": "[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]"}, {"pairs": "[[2147483647, 2147483647], [-2147483648, -2147483648]]"}, {"pairs": "[[1.5, 2.5], [3.5, 4.5]]"}, {"pairs": "[[\"1\", \"2\"], [\"3\", \"4\"]]"}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{"tuples_list": "[]", "sort_index": "null", "reverse": "false"}, {"tuples_list": "[[1, 2], [3, 1], [2, 3]]", "sort_index": "null", "reverse": "false"}, {"tuples_list": "[[1, 2], [3, 1], [2, 3]]", "sort_index": "1", "reverse": "true"}, {"tuples_list": "[[1]]", "sort_index": "0", "reverse": "false"}, {"tuples_list": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]]", "sort_index": "2", "reverse": "false"}, {"tuples_list": "[]", "sort_index": "0", "reverse": "true"}, {"tuples_list": "[[1, 2], [3, 4]]", "sort_index": "-1", "reverse": "false"}, {"tuples_list": "[[1, 2], [3, 4]]", "sort_index": "5", "reverse": "false"}, {"tuples_list": "[[9223372036854775807, -9223372036854775808], [0, 0]]", "sort_index": "0", "reverse": "false"}, {"tuples_list": "[[null, \"b\"], [\"a\", null]]", "sort_index": "0", "reverse": "false"}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [306, [-844, 921], [935, [-691, 502]], -127]}, {"lst": [-181, [330, -79], [-557, [595, 800]], -263]}, {"lst": [-778, [-424, -700], [-521, [-925, 177]], 575]}, {"lst": [-813, [-190, -185], [-151, [310, -101]], -945]}, {"lst": [729, [-94, -475], [738, [736, 641]], 583]}, {"lst": [783, [656, -756], [-41, [376, 815]], -579]}, {"lst": [-351, [314, -491], [-691, [15, -889]], -603]}, {"lst": [602, [890, -600], [898, [399, -438]], 21]}, {"lst": [-570, [-972, 789], [-554, [-485, 854]], 275]}, {"lst": [-328, [702, 993], [659, [-912, 483]], 459]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}, {"numbers": [-1, -2, -3, -4, -5]}, {"numbers": [0, 0, 0, 0, 0]}, {"numbers": [1, -1, 2, -2, 0]}, {"numbers": [999999999999999999999999999999]}, {"numbers": [-999999999999999999999999999999]}, {"numbers": [1.5, -2.7, 3.1, -4.9, 0.0]}, {"numbers": []}, {"numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50]}, {"numbers": [1e-30, -1e-30]}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "5"}, {"n": "-1"}, {"n": "999"}, {"n": "1000"}, {"n": "-999"}, {"n": "-1000"}, {"n": "2147483647"}, {"n": "-2147483648"}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [5, 4, 3, 2, 1]}, {"arr": [1, 3, 2, 4, 5]}, {"arr": []}, {"arr": [42]}, {"arr": [1, 1, 1, 1, 1]}, {"arr": [1, 2, 2, 3, 4]}, {"arr": [5, 4, 4, 3, 2]}, {"arr": [1, 2, 3, 2, 1]}, {"arr": [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": [1, 2, 3, 4, 5], "sublist": [2, 3]}, {"main_list": [], "sublist": []}, {"main_list": [1, 2, 3], "sublist": [4, 5]}, {"main_list": ["a", "b", "c", "d"], "sublist": ["b", "c"]}, {"main_list": [1], "sublist": [1]}, {"main_list": [1, 2, 3, 4, 5], "sublist": []}, {"main_list": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], "sublist": [9, 10]}, {"main_list": [1, 2, 3], "sublist": [1, 2, 3]}, {"main_list": [1, 2, 3, 4, 5], "sublist": [3, 4, 5]}, {"main_list": [1, 2, 3, 4, 5], "sublist": [1, 3]}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [5, 4, 3, 2, 1]}, {"arr": [1]}, {"arr": []}, {"arr": [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}, {"arr": [1, 1, 1, 1, 1]}, {"arr": [999999999, -999999999, 0]}, {"arr": [2.5, 1.1, 3.7, 0.5]}, {"arr": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]}, {"arr": [2147483647, -2147483648, 0, 1, -1]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": "4"}, {"n": "5"}, {"n": "0"}, {"n": "1"}, {"n": "2"}, {"n": "3"}, {"n": "8"}, {"n": "12"}, {"n": "-1"}, {"n": "2147483647"}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "hello world", "delimiters": [" ", ","]}, {"text": "a,b,c", "delimiters": [","]}, {"text": "test1;test2;test3", "delimiters": [";"]}, {"text": "", "delimiters": [" ", ",", ";"]}, {"text": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", "delimiters": ["x"]}, {"text": "a.b.c", "delimiters": ["."]}, {"text": "word", "delimiters": []}, {"text": "split|on|pipes", "delimiters": ["|"]}, {"text": "multiple,,commas", "delimiters": [","]}, {"text": "complex.delimiter;test", "delimiters": [".", ";"]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": "abc", "patterns": ["xyz"]}, {"sequence": "aabbcc", "patterns": ["112233"]}, {"sequence": "aaaaaaaaaa", "patterns": ["xxxxxxxxxx"]}, {"sequence": "", "patterns": [""]}, {"sequence": "abc", "patterns": ["aaa"]}, {"sequence": "xyzxyz", "patterns": ["abcabc", "ababab"]}, {"sequence": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "patterns": ["bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"]}, {"sequence": "abc", "patterns": ["abc", "xyz", "123", "aaa", "abb", "abc", "xyz", "123", "aaa", "abb", "abc", "xyz", "123", "aaa", "abb", "abc", "xyz", "123", "aaa", "abb"]}, {"sequence": "abc", "patterns": ["abc", "xyz", "123", "aaa", "abb", "abc", "xyz", "123", "aaa", "abb", "abc", "xyz", "123", "aaa", "abb", "abc", "xyz", "123", "aaa", "abb", "abc", "xyz", "123", "aaa", "abb", "abc", "xyz", "123", "aaa", "abb", "abc", "xyz", "123", "aaa", "abb", "abc", "xyz", "123", "aaa", "abb", "abc", "xyz", "123", "aaa", "abb", "abc", "xyz", "123", "aaa", "abb"]}, {"sequence": "a", "patterns": ["b"]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{"tuple_list": "[[2, 4], [6, 8], [3, 5]]", "k": "2"}, {"tuple_list": "[[0, 0], [0, 0], [0, 0]]", "k": "1"}, {"tuple_list": "[]", "k": "5"}, {"tuple_list": "[[10, 20, 30], [15, 25, 35]]", "k": "5"}, {"tuple_list": "[[-4, -8], [-6, -12]]", "k": "-2"}, {"tuple_list": "[[1000000000, 2000000000], [3000000000, 4000000000]]", "k": "1000000000"}, {"tuple_list": "[[1, 1], [1, 1], [1, 1]]", "k": "0"}, {"tuple_list": "[[9223372036854775807, 9223372036854775806], [9223372036854775805, 9223372036854775804]]", "k": "1"}, {"tuple_list": "[[], [1, 2], [3, 4, 5]]", "k": "1"}, {"tuple_list": "[[0.5, 1.5], [2.5, 3.5]]", "k": "0.5"}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": "5", "width": "3"}, {"length": "0", "width": "5"}, {"length": "5", "width": "0"}, {"length": "-1", "width": "3"}, {"length": "3", "width": "-1"}, {"length": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999", "width": "1"}, {"length": "1", "width": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"length": "0", "width": "0"}, {"length": "-5", "width": "-3"}, {"length": "1", "width": "1"}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": "12345"}, {"num": "24680"}, {"num": "13579"}, {"num": "0"}, {"num": "-12345"}, {"num": "99999999999999999999999999999999999999999999999999"}, {"num": "00000000000000000000000000000000000000000000000000"}, {"num": "18446744073709551615"}, {"num": "1.5"}, {"num": "12a34"}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "5"}, {"n": "10"}, {"n": "100"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "-1"}, {"n": "-100"}, {"n": "2147483647"}, {"n": "9223372036854775807"}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "tes"}, {"word": "etts"}, {"word": "ttse"}, {"word": "ttes"}, {"word": "stte"}, {"word": "tesMt"}, {"word": "testP"}, {"word": "estt"}, {"word": "tst"}, {"word": "tevst"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": "0"}, {"n": "1"}, {"n": "5"}, {"n": "100"}, {"n": "-1"}, {"n": "-100"}, {"n": "2147483647"}, {"n": "-2147483648"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{"tuple1": "()", "tuple2": "()"}, {"tuple1": "(1, 2, 3)", "tuple2": "('a', 'b', 'c')"}, {"tuple1": "(1,)", "tuple2": "('a', 'b')"}, {"tuple1": "(1, 2)", "tuple2": "('a',)"}, {"tuple1": "('x' * 100,)", "tuple2": "('y' * 100,)"}, {"tuple1": "(None, True, False)", "tuple2": "(0, 1, -1)"}, {"tuple1": "([], {}, set())", "tuple2": "((), [], {})"}, {"tuple1": "(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)", "tuple2": "('a', 'b', 'c')"}, {"tuple1": "(1, 2)", "tuple2": "('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j')"}, {"tuple1": "(1, 2, 3, 4, 5)", "tuple2": "('a', 'b', 'c', 'd', 'e')"}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": "1.0"}, {"radius": "0.0"}, {"radius": "-1.0"}, {"radius": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"radius": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"radius": "0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"}, {"radius": "NaN"}, {"radius": "Infinity"}, {"radius": "-Infinity"}, {"radius": "1.7976931348623157e+308"}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "cabc"}, {"s": "bca"}, {"s": "a4bc"}, {"s": "aSbc"}, {"s": "bac"}, {"s": "bac"}, {"s": "bca"}, {"s": "Labc"}, {"s": "ab"}, {"s": "abFc"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": "1"}, {"n": "2"}, {"n": "5"}, {"n": "10"}, {"n": "0"}, {"n": "-1"}, {"n": "1000"}, {"n": "999"}, {"n": "1000000"}, {"n": "2147483647"}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": "1.0"}, {"radius": "0.0"}, {"radius": "-1.0"}, {"radius": "999999999.0"}, {"radius": "-999999999.0"}, {"radius": "0.000000000000001"}, {"radius": "NaN"}, {"radius": "Infinity"}, {"radius": "-Infinity"}, {"radius": "1.7976931348623157e+308"}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"n": "1"}, {"n": "2"}, {"n": "0"}, {"n": "-1"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"n": "-10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"n": "18446744073709551615"}, {"n": "-9223372036854775808"}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": {"a": 1}, "dict2": {"b": 2}, "dict3": {"c": 921}}, {"dict1": {"a": 991}, "dict2": {"b": 2, "iJvKopcdlYz7K": "AIq"}, "dict3": {"c": 527}}, {"dict1": {"a": 1}, "dict2": {"b": 2}, "dict3": {"c": 615}}, {"dict1": {"a": 1}, "dict2": {"b": 2, "u9OxKFOQkpV": "Is5C5TX"}, "dict3": {"c": 3}}, {"dict1": {"a": -125}, "dict2": {"b": 187}, "dict3": {"c": 3}}, {"dict1": {"a": 1, "rFgdd": "iomkQDjMeemk"}, "dict2": {"b": 2, "A0k": "UNwcm3g6lE"}, "dict3": {"c": 3}}, {"dict1": {"a": 416}, "dict2": {"b": 2, "qvC": "gK5"}, "dict3": {"c": 3}}, {"dict1": {"a": 1, "8BXSp7V": "Z8Qok77qWgP"}, "dict2": {"b": 2}, "dict3": {"c": 3}}, {"dict1": {"a": 1}, "dict2": {"b": 247}, "dict3": {"c": 3}}, {"dict1": {"a": 1, "WqtZ5lkTV4": "mXl8"}, "dict2": {"b": -567}, "dict3": {"c": 3}}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": ["appl", "bianana", "aprple", "gernoa", "nabaan", "plape"]}, {"elements": ["pealp", "anana", "paepl", "korange", "abnaan", "applfe"]}, {"elements": ["plape", "aaanbn", "appleS", "reagno", "aananb", "aZpple"]}, {"elements": ["ap5ple", "bananai", "appe", "orage", "banna", "aple"]}, {"elements": ["eppla", "banan", "lepap", "anoreg", "ananab", "plepa"]}, {"elements": ["apUple", "bCanana", "pple", "nagroe", "Hbanana", "lapple"]}, {"elements": ["eapple", "bbanana", "apOple", "range", "banna", "apmple"]}, {"elements": ["avpple", "banaBna", "aplpe", "orage", "baana", "aMpple"]}, {"elements": ["Vapple", "banan4a", "lepap", "orane", "bEanana", "aRpple"]}, {"elements": ["eplap", "bananHa", "2apple", "orage", "ba0nana", "eplap"]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": 2175}, {"n": 331}, {"n": 1231}, {"n": 1793}, {"n": 1523}, {"n": 1962}, {"n": 1460}, {"n": 971}, {"n": 1858}, {"n": 1572}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "The quick brown fox jumps oer the lazy dog"}, {"sentence": "The quick brown fox jumps 6over the lazy dog"}, {"sentence": "The quick brown fox jumps ver the lazy dog"}, {"sentence": "The quick brown fox jumps over the lazy do"}, {"sentence": "  ru ehTkxoq mtzr oe dhlc wiubnogjvoapysf e"}, {"sentence": "oheed rxjyklgse uqabnoimw  ht  v ofcTzu orp"}, {"sentence": "tuxgu c ojio hTrvrnobhdqkaesw ozlfpm   ye e"}, {"sentence": "The quick brown foxjumps over the lazy dog"}, {"sentence": "The quick brown fox jumps ovr the lazy dog"}, {"sentence": "gmy qtroipj x bf hdwlsace ouon ek  Tvhourze"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"substring": "teost", "string_list": ["tentsig", "exampleq", "cse"]}, {"substring": "testq", "string_list": ["tejsting", "exaple", "cas"]}, {"substring": "tet", "string_list": ["ensgtti", "exazmple", "qcase"]}, {"substring": "tet", "string_list": ["Gtesting", "lpeaxem", "asce"]}, {"substring": "tet", "string_list": ["tesWting", "euxample", "casEe"]}, {"substring": "etts", "string_list": ["Rtesting", "examplRe", "casEe"]}, {"substring": "testM", "string_list": ["testiEng", "examplej", "cae"]}, {"substring": "stet", "string_list": ["ettinsg", "exampMle", "easc"]}, {"substring": "tst", "string_list": ["ngteist", "epxmlea", "c0ase"]}, {"substring": "stte", "string_list": ["tgietsn", "eample", "caseT"]}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"n": -326}, {"n": 232}, {"n": 633}, {"n": 576}, {"n": 184}, {"n": -395}, {"n": 417}, {"n": -313}, {"n": -44}, {"n": 898}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": "2"}, {"a": "0"}, {"a": "-1"}, {"a": "1000000000"}, {"a": "0.5"}, {"a": "-1000000000"}, {"a": "1"}, {"a": "999999999"}, {"a": "0.00000000000000000000000000000000000000000000000001"}, {"a": "-999999999"}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": [-871.6860428114006, 604.7745667781652, -703.3921721518378, 691.1793741336365, -977.1981115133725]}, {"records": [658.5947558987646, 334.48287806009114, -230.3891210876605, 386.08197501143184, -761.1004787007533]}, {"records": [496.6842093479933, 928.0578715900928, -520.6381580170278, -929.7780566919101, 501.2915065673699]}, {"records": [217.62455910781654, 688.8009694035401, 70.27335207495135, 216.60819584653782, -445.6407629577003]}, {"records": [-792.6710465991351, 240.48555425680783, -985.9490180099767, -624.882809522213, -461.00840059647805]}, {"records": [-316.618121915141, 19.767209409071803, -297.3239360461876, 651.1952221338541, 234.5806095516557]}, {"records": [-752.4288899055493, 248.76896822977332, -423.7711304559717, -152.43088153779522, -104.62065185014637]}, {"records": [85.5399923516131, -155.07503566305243, 130.54108728716614, -184.64414278580418, 916.2855285056792]}, {"records": [924.6221568922906, -797.387848933479, 257.28185032768255, 481.7093077581054, 151.51149205480647]}, {"records": [298.43648033086987, 199.15140487972425, -527.8708540518645, 699.5847750717272, -206.60400986641253]}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5], "target": 10}, {"nums": [1, 2, 3, 4, 5], "target": 0}, {"nums": [1, 2, 3, 4, 5], "target": -5}, {"nums": [1, 2, 3, 4, 5], "target": 100}, {"nums": [10, 20, 30, 40, 50], "target": 60}, {"nums": [1, 1, 1, 1, 1], "target": 3}, {"nums": [5], "target": 5}, {"nums": [5], "target": 6}, {"nums": [], "target": 5}, {"nums": [1, 2, 3, 4, 5], "target": 15}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": "25"}, {"n": "0"}, {"n": "1"}, {"n": "-10"}, {"n": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"n": "18446744073709551615"}, {"n": "2.5"}, {"n": "null"}, {"n": "true"}, {"n": "2147483647"}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": []}, {"lst": [[]]}, {"lst": [[], []]}, {"lst": [[1, 2, 3], [2, 3, 4], [3, 4, 5]]}, {"lst": [["a", "b"], ["b", "c"], ["c", "d"]]}, {"lst": [[null, null, null]]}, {"lst": [[{"key": "value"}], [{"key": "value"}]]}, {"lst": [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]}, {"lst": [["x", "x", "x"], ["y", "y", "y"], ["z", "z", "z"]]}, {"lst": [[1], [1, 1], [1, 1, 1], [1, 1, 1, 1]]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [1, 2, 3]}, {"numbers": [0, 5, 10]}, {"numbers": [-1, -2, -3]}, {"numbers": [1, 0, 0]}, {"numbers": [1000000, 1000000, 1000000]}, {"numbers": [0.1, 0.2, 0.3]}, {"numbers": [1]}, {"numbers": []}, {"numbers": [1, -1, 1, -1, 1]}, {"numbers": [999999, 999999, 999999, 999999]}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": "0"}, {"decimal_num": "1"}, {"decimal_num": "10"}, {"decimal_num": "-5"}, {"decimal_num": "2147483647"}, {"decimal_num": "-2147483648"}, {"decimal_num": "9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"decimal_num": "-9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"}, {"decimal_num": "1.5"}, {"decimal_num": "invalid"}]}
