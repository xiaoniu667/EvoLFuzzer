{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 2}, {"cost": [[149, 540, 118], [918, -704, -978], [891, -671, 697]], "m": 2, "n": 88}, {"cost": [[149, 540, 118], [918, -704, -978], [891, -671, 697]], "m": 719, "n": 553}, {"cost": [[36, -407, -847], [704, 478, -167], [-989, -212, -429]], "m": 721, "n": -976}, {"cost": [[149, 540, 118], [918, -704, -978], [891, -671, 697]], "m": 142.465412750638, "n": -45}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": [1, 2, 3, 4], "test_tup2": [3, 4, 5, 6]}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [2, 3, 4, 5, 6, 7, 8, 9, 10]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9, 3], "k": 3}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 4}, {"n": -698}, {"n": 953}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": 3, "b": 7}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": "abcabc"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": [5, 2, 8, 1, 9, 3], "n": 3}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "test_string", "char": "t"}, {"s": "test_striBng", "char": "lt"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": [[1, 2, 3], [4, 5, 6], [7, 8, 9]]}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2}, "n": 2}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": [3.0, 4.0], "height": 5.0}, {"base_triangle": [3.0, 4.0, 10], "height": -7.126835756685921}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "HelloWorld"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world test_case example_string"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": 4.0}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "hello world", "str2": "aeiou"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5, 1]}, {"nums": [805, -813, 927, -176, -165, 4]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": 21}, {"n": 82}, {"n": 1}, {"n": -267}, {"n": -25.070747636999997}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": 7, "m": 5}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 4, 5]}, {"arr": [-483, 145, -457, -873, -512, -119]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9], [10]]}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "1010"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["a1b2c3", "4d5e6f", "g7h8i9", "j0k1l2m3n4", "o5p6q7r8s9t0", "uvwxyz", "1234567890", "0987654321", "a0a0a0", "1b2c3d4e5f6g7h8i9j0"]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": 5, "k": 2}, {"n": 142, "k": 0.12574889123406852}, {"n": 142, "k": -582}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 3, 1, 3]}, {"arr": [1, 2.0700125750615266, 3, 2, 3, 1, 3]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": [[1, 2, 2], [3, 3, 3, 4], [5, 5, 5, 5, 6]], "k": 3}, {"numbers": [[-390, 746, 909], [-928, 551, -678, -805], [757, 649, 809, 650, 432]], "k": -957}, {"numbers": [[-390, 746, 909], [-928, 551, -678, -805], [757, 649, 809, 650, 432]], "k": 7.654549813184733}, {"numbers": [[-390, 746, 909], [-928, 551, -678, -805], [757, 649, 809, 650, 432], -2], "k": 3}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"n": 28}, {"n": 4.051449454091774}, {"n": 2.121287819906264}, {"n": -865}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": 42}, {"decimal_num": -328}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": [0, 1, 2, 4, 5, 6, 7, 8, 9]}, {"arr": [-962, 158, 388, 935, 503, 663, 424, -187, 558]}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 4}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": 1, "denominator": 3, "n": 5}, {"numerator": -91.89643741164761, "denominator": -102.50060925561718, "n": 5}, {"numerator": -630, "denominator": -196, "n": -845}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [3, "apple", 1, "banana", 2, "cherry"]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [2, 3, 4, 5, 6]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "aabbcc"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{"nested_list": [[1, 2, 3], [2, 3, 4], [3, 4, 5]]}, {"nested_list": [[1, 2, 3], [2, 3, 4], [3, 4, 5], 0]}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]}, {"arr": [-655, -597, 258, 604, -782, -772, 373, -334, 555, -569]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world test_case example_input"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "tes", "string": "test case"}, {"word": "test", "string": "test case"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24]}, {"numbers": [11.17887387410532, 18, 24]}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"a": 5, "b": 10}, {"a": -102.24858819664844, "b": 54}, {"a": -171, "b": -672}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": 42}, {"n": -958}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": [[1, 2], [3, 4], [5, 6]], "index": 1}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9], [10]]}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": 5, "side2": 5, "side3": 5}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": 5.0, "height": 3.0}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "racecar"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}, {"arr": [3, 1, 4, 1, 5, 9, 1.4740242485846575, 6, 5, 3, 5]}, {"arr": [3, 1, 4, 0.7587661469976275, 5, 9, 2, 6, 5, 3, 5]}, {"arr": [3, 1, 4, 0.7587661469976275, 5, 9.824389935866506, 2, 6, 5, 3, 5]}, {"arr": [3, 1, 4, 0.7587661469976275, 5, 9.824389935866506, 2, 6, 5, 3]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": 2.0, "r": 3.0, "n": 4}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"n": 73}, {"n": -102}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [3, 30, 34, 5, 9]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"a": 5, "b": -3}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": 28}, {"n": 5}, {"n": 18.440148122639307}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 4, 4, 5]}, {"arr": [-282, 450, 675, 33, 593, -173, -767]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "101"}, {"s": "101e"}, {"s": "z101"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9, 3]}, {"numbers": [-314, 541, 732, 497, 399, 970]}, {"numbers": [806, -232, -176, 412, 395, 69]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": [[1, 2], [4, 6], [7, 1], [3, 9]]}, {"pairs": [[-900, 665], [963, 866], [-200, 38], [-975, -498], -6]}, {"pairs": [[-900, 665], [963, 866], [-200, 38], [-975, -498]]}, {"pairs": [[804, -350], [-151, 797], [-438, -767], [404, 516]]}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [1, [2, 3], [4, [5, 6]], 7]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1, -2, 3, -4, 5, 0]}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"n": 5}, {"n": -783}, {"n": -772}, {"n": 11.759245018210997}, {"n": 722}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [-244, -983, 984, 429, 114]}, {"arr": [1, 2, 3, 4, 5]}, {"arr": [332, 109, -2, 528, -286]}, {"arr": [491, -440, 486, -115, -685]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": [-202, 651, -483, 269, -225], "sublist": [-330, -207]}, {"main_list": [1, 2, 3, 4, 5], "sublist": [3, 4]}, {"main_list": [-95, -566, 966, 60, -285], "sublist": [700, 17]}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [5, 2, 8, 1, 9, 3, 7, 4, 6]}, {"arr": [5, 2, 8, 1, 9, 3, 7, 4, 5.231291133586781]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": -868}, {"n": 2}, {"n": 5}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "hello,world;test|example", "delimiters": [",", ";", "|"]}, {"text": "hello,world;test|example", "delimiters": [",", ";", "|", -4]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": [-864, 590, 860, 244], "patterns": [["A", "B", "A", "B"], ["WX", "Y", "X", "Y"]]}, {"sequence": [1, 2, 1, 2], "patterns": [["A", "B", "A", "B"], ["X", "Y", "X", "Y"]]}, {"sequence": [-864, 590, 860, 244], "patterns": [["A", "B", "A", "B"], ["WX", "Y", "X", "Y"], -8]}, {"sequence": [-77, -670, 612, -740], "patterns": [["At", "xB", "A", "XB"], ["DX", "Y3", "X", "Y"]]}, {"sequence": [1, 2, 1, 2, 1], "patterns": [["A", "B", "A", "B"], ["X", "Y", "X", "Y"]]}, {"sequence": [1.1777819121015287, 2, 1, 2, 1], "patterns": [["A", "B", "A", "B"], ["WX", "Y", "X", "Y"], -8, -8]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": 5, "width": 3}, {"length": 72, "width": 3}, {"length": -443, "width": -938}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": 1234567890}, {"num": 64}, {"num": 790807004.4905467}, {"num": 2.8728406808608558}, {"num": 19.71125667034853}, {"num": -6.867710805554925}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": 10}, {"n": -932}, {"n": -180.9557024636686}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "test"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{"tuple1": [-42, -22, -855], "tuple2": ["a", "b", "Nc"]}, {"tuple1": [1, 2, 3], "tuple2": ["a", "b", "c"]}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": 1.5}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 5}, {"n": -319}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": 1.0}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"n": 5}, {"n": -336}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": {"a": 1}, "dict2": {"b": 2}, "dict3": {"c": 3}}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": 535149}, {"n": 534976}, {"n": 534965.2805824112}, {"n": 534799.1779068243}, {"n": 534426}, {"n": 535330}, {"n": -8.586281191745277}, {"n": 534060}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"substring": "test", "string_list": ["testing", "example", "case"]}, {"substring": "tets", "string_list": ["tes3ting", "examle", "aesc"]}, {"substring": "test", "string_list": ["tes3ting", "examle", "aesc", 1]}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"n": 121}, {"n": 638}, {"n": -466}, {"n": 599.0871314877846}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": 2.0, "b": 3.0}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": [5.2, 3.1, 8.7, 1.9, 4.4]}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [2, 3, 1, 2, 4, 3], "target": 7}, {"nums": [224, 456, -98, -600, -341, 584], "target": -332}, {"nums": [-877, -724, -240, -299, 951, 291], "target": 744}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": 36}, {"n": 113}, {"n": 73.35546110256328}, {"n": -449}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": [[1, 2, 3], [4, 5, 6], [7, 8, 9]]}, {"lst": [[1, 2, 3], [4, 5, 6], [7, 8, 9], 5]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [2, 4, 6]}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": -131}, {"decimal_num": 42}]}
{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 2}, {"cost": [[-533, -93, -761], [-959, -230, 376], [454, 534, 756]], "m": 794, "n": 110}, {"cost": [[334, -181, 491], [-250, -857, -413], [386, -941, 212]], "m": 350, "n": -777}, {"cost": [[-533, -93, -761], [-959, -230, 376], [454, 534, 756]], "m": 287.94808654229763, "n": 2}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": [1, 2, 3, 4, 5], "test_tup2": [4, 5, 6, 7, 8]}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [1, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9, 3], "k": 3}, {"numbers": [5, 2, 7.866622647032395, 1, 9, 3], "k": 3}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 4}, {"n": -234}, {"n": 933}, {"n": -17.367906936942926}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": 609, "b": -750}, {"a": 3, "b": 2}, {"a": 298.15710547877234, "b": -750}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": "abcabc"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": [5, 2, 8, 1, 9, 3], "n": 3}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "hello world", "char": "l"}, {"s": "hello world", "char": "ld"}, {"s": "helloworld", "char": "lk"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": [[1, 2, 3], [4, 5, 6], [7, 8, 9]]}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2}, "n": 2}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2, "7gkzqOpz": "qeZDebROUy7t7tsTK"}, "n": 33}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": [3.0, 4.0], "height": 5.0}, {"base_triangle": [3.0, 4.0, 1], "height": 5.0}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "HelloWorld"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "helloworld test_case multiple_underscores_here"}, {"text": "hello_world test_case multiple_underscores_here"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": 4.0}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "hello world", "str2": "aeiou"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5]}, {"nums": [1, 2, 3, 4, 5, 2]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": 554}, {"n": 1}, {"n": -962}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": 7, "m": 5}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 4, 5]}, {"arr": [-201, -844, 667, 754, -727, 593]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": [[375, -365, 339], [-636, -582], [911, 29, -569, 29], [-235, -233, 622], [83, 324, -727]]}, {"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9], [-1, -2, -3], [0, 0, 0]]}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "1010"}, {"binary_str": "101z0"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["a1b2c3", "4def5", "ghi6j7k8", "mno9p0q", "rstuvwxyz"]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": 5, "k": 2}, {"n": -955, "k": 112}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [1, 1, 2, 2, 3, 3, 4]}, {"arr": [1.5528359351441643, 1, 2, 2, 3, 3, 4]}, {"arr": [1, 2, 2, 3, 3, 4]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "abc*"}, {"s": "abc"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": [[1, 2, 2], [3, 3, 3, 4], [5], [2, 3, 4, 4, 4]], "k": 3}, {"numbers": [[-556, 930, 36], [-729, 874, 69, 618], [313], [-795, -466, -815, -216, -502]], "k": -324}, {"numbers": [[-556, 930, 36], [-729, 874, 69, 618], [313], [-795, -466, -815, -216, -502]], "k": -103.65143005455917}, {"numbers": [[1, 2, 2], [3, 3, 3, 4], [5], [2, 3, 4, 4, 4], -6], "k": 3}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"n": 13195}, {"n": 14149}, {"n": -4.194746454012113}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": 42}, {"decimal_num": -911}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": [0, 1, 2, 4, 5, 6, 7, 8, 9]}, {"arr": [-741, -209, 598, -67, 573, -157, -423, -787, 66]}, {"arr": [0, 1, 2, 4, 6, 7, 8, 9]}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 4}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": 1, "denominator": 3, "n": 5}, {"numerator": -598, "denominator": 20, "n": 210}, {"numerator": -95, "denominator": 391.64236668218444, "n": 3.5655928195497673}, {"numerator": -750, "denominator": 411, "n": -24}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [-719, "appe", 541, "baneana", -260, "chery"]}, {"mixed_list": [-600, "aplep", -557, "baInana", -265, "cTherry"]}, {"mixed_list": [3, "apple", 1, "banana", 2, "cherry"]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [2, 4, 6, 8, 1, 3, 5, 7]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "aabbcc"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [-39, 241, 793, 843, 175, -148, 919, -262, 277, 558]}, {"numbers": [783, -181, 302, 49, -224, -82, -859, 947, -443, 319]}, {"numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 3, 3, 4]}, {"arr": [381, 903, -591, -323, 250, -853, 184]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world test_case example_string"}, {"text": "heUllo_world test_case example_string"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "test", "string": "test case"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24], "threshold": 6}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"a": 5, "b": 10}, {"a": 5.820940249100593, "b": 10}, {"a": 0, "b": -639}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": 42}, {"n": -139}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": [[1, 2, 3], [4, 5], [6, 7, 8, 9]], "index": 2}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9], [10]]}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": 5, "side2": 5, "side3": 5}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": 5.0, "height": 3.0}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "test"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}, {"arr": [3, 1.8092884568000969, 4, 1, 5, 9, 2, 6, 5, 3, 5]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": 2.0, "r": 3.0, "n": 4}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"n": 73}, {"n": -294}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [3, 30, 34, 5, 9]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"a": 5, "b": -3}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 4, 4, 4, 5]}, {"arr": [-414, -775, -847, -225, -804, 843, -55, -386]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "101"}, {"s": "1q01"}, {"s": "N01"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9]}, {"numbers": [-514, -60, 137, 28, -153]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]]}, {"pairs": [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0], 4]}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [1, [2, 3], [4, [5, 6]], 7]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1, -2, 3, -4, 5, 0]}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"n": 616}, {"n": -98}, {"n": 544.3039355769682}, {"n": 5}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [881, -938, -925, -413, 264]}, {"arr": [1, 2, 3, 4, 5]}, {"arr": [-558, 721, -2, -844, 17]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": [1, 2, 3, 4, 5], "sublist": [2, 3, 4]}, {"main_list": [-207, 155, -287, -933, -124], "sublist": [-559, -165, 239]}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [5, 2, 8, 1, 9, 3, 7, 4, 6]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": 8}, {"n": -954}, {"n": 109}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "hello,world;test|example", "delimiters": [",", ";", "|"]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": [1, 2, 3, 4], "patterns": [["A", "A", "B", "B"], ["A", "B", "A", "B"]]}, {"sequence": [-780, -676, 925, -111], "patterns": [["A", "A", "SB", "B"], ["A", "jB", "aA", "B"]]}, {"sequence": [1, 2, 3, 4], "patterns": [["A", "A", "B", "B"], ["A", "B", "A", "B"], 1]}, {"sequence": [679, -648, 55, 923], "patterns": [["A", "At", "B", "Bb"], ["As", "B", "A", "B"]]}, {"sequence": [1, 2, 3, 4, -1], "patterns": [["A", "A", "B", "B"], ["A", "B", "A", "B"]]}, {"sequence": [1, 2, 3, 4, -1], "patterns": [["A", "A", "B", "B"], ["A", "B", "A", "B"], 1]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": 5, "width": 3}, {"length": 165, "width": -415}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": 1234567890}, {"num": 1219950256.087834}, {"num": -21}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": 10}, {"n": -510}, {"n": -276.9012307568294}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "test"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{"tuple1": [1, 2, 3], "tuple2": ["a", "b", "c"]}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": 1.0}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 10}, {"n": 4.624769947568177}, {"n": -631}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": 1.0}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"n": 5}, {"n": -612}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": {"a": 1}, "dict2": {"b": 2}, "dict3": {"c": 3}}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": 535137}, {"n": 534976}, {"n": 534996.325167712}, {"n": 534994.8532472285}, {"n": -5.056082706788647}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "The quick brown fox jumps over the lazy dog"}, {"sentence": "The quick brown fox jumps overtthe lazy dog"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"substring": "test", "string_list": ["testing", "example", "string"]}, {"substring": "teGst", "string_list": ["isgtnte", "mepaxel", "striSng"]}, {"substring": "teGst", "string_list": ["isgtnte", "mepaxel", "striSng", -5]}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"n": 121}, {"n": 665}, {"n": 934}, {"n": -711}, {"n": 228.4451469868108}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": 2.0, "b": 3.0}, {"a": -843.0194777295739, "b": -405.1881917726913}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": [3.5, 1.2, 4.8, 0.9, 2.1]}, {"records": [-916.8390648473855, -795.5095064267242, 515.610190278921, 174.24832081221976, 831.5180813104135]}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [2, 3, 1, 2, 4, 3], "target": 7}, {"nums": [634, 174, -879, 51, 345, -41], "target": -957}, {"nums": [209, -810, -668, -292, -159, 144], "target": 517}, {"nums": [56, 834, -993, -874, -857, 96], "target": -899}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": 36}, {"n": 905}, {"n": 107.51217958067701}, {"n": -631}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": [["a", "b", "c"], ["b", "c", "d"], ["c", "d", "e"]]}, {"lst": [["a", "b", "c"], ["b", "c", "d"], ["c", "d", "e"], 9]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [2.0, 4.0, 6.0]}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": -392}, {"decimal_num": 42}]}
{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 2}, {"cost": [[-684, -534, -165], [705, 68, -28], [-786, 577, -760]], "m": 590, "n": 41}, {"cost": [[-645, 989, -233], [146, -740, 56], [-535, -167, -542]], "m": -502, "n": -467}, {"cost": [[-645, 989, -233], [146, -740, 56], [-535, -167, -542]], "m": 305.5986369807086, "n": 41}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": [1, 2, 3, 4, 5], "test_tup2": [4, 5, 6, 7, 8]}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9, 3], "k": 3}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 4}, {"n": -87}, {"n": -73}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": 3, "b": 2}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "The quick bron fox jumps over the lazy dog"}, {"text": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0, 4.0, 5.0]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": "abcabc"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": [5, 2, 8, 1, 9, 3], "n": 3}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "test_string", "char": "t"}, {"s": "test_xstring", "char": "t"}, {"s": "test_string", "char": "r"}, {"s": "test_sring", "char": "xt"}, {"s": "st_iegrsntt", "char": "t"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": [[1, 2, 3], [4, 5, 6], [7, 8, 9]]}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2}, "n": 2}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": [3.0, 4.0], "height": 5.0}, {"base_triangle": [3.0, 4.0, -2], "height": 5.0}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "HelloWorldPython"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world test_case example_sequence_here"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": 1.3547380430084601}, {"side_length": 4.0}, {"side_length": -300.4038290292003}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "hello world", "str2": "aeiou"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": 1}, {"n": 323}, {"n": 11}, {"n": 0.7731484004822491}, {"n": -310}, {"n": -518}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": 7, "m": 5}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 4, 5]}, {"arr": [-177, -434, 409, 248, 739, -121]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9], [-1, -2, -3]]}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "1010"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["a1b2c3", "4d5e6f", "g7h8i9", "j0k1l2m3", "nop4qrs5t", "uv6w7x8y9z"]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": 5, "k": 2}, {"n": 734, "k": 1.5811430442003953}, {"n": 734, "k": -622}, {"n": 458.83190204832846, "k": 1.680293567237298}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 3, 1, 3]}, {"arr": [1, 1.0593017486172074, 3, 2, 3, 1, 3]}, {"arr": [1, 1.0593017486172074, 3, 1.3302659116911117, 3, 1, 3]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "bacad"}, {"s": "abcda"}, {"s": "aadbc"}, {"s": "aacdb"}, {"s": "abca"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": [[1, 2, 3], [2, 3, 4], [1, 1, 2, 3]], "k": 2}, {"numbers": [[935, 598, 196], [-599, 893, -460], [-742, -658, 715, 66]], "k": -805}, {"numbers": [[377, -22, -387], [216, 913, -943], [-5, 269, -424, 665]], "k": -543.1505640736956}, {"numbers": [[377, -22, -387], [216, 913, -943], [-5, 269, -424, 665], -1], "k": -805}, {"numbers": [[377, -22, -387], [216, 913, -943], [-5, 269, -424, 665]], "k": 639}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"n": 28}, {"n": 719}, {"n": 2.4009442037583995}, {"n": -28}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": 42}, {"decimal_num": -413}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": [0, 1, 2.1672782077298036, 4, 5, 6, 7]}, {"arr": [896, 108, 47, 404, 433, 194, -353]}, {"arr": [0, 1, 2, 4, 5, 6, 7, 2]}, {"arr": [0, 1, 2, 4, 5, 6, 7]}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 4}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": 1, "denominator": 3, "n": 5}, {"numerator": 611.4100281047533, "denominator": -148.51901647636004, "n": 5}, {"numerator": 674, "denominator": -441, "n": -941}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [3, "apple", 1, "banana", 2, "cherry"]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [2, 3, 4, 5]}, {"numbers": [755, -589, -861, -633]}, {"numbers": [886, -738, 306, 776]}, {"numbers": [755, -861, -633]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "aabbcc"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{"nested_list": [[1, 2, 3], ["a", "b", "c"], [1, "a", 2]]}, {"nested_list": [[1, 2, 3], ["a", "b", "c"], [1, "a", 2], 10]}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]}, {"arr": [772, 756, 97, 361, 428, 180, -744, -947, -365, -844]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world test_case another_example"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "test", "string": "test string"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24], "threshold": 6}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"a": 5, "b": 10}, {"a": 553, "b": -966}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": 42}, {"n": -139}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "index": 1}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9], [10]]}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": 5.0, "side2": 5.0, "side3": 5.0}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": 5.0, "height": 3.0}, {"base": 5.0, "height": 3.4569276691558826}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "racecar"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}, {"arr": [3, 1, 4.060225993351907, 1, 5, 9, 2, 6, 5, 3, 5]}, {"arr": [3, 0.8425778016280645, 4, 1, 5, 9, 2, 6, 5, 3, 5]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": 2.0, "r": 3.0, "n": 4}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"n": 244}, {"n": -606}, {"n": 73}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [3, 30, 34, 5, 9]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"a": 5, "b": -3}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": -490}, {"n": 5}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 4, 4, 4, 5]}, {"arr": [140, 177, 999, 745, -126, 374, -220, -581]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "101"}, {"s": "10n1"}, {"s": "@0n1"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9]}, {"numbers": [-569, 72, 616, 564, 5]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]]}, {"pairs": [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0], -3]}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [1, [2, 3], [4, [5, 6]], 7]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1, -2, 3, 0, -4, 5]}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"n": 5}, {"n": -627}, {"n": -482.3644438458087}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [68, -401, -636, -268, 672]}, {"arr": [1, 2, 3, 4, 5]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": [1, 2, 3, 4, 5], "sublist": [2, 3]}, {"main_list": [960, 118, 208, 387, -50], "sublist": [-692, 461]}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [5, 2, 8, 1, 9, 3, 7, 4, 6]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": 484}, {"n": -34}, {"n": 15}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "hello,world;test|example", "delimiters": [",", ";", "|"]}, {"text": "hello,world;test|example", "delimiters": [",", ";", "|", -1]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": "acb", "patterns": ["23", "11", "122"]}, {"sequence": "ac7", "patterns": ["23", "11", "122", 4]}, {"sequence": "ac", "patterns": ["u123", "12", "12"]}, {"sequence": "abc", "patterns": ["123", "112", "122"]}, {"sequence": "ab", "patterns": ["m123", "112w", "1Y22"]}, {"sequence": "ac7#", "patterns": ["23", "11", 4]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": 5, "width": 3}, {"length": -266, "width": 86}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": 123456}, {"num": 26}, {"num": 46325.854598769576}, {"num": 3.539603462534952}, {"num": -81}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": 5}, {"n": -888}, {"n": -130.40140295300262}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "test"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{"tuple1": [1, 2, 3], "tuple2": ["a", "b", "c"]}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": 1.0}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 5}, {"n": 3.532437422109013}, {"n": -687}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": 1.5}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"n": 5}, {"n": -213}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": {"a": 1, "b": 2}, "dict2": {"c": 3, "d": 4}, "dict3": {"e": 5, "f": 6}}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": 534601}, {"n": 534976}, {"n": 534862.6320176905}, {"n": 1.7245937079579718}, {"n": -2.1459652813631287}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"substring": "test", "string_list": ["testing", "example", "string"]}, {"substring": "tes", "string_list": ["etgints", "exampleI", "rstring"]}, {"substring": "test", "string_list": ["etgints", "exampleI", "rstring", 5]}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"n": 121}, {"n": 655}, {"n": 307}, {"n": -17}, {"n": 267.04302388247754}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": 2.0, "b": 3.0}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": [5.2, 3.1, 8.7, 2.9, 4.5]}, {"records": [-221.3363664253148, -20.000075073227798, 985.3577977657524, -59.64157625345715, 165.29657289487]}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [2, 3, 1, 2, 4, 3], "target": 7}, {"nums": [-85, -939, 945, 599, -482, 87], "target": -621}, {"nums": [678, 95, -275, 107, -226, -335], "target": 970}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": 36}, {"n": 668}, {"n": 272.64285506713503}, {"n": 0.41498596653216424}, {"n": -338}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": [["apple", "banana"], ["banana", "cherry"], ["cherry", "date", "apple"]]}, {"lst": [["apple", "banana"], ["banana", "cherry"], ["cherry", "date", "apple"], 0]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [2.0, 3.0, 4.0]}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": -725}, {"decimal_num": 42}]}
{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 2}, {"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 78}, {"cost": [[765, 964, -939], [345, 122, -640], [-705, -630, -78]], "m": 588, "n": 617}, {"cost": [[-108, 545, -168], [509, -877, -901], [-220, -410, -373]], "m": -789, "n": -181}, {"cost": [[-108, 545, -168], [509, -877, -901], [-220, -410, -373]], "m": 588, "n": 404.44100117500926}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": [1, 2, 3, 4, 5], "test_tup2": [4, 5, 6, 7, 8]}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [2, 3, 4, 5, 6, 7, 8, 9, 10]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [5, 3, 8, 1, 9, 2], "k": 3}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 4}, {"n": -358}, {"n": 217}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": 3, "b": 2}, {"a": 2, "b": 2}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0, 4.0, 5.0]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": [5, 2, 8, 1, 9, 3], "n": 3}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "hello world", "char": "l"}, {"s": "hell world", "char": "lP"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": [[3, 2, 1], [1, 1, 1], [4, 5, 6]]}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2}, "n": 3}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2, "WU98tVA1uxjl8dOm": "JN"}, "n": 921}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": [3.0, 4.0], "height": 5.0}, {"base_triangle": [3.0, 4.0, -9], "height": 5.0}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "HelloWorldPython"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world_test_case_example"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": 4.0}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "abcdef", "str2": "ace"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5, 1]}, {"nums": [-583, 880, -421, 156, 79, 908]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": 995}, {"n": 1}, {"n": -581}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": 7, "m": 5}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 4, 5]}, {"arr": [532, -975, 461, -982, 728, 996]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9], [10]]}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "1010"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["abc123def", "456", "gh7i8j9", "hello", "world123", "test456case", "no_digits_here", "1234567890", "mixed123with456digits789", "a1b2c3d4e5f6"]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": 5, "k": 2}, {"n": -695, "k": 874}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [7, 3, 9, 3, 7, 8, 9]}, {"arr": [7, 3, 9, 3, 7, 8, 9.199093078419136]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "abcda"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": [[1, 2, 2], [3, 3, 3], [4, 5]], "k": 2}, {"numbers": [[705, -78, -594], [-941, 753, 957], [239, 571]], "k": -710}, {"numbers": [[1, 2, 2], [3, 3, 3], [4, 5]], "k": -631.9057785949511}, {"numbers": [[1, 2, 2], [3, 3, 3], [4, 5], 9], "k": -406.10329113511614}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"n": 28}, {"n": 19}, {"n": 24}, {"n": -864}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": 42}, {"decimal_num": -738}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": [0, 1, 2, 4, 5, 6, 7, 8, 9, 4]}, {"arr": [812, -239, 189, 720, 710, -70, 428, 273, -958, 154]}, {"arr": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]}, {"arr": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}, {"arr": [0, 1, 2, 3, 4, 6, 7, 8, 9, 4, -1]}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 4}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": 1, "denominator": 3, "n": 5}, {"numerator": -230, "denominator": -160, "n": 651}, {"numerator": -31, "denominator": 580.9532681102718, "n": 24}, {"numerator": 39, "denominator": 781, "n": -872}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [3, "apple", 1, "banana", 2, "cherry"]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [4, 9, 2, 7, 8]}, {"numbers": [-166, -262, 616, 718, 638]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "aabbcc"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{"nested_list": [[1, 2, 3], ["a", "b", "c"], [1, "a", 2.5], []]}, {"nested_list": [[1, 2, 3], ["a", "b", "c"], [1, "a", 2.5], [], -7]}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]}, {"arr": [315, 185, -689, 615, -8, -590, 585, -935, -396, -600]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world test_case example_input"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "test", "string": "testing"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24], "threshold": 6}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"a": 5, "b": 10}, {"a": 1.2364066165508003, "b": 10}, {"a": 33, "b": -98}, {"a": 30.993607543185178, "b": 10}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": 42}, {"n": -294}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": [[1, 2, 3], [4, 5], [6, 7, 8, 9], []], "index": 2}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9], [10]]}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": 5.0, "side2": 5.0, "side3": 5.0}, {"side1": 4.774581342318591, "side2": 1.9524346552528886, "side3": 5.0}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": 5.0, "height": 3.0}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "racecar"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}, {"arr": [3, 1, 4, 1, 5, 9, 2, 6, 5, 3.1681824499740756, 5]}, {"arr": [3, 1, 4, 1, 5, 9.011650756078621, 2, 6, 5, 3.1681824499740756, 5]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": 2.0, "r": 3.0, "n": 4}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"n": 73}, {"n": -426}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [3, 30, 34, 5, 9]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"a": 5, "b": -3}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 4, 4, 4, 5]}, {"arr": [-191, -663, -577, -728, -192, -681, 95, -282]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "101"}, {"s": "10d1"}, {"s": "m101"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9]}, {"numbers": [-994, 437, 704, -370, 503]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]]}, {"pairs": [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0], 7]}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [1, [2, 3], [4, [5, 6]], 7]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1, -2, 3, -4, 5, 0]}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"n": 5}, {"n": -712}, {"n": -357.74640148499503}, {"n": -109.32579021204558}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [511, -354, 607, 365, -80]}, {"arr": [1, 2, 3, 4, 5]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": [1, 2, 3, 4, 5], "sublist": [2, 3]}, {"main_list": [868, -182, -241, 645, 78], "sublist": [594, -403]}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [5, 2, 8, 1, 9, 3, 7, 4, 6]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": -523.1716739531693}, {"n": 8}, {"n": -526}, {"n": -171}, {"n": -317.17833470453394}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "hello,world;t\"st|example", "delimiters": [",", ";", "|"]}, {"text": "hello,world;test|example", "delimiters": [",", ";", "|"]}, {"text": "hello,world;test|example", "delimiters": [",", ";", "|", -6]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": [220, 614, -479, -375], "patterns": [["A", "B", "A", "Bj"], ["X", "Y", "X", "Y"]]}, {"sequence": [1, 2, 1, 2], "patterns": [["A", "tB", "SA", "B"], ["X", "Y", "X", "Yh"]]}, {"sequence": [1, 2, 1, 2], "patterns": [["A", "B", "A", "Bj"], ["X", "Y", "X", "Y"]]}, {"sequence": [1, 2, 1, 2], "patterns": [["A", "B", "A", "B"], ["X", "Y", "X", "Y"]]}, {"sequence": [549, -577, 192, 451], "patterns": [["A", "tB", "SA", "B"], ["X", "Y", "X", "Yh"]]}, {"sequence": [549, -577, 192, 451, -9], "patterns": [["A", "tB", "SA", "B"], ["X", "Y", "X", "Yh"]]}, {"sequence": [549, 192, 451], "patterns": [["A", "tB", "SA", "B"], ["X", "Y", "X", "Yh"], -6, -1]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": 5, "width": 3}, {"length": -866, "width": 50}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": 1234567890}, {"num": 222718556.1245026}, {"num": 6.388711260782944}, {"num": -60}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": -955}, {"n": 10}, {"n": -619}, {"n": -707.7760471867442}, {"n": -970}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "test"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": -133}, {"n": -21.67373841590075}, {"n": 5}, {"n": 730}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": 1.0}, {"radius": -933.9299859646035}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 5}, {"n": 3.231363163815783}, {"n": -960}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": 1.0}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"n": 5}, {"n": -14}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": {"a": 1}, "dict2": {"b": 2}, "dict3": {"c": 3}}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": [1, 2, 3, 2, 1, 3, 3, "a", "b", "a", 1.5, 2.5, 1.5]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": 534566}, {"n": 534976}, {"n": 534759.223538223}, {"n": 534826.1798081067}, {"n": -87}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"substring": "tste", "string_list": ["ngtiets", "exmple", "str4ing"]}, {"substring": "est", "string_list": ["txesting", "elpaxme", "7string"]}, {"substring": "1test", "string_list": ["tesWting", "eample", "stnring", -1]}, {"substring": "1test", "string_list": ["tesWting", "eample", "stnring"]}, {"substring": "test", "string_list": ["testing", "example", "string"]}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"n": 121}, {"n": 133}, {"n": 268}, {"n": -799}, {"n": 209.34785342653106}, {"n": -576.1076146154822}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": 2.0, "b": 3.0}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": [5.2, 3.1, 8.7, 2.9, 4.5]}, {"records": [-890.5705486747569, -307.1141411230336, -585.6955042510506, -81.31400341553896, 824.9389085954115]}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [2, 3, 1, 2, 4, 3], "target": 7}, {"nums": [-451, -944, 140, 602, 296, -541], "target": -918}, {"nums": [-870, -879, 241, -99, 313, -231], "target": 606}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": 36}, {"n": 159}, {"n": 21.911446785367293}, {"n": -19}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": [["a", "b", "c"], ["b", "c", "d"], ["c", "vd", "e"]]}, {"lst": [["a", "b", "c"], ["b", "c", "d"], ["c", "d", "e"]]}, {"lst": [["a", "b", "c"], ["Ab", "Pc", "sd"], ["c", "d", "e"], -10]}, {"lst": [["a", "b", "c"], ["Ab", "Pc", "sd"], ["c", "d", "e"]]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [2, 4, 6], "threshold": 1.5}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": -715}, {"decimal_num": 42}]}
{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 2}, {"cost": [[544, 140, -973], [-749, -158, -450], [767, 794, -628]], "m": 50, "n": 137}, {"cost": [[-46, 460, -161], [287, 826, 90], [-912, 629, -874]], "m": -287, "n": 613}, {"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": -36.264582956613985, "n": 613}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": [1, 2, 3, 4, 5], "test_tup2": [4, 5, 6, 7, 8]}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [2, 3, 4, 5, 6, 7, 8, 9, 10]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [5, 3, 9, 0.5307206290232591, 7], "k": 3.0}, {"numbers": [5, 3, 9, 1, 7], "k": 3}, {"numbers": [5, 3, 9, 0.5307206290232591, 7], "k": 3}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 4}, {"n": -990}, {"n": 113}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": 3, "b": 2}, {"a": 320, "b": 320}, {"a": 3, "b": 177.52348712341038}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0, 4.0, 5.0]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": [830, 599, -149, -453, -501, -127, -731, 432, 480], "n": -33}, {"dataset": [433, 68, -270, 93, -718, 102, -300, 413, 214], "n": -922}, {"dataset": [5, 2, 8, 1, 9, 3, 7, 4, 6], "n": 3}, {"dataset": [-112, 944, -343, -770, -445, 550, 318, -207, 244], "n": -402}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "test string with multiple t characters", "char": "t"}, {"s": "test string withb multiple t characters", "char": "St"}, {"s": "mtir utgiceaihltprh tlstase rswn tcte ", "char": "tf"}, {"s": "ecri phesaartiietlg mts ul nttsctthrw ", "char": "t"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": [[3, 2, 1], [1, 1, 1], [4, 5, 6]]}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2}, "n": 2}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2, "Phcl": "H"}, "n": 855}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": [3.0, 4.0], "height": 5.0}, {"base_triangle": [3.0, 4.0, -2], "height": 5.0}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "HelloWorld"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world_test_case_example"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": 4.0}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "hello world", "str2": "aeiou"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5]}, {"nums": [1, 2, 3, 4, 5, 2]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": 383}, {"n": 893}, {"n": 1}, {"n": -367}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": 7, "m": 5}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 4, 5]}, {"arr": [10, -332, -138, 369, 488, -864]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9]]}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "1010"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}, {"arr": [925, 483, 173, 81, 845]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{"tuple_list": [[1, 2], [3, 4], [5, 6]], "k": 2}, {"tuple_list": [[50, 275], [146, -41], [-513, 315]], "k": -313}, {"tuple_list": [[464, 453], [512, -741], [861, 929]], "k": 831}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["a1b2c3", "4d5e6f", "g7h8i9", "j0k1l2m3n4o5p6q7r8s9t0", "no_digits_here", "1234567890", ""]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": 5, "k": 2}, {"n": 5, "k": 4.511162604626257}, {"n": -102, "k": -509}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 3, 1, 3]}, {"arr": [1, 2, 3.3459358343903554, 2, 3, 1, 3]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": [[1, 2, 3], [2, 3, 4], [1, 1, 2], [3, 4, 5]], "k": 2}, {"numbers": [[130, -80, -324], [-775, 141, 318], [-481, -82, -664], [401, 18, 934]], "k": -370}, {"numbers": [[130, -80, -324], [-775, 141, 318], [-481, -82, -664], [401, 18, 934]], "k": -42.2023550454953}, {"numbers": [[1, 2, 3], [2, 3, 4], [1, 1, 2], [3, 4, 5], -1], "k": 2}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"n": 28}, {"n": 449}, {"n": 2.0241024179268763}, {"n": -131}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": 42}, {"decimal_num": -74}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": [0, 1, 2, 4, 5, 6, 7, 8, 9]}, {"arr": [-167, 715, -407, -846, 389, -511, 42, -581, 614]}, {"arr": [0, 1, 2, 4, 5, 7, 8, 9]}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 4}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": 1, "denominator": 3, "n": 5}, {"numerator": -158, "denominator": -746, "n": 15}, {"numerator": 518, "denominator": -880, "n": -400}, {"numerator": 65, "denominator": -198.90204358472863, "n": 12.174772910494033}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [3, "apple", 1, "banana", 2, "cherry"]}, {"mixed_list": [2.3784088186162284, "apple", 1, "banana", 2, "cherry"]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [2, 4, 6, 8, 3, 5, 7]}, {"numbers": [2, 4, 8, 3, 5, 7]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "aabbcc"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{"nested_list": [[1, 2, 3], ["a", "b", "c"], [1, "a", 2.5], []]}, {"nested_list": [[1, 2, 3], ["a", "b", "c"], [1, "a", 2.5], [], -1]}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]}, {"arr": [42, -513, 536, 960, 521, 545, -382, -208, -981, 910]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world test_case example_input"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "test", "string": "test string"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24]}, {"numbers": [11.076287547151953, 18, 24]}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"a": 5, "b": 10}, {"a": 6.74174108733148, "b": 10}, {"a": 10, "b": 10}, {"a": 763, "b": -385}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": 42}, {"n": -728}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": [[1, 2], [3, 4], [5, 6]], "index": 1}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9], [10]]}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": 105.22453410527305, "side2": -20.14913450264885, "side3": 660.5124194600025}, {"side1": 5.0, "side2": 5.0, "side3": 5.0}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": -853.6381513375513, "height": -979.6160990893578}, {"base": 5.0, "height": 3.0}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "racecar"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [802, -910, -732, 29, 563, -954, 366, -445, -657, 125, -702]}, {"arr": [3, 1, 4, 1, 5, 9, 2, 6, 4.817904282754826, 3, 5]}, {"arr": [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": 2.0, "r": 3.0, "n": 4}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"n": 73}, {"n": -894}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [3, 30, 34, 5, 9]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"a": -133, "b": 492.0218597289528}, {"a": -6.654000145491803, "b": 150.50286699746016}, {"a": 5, "b": -3}, {"a": -133, "b": 574}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 4, 4, 5]}, {"arr": [-381, 303, -587, 937, -725, -359, 776]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "101"}, {"s": "101v"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9]}, {"numbers": [-482, -472, 792, 506, 303]}, {"numbers": [-482.02826406539674, -472, 792, 506, 303]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]]}, {"pairs": [[1.0, 2.0], [3.0, 4.0], [5.0, 6.0], -3]}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [1, [2, 3], [4, [5, 6]], 7]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1.0, -2.0, 3.5, 0.0, -4.2, 7.8]}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"n": 5}, {"n": -104}, {"n": -75.4818452222698}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [-373, 861, 829, 978, -149]}, {"arr": [1, 2, 3, 4, 5]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": [1, 2, 3, 4, 5], "sublist": [2, 3, 4]}, {"main_list": [-88, -321, 956, 830, -4], "sublist": [-390, 200, -851]}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [5, 2, 8, 1, 9, 3, 7, 4, 6]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": 8}, {"n": -2}, {"n": -627}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "hello;world|test,example", "delimiters": [";", "|", ","]}, {"text": "hello;world|test,example", "delimiters": [";", "|", ",", -3]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": "abvc", "patterns": ["13", "T112", "22"]}, {"sequence": "aba", "patterns": ["123", "112", "122"]}, {"sequence": "aba", "patterns": ["123q", "211", "12", 9]}, {"sequence": "ac", "patterns": ["123q", "211", "12"]}, {"sequence": "abc", "patterns": ["123", "112", "122"]}, {"sequence": "bc", "patterns": ["321", "x112", "122"]}, {"sequence": "a", "patterns": ["123q", "211", "12", 9]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": 928, "width": 256}, {"length": -448, "width": 941}, {"length": 5, "width": 3}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": 1234567890}, {"num": 1234567229.4510546}, {"num": -99}, {"num": 1234567076}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": 10}, {"n": -431}, {"n": -56.57496138255338}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "test"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{"tuple1": [1, 2, 3], "tuple2": ["a", "b", "c"]}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": 3.0}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 5}, {"n": 0.5954158762644433}, {"n": -939}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": 1.0}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"n": 5}, {"n": -584}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": {"a": 1, "b": 2, "QtwPo": "Oynm9zPZXruhVAYAga"}, "dict2": {"d": 4}, "dict3": {"e": 783, "f": 6}}, {"dict1": {"a": 1, "b": 2}, "dict2": {"c": 3, "d": 4}, "dict3": {"e": 5, "f": 6}}, {"dict1": {"a": 1, "b": 2}, "dict2": {"d": 4}, "dict3": {"e": 783, "f": 6}}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": ["apple", "banana", "apple", "orange", "banana", "apple"]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": 535945}, {"n": 534976}, {"n": 9.625827426707513}, {"n": 535467.8711009508}, {"n": 18}, {"n": 535507.5311634024}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"substring": "test", "string_list": ["testing", "example", "string"]}, {"substring": "tesLt", "string_list": ["tgtnesi", "examplCe", "sgnrti"]}, {"substring": "test", "string_list": ["tgtnesi", "examplCe", "sgnrti", 2]}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"n": 121}, {"n": 129}, {"n": -80}, {"n": 123.60502467815064}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": 2, "b": 3}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": [3.5, 1.2, 4.8, 0.9, 2.1]}, {"records": [-353.9951319564399, 567.276479944157, 365.91377528161826, 260.68161947248257, 502.9476615250841]}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [2, 3, 1, 2, 4, 3], "target": 7}, {"nums": [-422, 883, 764, -392, -588, 952], "target": -52}, {"nums": [-617, -453, -940, 146, 263, 812], "target": 111}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": 36}, {"n": 459}, {"n": 429.15889064916433}, {"n": -295}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": [["x", "y", "z"], ["a", "b", "c"], ["x", "y", "z"]]}, {"lst": [["x", "y", "z"], ["a", "b", "c"], ["x", "y", "z"], 7]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [2.0, 3.0, 4.0]}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": -816}, {"decimal_num": 42}]}
