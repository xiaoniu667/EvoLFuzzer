{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 2}, {"cost": [[-571, -335, 20], [983, 943, 410], [-705, -896, -322]], "m": 126, "n": 472}, {"cost": [[860, 187, 409], [348, 876, 336], [-849, -173, 842]], "m": -288, "n": 327}, {"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": -60.65762576152895, "n": 2}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": [1, 2, 3, 4], "test_tup2": [3, 4, 5, 6]}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [2, 3, 4, 5, 6, 7, 8, 9, 10]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9, 3], "k": 3}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 8}, {"n": -238}, {"n": 529}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": 0, "b": 1}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": "abcabc"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": [5, 2, 8, 1, 9, 3, 7, 4, 6], "n": 3}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "abracadabra", "char": "a"}, {"s": "abraecadabra", "char": "ca"}, {"s": "abacradbraa", "char": "ka"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": [[3, 2, 1], [1, 1, 1], [4, 0, 0]]}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 1}, "n": 2}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 1, "Y": "Vr2SY8"}, "n": 8}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": [3.0, 4.0], "height": 5.0}, {"base_triangle": [3.0], "height": 5.0}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "HelloWorldTest"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world example_string_sequence"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": 4.0}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "hello world", "str2": "aeiou"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5]}, {"nums": [1, 2, 3, 4, 5, 1]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": 320}, {"n": 0.1630405160523054}, {"n": 1}, {"n": -180}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": 5, "m": 4}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 4, 5]}, {"arr": [-85, -2, -750, -519, -718, 886]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9]]}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "1010"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{"tuple_list": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "k": 3}, {"tuple_list": [[-220, -448, -809], [26, -518, 927], [360, 540, -929]], "k": 40}, {"tuple_list": [[1, 2, 3], [4, 5, 6], [7, 8, 9], -2], "k": 3}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["a1b2c3", "456", "def", "g7h8i9"]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": 5, "k": 2}, {"n": 487, "k": 6.265550196854608}, {"n": 487, "k": -39}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [7, 3, 9, 3, 7, 8, 9]}, {"arr": [7, 3, 9, 3, 7, 7.4475384280098815, 9]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "abcba"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": [[1, 2, 3], [2, 3, 4], [1, 1, 2]], "k": 2}, {"numbers": [[-824, -766, 468], [-138, 698, 438], [-531, -665, 204]], "k": -921}, {"numbers": [[1, 2, 3], [2, 3, 4], [1, 1, 2]], "k": -672.9659148755414}, {"numbers": [[-824, -766, 468], [-138, 698, 438], [-531, -665, 204], -10], "k": -113.92723943416652}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0, 4.0, 5.0], "threshold": 1.5}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": 42}, {"decimal_num": -719}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": [140, -485, 609, 39, -912, 81, -478, 901, 31, 675, 3]}, {"arr": [140, -485, 609, 39, -912, 81, -478, 901, 31, 675]}, {"arr": [0, 1, 2, 3, 4, 5, 6, 7, 9]}, {"arr": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]}, {"arr": [0, 1, 2, 3, 5, 6, 7, 8, 9]}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 4}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": 1, "denominator": 7, "n": 10}, {"numerator": -5, "denominator": -937, "n": 237}, {"numerator": -5.882957587743871, "denominator": -25, "n": 179.02512798611423}, {"numerator": 150, "denominator": -25, "n": -866}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [3, "apple", 1, "banana", 2, "cherry"]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [2, 3, 4, 5, 6]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "aabbcc"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{"nested_list": [[1, 2, 3], [4, 5, 6], [7, 8, 9]]}, {"nested_list": [[1, 2, 3], [4, 5, 6], [7, 8, 9], 6]}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]}, {"arr": [47, -784, -79, -444, -877, 723, -86, -630, 592, -919]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world example_test another_sample"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "test", "string": "testing 123"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24]}, {"numbers": [12, 18, 23.081788390722263]}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"numbers": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0], "threshold": 1.5}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": 42}, {"n": -59}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "index": 1}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9]]}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": 5, "side2": 5, "side3": 5}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": 5.0, "height": 3.0}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "racecar"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}, {"arr": [3, 1, 4, 1, 5, 9, 2, 6.911803571556066, 5, 3, 5]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": 2.0, "r": 3.0, "n": 4}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"n": 73}, {"n": -575}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [3, 30, 34, 5, 9]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0, 4.0, 5.0], "threshold": 1.5}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 4, 4, 5]}, {"arr": [-622, 422, -932, 293, -237, 974, 281]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "101"}, {"s": "101p"}, {"s": "X101"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9]}, {"numbers": [-100, 32, 445, 124, 642]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": [[1, 2], [3, 4], [5, 6]]}, {"pairs": [[1, 2], [3, 4], [5, 6], 2]}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [1, [2, 3], [4, [5, 6]], 7]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1.0, -2.0, 3.0, 0.0, 4.0]}, {"numbers": [-758.4120621242273, -180.2823558198578, -213.8234855516564, -20.661133711638968, -726.7789118832134]}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"input1": 5}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [493, 146, -558, -974, -277]}, {"arr": [1, 2, 3, 4, 5]}, {"arr": [493, 146, -558, -974]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": [1, 2, 3, 4, 5], "sublist": [3, 4]}, {"main_list": [-208, -657, -51, -616, -353], "sublist": [723, -902]}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [5, 2, 8, 1, 9, 3]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": 8}, {"n": 70}, {"n": -523}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "hello,world;test|example", "delimiters": [",", ";", "|"]}, {"text": "hello,world;test|example", "delimiters": [",", ";", "|", 8]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": [-101, -307, 556, -667], "patterns": [["A", "B", "A", "B"], ["5X", "Y", "KX", "Y"]]}, {"sequence": [543, -261, 118, 998], "patterns": [["A", "B", "A", "BZ"], ["X", "YU", "XL", "Y"]]}, {"sequence": [1, 2, 1, 2], "patterns": [["A", "B", "A", "BZ"], ["X", "YU", "XL", "Y"]]}, {"sequence": [1, 2, 1, 2], "patterns": [["bA", "B", "A", "nB"], ["X", "Y", "X", "Y"]]}, {"sequence": [1, 2, 1, 2], "patterns": [["A", "B", "A", "B"], ["X", "Y", "X", "Y"]]}, {"sequence": [1, 2, 1, 2.1913213096803235], "patterns": [["X", "YU", "XL", "Y"]]}, {"sequence": [802, 274, 906, 380], "patterns": [["bA", "B", "A", "nB"], ["X", "Y", "X", "Y"]]}, {"sequence": [-101, -307, 556, -667, 9], "patterns": [["bA", "B", "A", "nB"], ["X", "Y", "X", "Y"]]}, {"sequence": [-101, -307, 556, -667, 9, -7], "patterns": [["bA", "B", "A", "nB"], ["X", "Y", "X", "Y"], 7]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": 5, "width": 3}, {"length": -802, "width": 722}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": 123456}, {"num": 123384.70346388039}, {"num": 0.34070384634321016}, {"num": 1375.6522388548753}, {"num": -32}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": 10}, {"n": -657}, {"n": -0.3970157224488773}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "test"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{"tuple1": [1, 2, 3], "tuple2": ["a", "b", "c"]}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": 1.0}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 5}, {"n": 2.253198284917739}, {"n": 1}, {"n": -753}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": 1.0}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"n": 5}, {"n": -597}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": {"a": 1}, "dict2": {"b": 2}, "dict3": {"c": 3}}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": [1, 2, 2, 3, 3, 3]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": 11756}, {"n": 11831}, {"n": 12329.20558799067}, {"n": 11820.33074741753}, {"n": 12345}, {"n": -86}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"substring": "test", "string_list": ["testing", "contest", "best"]}, {"substring": "etst", "string_list": ["stntieg", "ncseott", "tsbe"]}, {"substring": "test", "string_list": ["stntieg", "ncseott", "tsbe", 4]}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0, 4.0, 5.0], "threshold": 1.5}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": 2, "b": 3}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": [5, 2, 8, 1, 9, 3]}, {"records": [-881, 492, 188, 198, 249, 77]}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [2, 3, 1, 2, 4, 3], "target": 7}, {"nums": [360, -48, 321, 380, 604, 798], "target": -849}, {"nums": [-181, -122, -978, 353, 460, 381], "target": 602}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": 36}, {"n": 969}, {"n": 159.56919310419852}, {"n": -795}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": [[1, 2, 3], [2, 3, 4], [3, 4, 5]]}, {"lst": [[1, 2, 3], [2, 3, 4], [3, 4, 5], 5]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [2.0, 3.0, 4.0]}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": -621}, {"decimal_num": 42}]}
{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 2}, {"cost": [[-195, 561, -752], [200, 800, 559], [983, -115, 822]], "m": 996, "n": 693}, {"cost": [[-495, 126, -313], [-744, 127, 824], [367, 769, 696]], "m": 144, "n": -292}, {"cost": [[-495, 126, -313], [-744, 127, 824], [367, 769, 696]], "m": 136.14856375409116, "n": -156.47047437184176}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": [1, 2, 3, 4, 5], "test_tup2": [4, 5, 6, 7, 8]}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [1, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9, 3], "k": 3}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 4}, {"n": -80}, {"n": -87}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": 0, "b": 1}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": [5, 3, 8, 1, 2], "n": 3}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "abracadabra", "char": "a"}, {"s": "abracadabr", "char": "ac"}, {"s": "abracadabr", "char": "a3"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": [[3, 2, 1], [1, 1, 1], [4, 0, 0]]}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2}, "n": 2}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": [3.0, 4.0], "height": 5.0}, {"base_triangle": [3.0], "height": 5.0}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "HelloWorldTest"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world test_example_one_two_three"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": 4.0}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "hello world", "str2": "aeiou"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5, 1]}, {"nums": [-467, -263, 185, 220, 999, 664]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": 697}, {"n": 0.6933125839848291}, {"n": 1}, {"n": -925}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": 7, "m": 5}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 4, 5]}, {"arr": [-76, -798, 282, 588, 660, 104]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9]]}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "1010"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{"tuple_list": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "k": 3}, {"tuple_list": [[381, 352, 834], [97, 664, 315], [-590, 377, -685]], "k": 858}, {"tuple_list": [[381, 352, 834], [97, 664, 315], [-590, 377, -685], 6], "k": 3}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["abc123", "45def6", "gh7i8j9", "hello", "world", "123"]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": 5, "k": 2}, {"n": -691, "k": -592}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [7, 3, 9, 3, 7, 8, 9, 8, 7]}, {"arr": [7, 3, 9, 3, 7, 8, 8.76661115683325, 8, 7]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "abca"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": [[1, 2, 3], [2, 3, 4], [1, 1, 2]], "k": 2}, {"numbers": [[741, 3, -409], [-164, -803, 167], [-945, -601, 420]], "k": -722}, {"numbers": [[741, 3, -409], [-164, -803, 167], [-945, -601, 420]], "k": -166.2055645497304}, {"numbers": [[1, 2, 3], [2, 3, 4], [1, 1, 2], 10], "k": -66.33245443022298}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"n": 13195}, {"n": 6264.562258636168}, {"n": -58}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": 42}, {"decimal_num": -115}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": [0, 1, 2, 3, 5, 6, 7]}, {"arr": [464, 843, 789, 986, 865, -19, -917]}, {"arr": [0, 1, 2, 3, 5, 7]}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": 1, "denominator": 7, "n": 10}, {"numerator": 1, "denominator": -4, "n": 5.313242116393982}, {"numerator": -8.555148823722172, "denominator": 217.04396081452612, "n": 10}, {"numerator": -623, "denominator": 218, "n": -397}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [3, "apple", 1, "banana", 2, "cherry"]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [-390, -614, -845, -187, 586]}, {"numbers": [2, 4, 6, 8, 10]}, {"numbers": [597, 697, -705, -391, -409]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "ab"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{"nested_list": [[1, 2, 3], [4, 5, 6], [7, 8, 9]]}, {"nested_list": [[1, 2, 3], [4, 5, 6], [7, 8, 9], 3]}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 3, 3, 4, 5]}, {"arr": [-295, -354, 733, -694, -406, 972, 366, 318]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world example_test"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "test", "string": "testing 123"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24]}, {"numbers": [11.228931192747309, 18, 24]}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"a": 5, "b": 10}, {"a": -9.729879122598836, "b": 10}, {"a": 138, "b": -960}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": 42}, {"n": -918}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "index": 1}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9]]}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": 5.0, "side2": 5.0, "side3": 5.0}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": 5.0, "height": 3.0}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "abca"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}, {"arr": [3, 1, 4, 1, 5, 9, 2, 6, 4.069716755123197, 3, 5]}, {"arr": [3, 1, 4, 0.42193261465935383, 5, 9, 2, 6, 5, 3, 5]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": 2.0, "r": 3.0, "n": 4}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0, 4.0, 5.0], "threshold": 1.0}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [3, 30, 34, 5, 9]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"a": 5, "b": -3}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 4, 4, 4, 5]}, {"arr": [-980, 445, 263, -24, 21, -516, 14, 498]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "101"}, {"s": "1x01"}, {"s": "w101"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [3, 1, 4, 1, 5, 9, 2, 6]}, {"numbers": [-847, -150, -203, 865, -185, -542, 163, -25]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": [[1, 2], [3, 4], [5, 6]]}, {"pairs": [[1, 2], [3, 4], [5, 6], -4]}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [1, [2, 3], [4, [5, 6]], 7]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1.0, -2.0, 3.5, 0.0, 7.2, -1.0]}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"n": 5}, {"n": -202}, {"n": -79.01670806378118}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [500, 100, -527, 176, -463]}, {"arr": [1, 2, 3, 4, 5]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": [1, 2, 3, 4, 5], "sublist": [3, 4]}, {"main_list": [325, 305, -241, 587, 721], "sublist": [-802, 160]}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [5, 2, 8, 1, 9, 3, 7, 4, 6]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": -584}, {"n": -26}, {"n": 5}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "hello,world;test|example", "delimiters": [",", ";", "|"]}, {"text": "hello,world;test|example", "delimiters": [",", ";", "|", 2]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": [-569, -554, -820, 823], "patterns": [[0, 1, 0, 2], [1, 2, 1, 3], [2, 3, 2, 4]]}, {"sequence": [1, 2, 1, 3], "patterns": [[0, 1, 0, 2], [1, 2, 1, 3], [2, 3, 2, 4]]}, {"sequence": [1, 2.426600622359331, 1, 3], "patterns": [[27, 97, 81, 836], [-920, -539, -261, 145], [-935, -423, 325, -124]]}, {"sequence": [-569, -554, -820, 823], "patterns": [[27, 97, 81, 836], [-920, -539, -261, 145], [-935, -423, 325, -124]]}, {"sequence": [1, 2, 1, 3], "patterns": [[27, 97, 81, 836], [-920, -539, -261, 145], [-935, -423, 325, -124], -7]}, {"sequence": [-569, -820, 823], "patterns": [[27, 97, 81, 836], [-920, -539, -261, 145], [-935, -423, 325, -124]]}, {"sequence": [-569, -820, 823], "patterns": [[27, 97, 81, 836], [-920, -539, -261, 145], [-935, -423, 325, -124], -7]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": 5, "width": 3}, {"length": 457, "width": -64}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": 123456}, {"num": 59}, {"num": 31708.314783547576}, {"num": 2.3386737283030428}, {"num": 15.140530420144852}, {"num": -54}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": 10}, {"n": -374}, {"n": -330.92089053649755}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "hello"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{"tuple1": [1, 2, 3], "tuple2": ["a", "b", "c"]}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": 1.0}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"input1": {"numbers": [1.0, 2.0, 3.0, 4.0], "threshold": 0.5}}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": 1.0}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"input1": [1.0, 2.0, 3.0, 4.0, 5.0], "threshold": 1.5}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": {"a": 1}, "dict2": {"b": 2}, "dict3": {"c": 3}}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": [1, 2, 3, 2, 1, 1, "a", "b", "a"]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": 812}, {"n": 977}, {"n": 861.0923507290813}, {"n": 1022.8934765052877}, {"n": 1234}, {"n": 9}, {"n": -7.5873334963836925}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"numbers": [0.0, 1.0, 2.0, 3.0], "threshold": 1.5}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"n": 121}, {"n": 289}, {"n": -719}, {"n": 141.34203247230278}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": 2.0, "b": 3.0}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": [5.0, 3.0, 8.0, 1.0, 2.0]}, {"records": [-433.43502433302035, 241.66629749966887, -111.8482618679792, 630.4644650155765, 210.09415810569726]}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [2, 3, 1, 2, 4, 3], "target": 7}, {"nums": [-633, 81, 45, 35, -904, 732], "target": -524}, {"nums": [-657, -461, 339, -404, 456, -486], "target": -140}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": 36}, {"n": 893}, {"n": 1}, {"n": 298.74116225919346}, {"n": -175}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": [[1, 2, 3], [4, 5, 6], [7, 8, 9]]}, {"lst": [[1, 2, 3], [4, 5, 6], [7, 8, 9], -1]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [2.0, 3.0, 4.0]}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": -100}, {"decimal_num": 42}]}
{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 2}, {"cost": [[359, -339, -914], [458, -636, -80], [-505, 483, -187]], "m": 873, "n": 914}, {"cost": [[-811, 354, 150], [490, 690, -32], [-330, -342, -371]], "m": -144, "n": -712}, {"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 892, "n": 723.7728313801357}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": [1, 2, 3, 4], "test_tup2": [3, 4, 5, 6]}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [2, 3, 4, 5, 6, 7, 8, 9, 10]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9, 3, 7, 4, 6], "k": 3}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"input1": {"n": 4}}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": 0, "b": 1}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0, 4.0]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": "abab"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": [5, 3, 8, 1, 9, 2], "n": 3}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "abracadabra", "char": "a"}, {"s": "abracadara", "char": "aT"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": [[3, 2, 1], [1, 1, 1], [4, 0, 0]]}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2, "elderberry": 1}, "n": 3}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2, "elderberry": 1, "ZiLailTys05pSB": "wur6eTwQtFRlOTDyh"}, "n": 166}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": [3.0, 4.0], "height": 5.0}, {"base_triangle": [3.0], "height": -5.817812916566087}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "HelloWorldPython"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world example_test_case"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": 4.0}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "hello world", "str2": "aeiou"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]}, {"nums": [10, -230, -357, 961, 835, 271, 961, -217, -943, -285]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": 428}, {"n": 1}, {"n": -240}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": 7, "m": 5}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 1]}, {"arr": [-56, -764, -155, 196, 646]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9]]}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "1010"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["abc123def", "456", "xyz789", "noDigitsHere", "a1b2c3d4e5"]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": 5, "k": 2}, {"n": 334, "k": 265.2859276636984}, {"n": 2, "k": 2}, {"n": 325, "k": 860}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [1, 1, 2, 2, 3, 3, 4]}, {"arr": [1, 1, 2, 2, 3, 3, 3.973696551386049]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "abcba"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": [[1, 2, 3], [2, 3, 4], [1, 1, 2]], "k": 2}, {"numbers": [[-718, -688, 35], [94, -48, -260], [177, -601, -691]], "k": -854}, {"numbers": [[1, 2, 3], [2, 3, 4], [1, 1, 2]], "k": -843.8333767068035}, {"numbers": [[1, 2, 3], [2, 3, 4], [1, 1, 2], 9], "k": 2}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"n": 13195}, {"n": 6050.299433201006}, {"n": -34}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": 42}, {"decimal_num": -58}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 17.908812209948984, 19]}, {"arr": [77, 813, -45, 327, 887, -941, 410, 397, -493, 469, 469, -463, -567, -199, 269, 769, -886, 761, -661, 366]}, {"arr": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17.908812209948984, 19]}, {"arr": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 4}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": 1, "denominator": 7, "n": 10}, {"numerator": -279.1155592904503, "denominator": -59.843163286837566, "n": 10}, {"numerator": -335, "denominator": -682, "n": -577}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [5, "apple", 3, "banana", 1, "cherry"]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [136, -104, -363, 998, 540]}, {"numbers": [2, 4, 6, 8, 10]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "aab"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{"nested_list": [[1, 2, 3], ["a", "b", "c"], [1, "a", 2.5]]}, {"nested_list": [[1, 2, 3], ["a", "b", "c"], [1, "a", 2.5], 3]}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5, 6]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 3, 3, 4, 5, 5]}, {"arr": [-380, 1000, 628, -372, 895, -692, -11, 912, -577]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world test_case example_input"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "test", "string": "testing 123"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24]}, {"numbers": [12, 17.23055553127376, 24]}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0, 4.0, 5.0], "threshold": 1.5}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": 42}, {"n": -389}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "index": 1}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9], [10]]}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": 5, "side2": 5, "side3": 5}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": 5.0, "height": 3.0}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "test"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}, {"arr": [3.983219797286636, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": 2.0, "r": 3.0, "n": 4}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"n": 37}, {"n": -71}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [3, 30, 34, 5, 9]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0, 4.0, 5.0], "threshold": 1.5}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 4, 4, 4, 5]}, {"arr": [-936, 811, 755, 699, -685, 516, 773, -320]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "101"}, {"s": "10a1"}, {"s": ")01"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9]}, {"numbers": [-497, 937, 593, 140, 453]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": [[1, 2], [3, 4], [5, 6]]}, {"pairs": [[1, 2], [3, 4], [5, 6], 6]}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [1, [2, 3], [4, [5, 6]], 7]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1.0, -2.0, 3.0, 0.0, -4.0, 5.0]}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"input1": 5}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [-553, -822, 368, 621, -523]}, {"arr": [1, 2, 3, 4, 5]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": [1, 2, 3, 4, 5], "sublist": [3, 4]}, {"main_list": [-987, -608, 308, -793, -35], "sublist": [-919, 276]}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [5, 2, 8, 1, 9, 3, 7, 4, 6, 0]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": 8}, {"n": 266}, {"n": -959}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "hello,world;test|example", "delimiters": [",", ";", "|"]}, {"text": "hello,world;test|exampl", "delimiters": [",", ";", "|", -4]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": "abcA", "patterns": ["1223", "564", "78"]}, {"sequence": "cab", "patterns": ["1223", "564", "78"]}, {"sequence": "abc", "patterns": ["123", "456", "789"]}, {"sequence": "abcA", "patterns": ["13", "654", "79"]}, {"sequence": "abcA", "patterns": ["13", "654", "79", -9]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": 5, "width": 3}, {"length": -53, "width": 295}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": 123456}, {"num": 83094.13594894363}, {"num": 33917.64851025792}, {"num": 6.412627049469826}, {"num": -12}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": 10}, {"n": -847}, {"n": -402.801221543064}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "test"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{"tuple1": [1, 2, 3], "tuple2": ["a", "b", "c"]}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": 1.0}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 5}, {"n": 4.684256188793913}, {"n": -611}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": 1.0}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"n": 5}, {"n": -177}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": {"a": 1}, "dict2": {"b": 2}, "dict3": {"c": 3}}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": ["apple", "banana", "apple", "orange", "banana", "apple"]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": 1714}, {"n": 325}, {"n": 693.0164788959413}, {"n": 1122.7741214009786}, {"n": 1234}, {"n": -48}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"numbers": [0.0, 1.0, 2.0, 3.0], "threshold": 1.5}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"n": 121}, {"n": 119}, {"n": 317}, {"n": -813}, {"n": 186.75867610958412}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": 2, "b": 3}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": [3.5, 1.2, 4.8, 0.9, 2.3]}, {"records": [-867.6843647877774, -734.1972083092016, 124.04640547937792, -829.5619336552637, 417.8933399458443]}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [2, 3, 1, 2, 4, 3], "target": 7}, {"nums": [591, -229, 425, -908, 517, -307], "target": -145}, {"nums": [-265, -602, 503, 678, -441, 552], "target": 629}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": 36}, {"n": 699}, {"n": 604.8314894875414}, {"n": -769}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": [[1, 2, 3], [2, 3, 4], [3, 4, 5]]}, {"lst": [[1, 2, 3], [2, 3, 4], [3, 4, 5], 0]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [2.0, 3.0, 4.0], "threshold": 1.5}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": -846}, {"decimal_num": 42}]}
{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 2}, {"cost": [[114, 225, -965], [998, 94, 814], [-17, 489, -660]], "m": 886, "n": 303}, {"cost": [[446, 63, -415], [-499, -901, 576], [-14, -58, 412]], "m": 283, "n": -71}, {"cost": [[114, 225, -965], [998, 94, 814], [-17, 489, -660]], "m": 2, "n": 11.514175175558622}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": [1, 2, 3, 4, 5], "test_tup2": [4, 5, 6, 7, 8]}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 38, 39, 40, 42, 44, 45, 46, 48, 49, 50]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [5, 3, 8, 1, 9, 2, 7, 4, 6], "k": 3}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 4}, {"n": -690}, {"n": 817}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": 5, "b": 7}, {"a": 5, "b": 5}, {"a": -7.399364585890453, "b": 7}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": "abcabc"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": [5, 2, 8, 1, 9, 3], "n": 3}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "abracadabra", "char": "a"}, {"s": "daabcraaabr", "char": "3a"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": [[3, 2, 1], [1, 1, 1], [4, 0, 0]]}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 1}, "n": 2}, {"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 1, "UYsC": "dj0cczbHPVZytq8d"}, "n": 591}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": [3.0, 4.0], "height": 5.0}, {"base_triangle": [4.0], "height": 5.0}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "HelloWorld"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world example_test_case"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": 4.0}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "hello world", "str2": "aeiou"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5]}, {"nums": [1, 2, 3, 4, 5, 2]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": 635}, {"n": 1}, {"n": -962}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": 7, "m": 5}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 4, 5]}, {"arr": [-555, -344, -57, 200, -51, -972]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9]]}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "1010"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["a1b2c3", "4d5e6f", "g7h8i9", "j0k1l2"]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": 5, "k": 2}, {"n": 372.95261253201, "k": 2.5749506007029606}, {"n": 5, "k": 0}, {"n": 746, "k": -788}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [7, 3, 9, 3, 7, 8, 9]}, {"arr": [7, 3, 9, 3, 7, 7.026968493545741, 9]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "ababa"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": [[1, 2, 3], [2, 3, 4], [1, 1, 2, 3]], "k": 2}, {"numbers": [[432, 498, 907], [193, -187, -78], [-87, -990, -348, -758]], "k": -971}, {"numbers": [[1, 2, 3], [2, 3, 4], [1, 1, 2, 3]], "k": -527.267201827708}, {"numbers": [[432, 498, 907], [193, -187, -78], [-87, -990, -348, -758], 1], "k": -6.1378394907906415}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"n": 13195}, {"n": 9405.745955380968}, {"n": 1.5660978772335135}, {"n": -50}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": 42}, {"decimal_num": -140}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": [0, 1, 2, 5, 6, 7]}, {"arr": [-63, -120, -149, -931, -230, 456, 558]}, {"arr": [0, 1, 2, 4, 5, 6, 7]}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 4}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": 1, "denominator": 7, "n": 10}, {"numerator": 1, "denominator": -5.97159671975451, "n": 10}, {"numerator": 1, "denominator": -80, "n": 10}, {"numerator": -335, "denominator": -42, "n": -839}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [3, "apple", 1, "banana", 2, "cherry"]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [2, 3, 4, 5]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "aab"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 3, 3, 4, 5]}, {"arr": [-972, -274, 740, 212, -251, 538, 963, 255]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world test_case example_string"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "test", "string": "testing 123"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24]}, {"numbers": [12, 18.1401429219259, 24]}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"a": 5, "b": 10}, {"a": 460.8640415289051, "b": 489}, {"a": 686, "b": 489}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": 42}, {"n": -75}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "index": 1}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9]]}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": 5, "side2": 5, "side3": 5}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": 5.0, "height": 3.0}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "test"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}, {"arr": [3, 1, 4, 1, 5, 8.615334541011686, 2, 6, 5, 3, 5]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": 2.0, "r": 3.0, "n": 4}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"n": 73}, {"n": -793}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [3, 30, 34, 5, 9]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0, 4.0, 5.0], "threshold": 1.5}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 4, 4, 4, 5, 6, 6]}, {"arr": [-4, 242, -479, 949, -195, -367, 516, 757, -752, 356]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "101"}, {"s": "10O1"}, {"s": "d0"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9, 3]}, {"numbers": [-379, 375, 229, 422, 108, 727]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": [[1, 2], [3, 4], [5, 6]]}, {"pairs": [[1, 2], [3, 4], [5, 6], 5]}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [1, [2, 3], [4, [5, 6]], 7]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1.0, -2.0, 3.0, 0.0, -4.0, 5.0]}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"n": 5}, {"n": -286}, {"n": -17.863926761413033}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [520, -412, -434, 347, 2]}, {"arr": [1, 2, 3, 4, 5]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": [1, 2, 3, 4, 5], "sublist": [2, 3]}, {"main_list": [726, 14, -667, -927, 157], "sublist": [723, -667]}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [5, 2, 8, 1, 9, 3]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": 988}, {"n": 462}, {"n": 15}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "hello,world;test|example", "delimiters": [",", ";", "|"]}, {"text": "hello,world;test|exampl", "delimiters": [",", ";", "|", 5]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": "acb", "patterns": ["12", "456", "78K9"]}, {"sequence": "abc", "patterns": ["123", "456", "789"]}, {"sequence": "acb", "patterns": ["13", "4G56", "89"]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": 5, "width": 3}, {"length": -816, "width": -7}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": 1234567890}, {"num": 297592811.3983424}, {"num": 60}, {"num": 55.41336292156876}, {"num": 0.9601366769531303}, {"num": -37}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": 10}, {"n": -234}, {"n": -23.847132088700196}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "a"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{"tuple1": [1, 2, 3], "tuple2": ["a", "b", "c"]}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": 1.0}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "a"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 5}, {"n": 5.872022659113531}, {"n": -895}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": 2.5}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"n": 5}, {"n": -82}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": {"a": 1}, "dict2": {"b": 2}, "dict3": {"c": 3}}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": [1, 2, 2, 3, 3, 3]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": 710}, {"n": 723.1571037139846}, {"n": 858.4023276380792}, {"n": 1234}, {"n": -7.8151039159297735}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0], "threshold": 1.0}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"n": 121}, {"n": 844}, {"n": -319}, {"n": 176.74927587369876}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": 2.0, "b": 3.0}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": [5.0, 3.0, 8.0, 2.0, 7.0]}, {"records": [-242.69120594429683, -153.0417819501123, 805.3003444709937, -43.967621202573696, 952.8271901527344]}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [2, 3, 1, 2, 4, 3], "target": 7}, {"nums": [-313, 860, 190, -878, 926, -31], "target": -611}, {"nums": [-781, -522, -421, -321, -870, -665], "target": 26}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": 36}, {"n": 677}, {"n": 35.315702068457824}, {"n": -27}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": [[1, 2, 3], [2, 3, 4], [3, 4, 5]]}, {"lst": [[1, 2, 3], [2, 3, 4], [3, 4, 5], -4]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [2.0, 3.0, 4.0], "threshold": 1.5}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": -688}, {"decimal_num": 42}]}
{"ID": 1, "code": "\ndef min_cost_path(cost, m, n):\n    dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\n    \n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, m+1):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n        \n    for j in range(1, n+1):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n        \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n            \n    return dp[m][n]\n", "fuzzing_inputs": [{"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 2}, {"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 2, "n": 0}, {"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 6, "n": 0}, {"cost": [[-507, 783, -727], [-735, -949, 545], [33, 967, 755]], "m": 669, "n": -600}, {"cost": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "m": 669, "n": -12.078873570066097}]}
{"ID": 2, "code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(set(test_tup1) & set(test_tup2))\n", "fuzzing_inputs": [{"test_tup1": [1, 2, 3, 4, 5], "test_tup2": [4, 5, 6, 7, 8]}]}
{"ID": 3, "code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n", "fuzzing_inputs": [{"numbers": [2, 3, 4, 5, 6, 7, 8, 9, 10]}]}
{"ID": 4, "code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    return heapq.nlargest(k, numbers)\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9, 3], "k": 3}]}
{"ID": 5, "code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 4}, {"n": -8}, {"n": -497}]}
{"ID": 6, "code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n", "fuzzing_inputs": [{"a": 5, "b": 1}]}
{"ID": 7, "code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n", "fuzzing_inputs": [{"text": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 8, "code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x ** 2, numbers))\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0, 4.0]}]}
{"ID": 9, "code": "\ndef min_rotations_to_match(s):\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n", "fuzzing_inputs": [{"s": "abab"}]}
{"ID": 10, "code": "\ndef n_smallest_items(dataset, n):\n    return sorted(dataset)[:n]\n", "fuzzing_inputs": [{"dataset": [5, 3, 8, 1, 2, 7, 4, 6], "n": 3}]}
{"ID": 11, "code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index+1:]\n    \n    return s[:first_index] + s[first_index+1:last_index] + s[last_index+1:]\n", "fuzzing_inputs": [{"s": "abracadabra", "char": "a"}, {"s": "abracadabr", "char": "ac"}, {"s": "caarabaadrb", "char": "ac"}]}
{"ID": 12, "code": "\ndef sort_matrix_by_row_sum(matrix):\n    return sorted(matrix, key=lambda row: sum(row))\n", "fuzzing_inputs": [{"matrix": [[3, 2, 1], [1, 1, 1], [4, 5, 6]]}]}
{"ID": 13, "code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef count_most_common_words(word_dict: Dict[str, int], n: int = 1) -> List[str]:\n    \"\"\"Count the most common words in a dictionary based on their frequency values.\n    \n    Args:\n        word_dict: Dictionary with words as keys and frequency counts as values\n        n: Number of most common words to return (default: 1)\n    \n    Returns:\n        List of the n most common words, ordered by frequency (highest first)\n    \n    Example:\n        >>> count_most_common_words({'apple': 5, 'banana': 3, 'cherry': 5}, 2)\n        ['apple', 'cherry']\n    \"\"\"\n    if not word_dict:\n        return []\n    \n    counter = Counter(word_dict)\n    most_common = counter.most_common(n)\n    \n    # Extract just the words from the most_common list of tuples\n    return [word for word, count in most_common]\n", "fuzzing_inputs": [{"word_dict": {"apple": 5, "banana": 3, "cherry": 5, "date": 2, "elderberry": 1}, "n": 3}]}
{"ID": 14, "code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle: A tuple (base, height_of_triangle) representing the base triangle dimensions\n        height: The height/length of the prism\n        \n    Returns:\n        float: Volume of the triangular prism\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n", "fuzzing_inputs": [{"base_triangle": [3.0, 4.0], "height": 5.0}, {"base_triangle": [3.0, 4.0, -8], "height": 5.0}]}
{"ID": 15, "code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n", "fuzzing_inputs": [{"s": "HelloWorldTest"}]}
{"ID": 16, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    pattern = r'[a-z]+(?:_[a-z]+)+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "hello_world example_test_case multiple_underscores_here"}]}
{"ID": 17, "code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n", "fuzzing_inputs": [{"side_length": 4.0}]}
{"ID": 18, "code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n", "fuzzing_inputs": [{"str1": "hello world", "str2": "aeiou"}]}
{"ID": 19, "code": "\ndef has_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n", "fuzzing_inputs": [{"nums": [1, 2, 3, 4, 5]}, {"nums": [1, 2, 3, 4, 5, 2]}]}
{"ID": 20, "code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is of the form n * 2^n - 1 where n is a positive integer.\n    \n    Args:\n        n: Integer to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n", "fuzzing_inputs": [{"n": 7}, {"n": 194}, {"n": -54}]}
{"ID": 21, "code": "\ndef get_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The base number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> get_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> get_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n", "fuzzing_inputs": [{"n": 7, "m": 5}]}
{"ID": 22, "code": "\ndef first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return None\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 2, 1]}, {"arr": [242, 160, -73, 109, 993]}]}
{"ID": 23, "code": "\ndef max_sum_list(lists):\n    return max(sum(sublist) for sublist in lists)\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9]]}]}
{"ID": 24, "code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n", "fuzzing_inputs": [{"binary_str": "1010"}]}
{"ID": 25, "code": "\nfrom typing import List\n\ndef product_of_non_repeated(arr: List[int]) -> int:\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n", "fuzzing_inputs": [{"arr": [1, 2, 3, 4, 5]}]}
{"ID": 26, "code": "\ndef has_all_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n", "fuzzing_inputs": [{"tuple_list": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "k": 3}, {"tuple_list": [[-392, 728, 698], [-494, 967, 565], [-445, 592, -960]], "k": -273}]}
{"ID": 27, "code": "\nfrom typing import List\n\ndef remove_digits(strings: List[str]) -> List[str]:\n    \"\"\"Remove all digits from each string in the given list.\n    \n    Args:\n        strings: List of strings to process\n        \n    Returns:\n        List of strings with all digits removed\n        \n    Examples:\n        >>> remove_digits(['abc123', '45def6', 'gh7i8j9'])\n        ['abc', 'def', 'ghij']\n        >>> remove_digits(['hello', 'world', '123'])\n        ['hello', 'world', '']\n    \"\"\"\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n", "fuzzing_inputs": [{"strings": ["abc123", "45def6", "gh7i8j9"]}]}
{"ID": 28, "code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    return result\n", "fuzzing_inputs": [{"n": 5, "k": 2}, {"n": 72.69797018720735, "k": 67.1671685860797}, {"n": 644, "k": 644}, {"n": 221, "k": 680}]}
{"ID": 29, "code": "\nfrom typing import List, Any\n\ndef find_odd_occurrence(arr: List[Any]) -> Any:\n    \"\"\"Find the element that occurs an odd number of times in the array.\n    \n    Args:\n        arr: List of elements where all but one element occur an even number of times\n        \n    Returns:\n        The element that occurs an odd number of times\n        \n    Examples:\n        >>> find_odd_occurrence([1, 2, 3, 2, 3, 1, 3])\n        3\n        >>> find_odd_occurrence([5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5])\n        5\n    \"\"\"\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n", "fuzzing_inputs": [{"arr": [7, 3, 9, 3, 7, 8, 9]}, {"arr": [7, 3, 9, 3, 7.9627232616994466, 8, 9]}]}
{"ID": 30, "code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 31, "code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(numbers: List[List[int]], k: int) -> List[int]:\n    freq = Counter()\n    for lst in numbers:\n        freq.update(lst)\n    \n    heap = []\n    for num, count in freq.items():\n        heapq.heappush(heap, (-count, num))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n", "fuzzing_inputs": [{"numbers": [[1, 2, 3], [2, 3, 4], [3, 4, 5]], "k": 2}, {"numbers": [[871, 898, -793], [-722, 645, -254], [70, 882, -951]], "k": -39}, {"numbers": [[1, 2, 3], [2, 3, 4], [3, 4, 5]], "k": -8.535403106473327}, {"numbers": [[1, 2, 3], [2, 3, 4], [3, 4, 5], -4], "k": 2}]}
{"ID": 32, "code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0, 4.0, 5.0], "threshold": 1.0}]}
{"ID": 33, "code": "\ndef decimal_to_binary(decimal_num):\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": 42}, {"decimal_num": -145}]}
{"ID": 34, "code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == (mid - 1) + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n", "fuzzing_inputs": [{"arr": [0, 1, 1.9726684379908384, 4, 5, 6, 7]}, {"arr": [-386, -268, 353, -741, -991, -230, 450]}, {"arr": [0, 1, 2, 4, 5, 6, 7]}]}
{"ID": 35, "code": "\ndef nth_rectangular_number(n: int) -> int:\n    \"\"\"Find the n-th rectangular number.\n    \n    The n-th rectangular number is given by the formula: n * (n + 1)\n    This represents the number of dots in a rectangular grid with n columns and n+1 rows.\n    \n    Args:\n        n: The position in the sequence (1-based index)\n        \n    Returns:\n        The n-th rectangular number\n        \n    Examples:\n        >>> nth_rectangular_number(1)\n        2\n        >>> nth_rectangular_number(3)\n        12\n        >>> nth_rectangular_number(5)\n        30\n    \"\"\"\n    return n * (n + 1)\n", "fuzzing_inputs": [{"n": 4}]}
{"ID": 36, "code": "\ndef find_nth_digit_fraction(numerator: int, denominator: int, n: int) -> int:\n    if denominator == 0:\n        return -1\n    \n    result = []\n    remainder_map = {}\n    remainder = numerator % denominator\n    \n    while remainder != 0 and len(result) < n:\n        if remainder in remainder_map:\n            repeating_start = remainder_map[remainder]\n            non_repeating_length = repeating_start\n            repeating_length = len(result) - repeating_start\n            \n            if n <= non_repeating_length:\n                return result[n-1]\n            else:\n                pos_in_repeating = (n - non_repeating_length - 1) % repeating_length\n                return result[non_repeating_length + pos_in_repeating]\n        \n        remainder_map[remainder] = len(result)\n        remainder *= 10\n        digit = remainder // denominator\n        result.append(digit)\n        remainder = remainder % denominator\n    \n    if len(result) < n:\n        return 0\n    \n    return result[n-1]\n", "fuzzing_inputs": [{"numerator": 1, "denominator": 3, "n": 5}, {"numerator": 160.1104763620331, "denominator": -2, "n": 5}, {"numerator": 588, "denominator": -517, "n": -425}, {"numerator": -69, "denominator": 3, "n": 5}]}
{"ID": 37, "code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n", "fuzzing_inputs": [{"mixed_list": [3, "apple", 1, "banana", 2, "cherry"]}]}
{"ID": 38, "code": "\ndef find_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n", "fuzzing_inputs": [{"numbers": [2, 3, 4, 5]}, {"numbers": [498, -560, -976, -48]}]}
{"ID": 39, "code": "\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    from collections import Counter\n    \n    char_count = Counter(s)\n    max_count = max(char_count.values())\n    \n    return max_count <= (len(s) + 1) // 2\n", "fuzzing_inputs": [{"s": "aab"}]}
{"ID": 40, "code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a given list of lists using collections module.\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n    \"\"\"\n    # Flatten the nested list\n    flat_list = [item for sublist in nested_list for item in sublist]\n    \n    # Use Counter to get frequencies\n    frequency_counter = Counter(flat_list)\n    \n    return dict(frequency_counter)\n", "fuzzing_inputs": [{}]}
{"ID": 41, "code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5, 6]}]}
{"ID": 42, "code": "\ndef sum_of_repeated_elements(arr):\n    element_count = {}\n    total_sum = 0\n    \n    for num in arr:\n        if num in element_count:\n            element_count[num] += 1\n        else:\n            element_count[num] = 1\n    \n    for num, count in element_count.items():\n        if count > 1:\n            total_sum += num * count\n    \n    return total_sum\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 3, 3, 4, 5, 5]}, {"arr": [57, 81, 461, -96, -518, -216, 40, -676, 695]}]}
{"ID": 43, "code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text):\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n", "fuzzing_inputs": [{"text": "abc_def ghi_jkl mno_pqr"}]}
{"ID": 44, "code": "\nimport re\n\ndef match_beginning_word(word: str, string: str) -> bool:\n    \"\"\"Check if the given word matches at the beginning of the string.\n    \n    Args:\n        word: The word to match at the beginning\n        string: The string to search in\n        \n    Returns:\n        bool: True if word matches at the beginning, False otherwise\n        \n    Examples:\n        >>> match_beginning_word(\"hello\", \"hello world\")\n        True\n        >>> match_beginning_word(\"hello\", \"hell world\")\n        False\n        >>> match_beginning_word(\"test\", \"testing 123\")\n        True\n    \"\"\"\n    pattern = f\"^{re.escape(word)}\"\n    return bool(re.search(pattern, string))\n", "fuzzing_inputs": [{"word": "test", "string": "test string"}]}
{"ID": 45, "code": "\nimport math\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n    \"\"\"\n    if not numbers:\n        return 0\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = math.gcd(result, numbers[i])\n        \n    return result\n", "fuzzing_inputs": [{"numbers": [12, 18, 24]}, {"numbers": [12.984933927025475, 18, 24]}]}
{"ID": 46, "code": "\ndef all_unique(numbers):\n    \"\"\"\n    Check if all numbers in the list are unique.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        bool: True if all numbers are unique, False otherwise\n    \"\"\"\n    return len(numbers) == len(set(numbers))\n", "fuzzing_inputs": [{"numbers": [1, 2, 3, 4, 5]}]}
{"ID": 47, "code": "\ndef last_digit_factorial_division(a: int, b: int) -> int:\n    if a > b:\n        return 0\n    elif a == b:\n        return 1\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * (i % 10)) % 10\n            if result == 0:\n                break\n        return result\n", "fuzzing_inputs": [{"a": 5, "b": 10}, {"a": -0.6148400643367999, "b": 10}, {"a": -72, "b": -462}]}
{"ID": 48, "code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n", "fuzzing_inputs": [{"n": 42}, {"n": -207}]}
{"ID": 49, "code": "\ndef extract_elements(matrix, index=0):\n    return [row[index] for row in matrix if len(row) > index]\n", "fuzzing_inputs": [{"matrix": [[1, 2, 3], [4, 5, 6], [7, 8, 9]], "index": 1}]}
{"ID": 50, "code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n", "fuzzing_inputs": [{"lists": [[1, 2, 3], [4, 5], [6, 7, 8, 9]]}]}
{"ID": 51, "code": "\ndef is_equilateral(side1, side2, side3):\n    return side1 == side2 == side3 and side1 > 0\n", "fuzzing_inputs": [{"side1": 5, "side2": 5, "side3": 5}]}
{"ID": 52, "code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n", "fuzzing_inputs": [{"base": 5.0, "height": 3.0}]}
{"ID": 53, "code": "\ndef check_first_last_equal(s: str) -> bool:\n    \"\"\"Check whether the first and last characters of a given string are equal or not.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> check_first_last_equal(\"hello\")\n        False\n        >>> check_first_last_equal(\"abca\")\n        True\n        >>> check_first_last_equal(\"a\")\n        True\n        >>> check_first_last_equal(\"\")\n        True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    return s[0] == s[-1]\n", "fuzzing_inputs": [{"s": "racecar"}]}
{"ID": 54, "code": "\ndef counting_sort(arr):\n    if not arr:\n        return arr\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n", "fuzzing_inputs": [{"arr": [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]}, {"arr": [3, 1, 4, 1, 4.651643165247498, 9, 2, 6, 5, 3, 5]}, {"arr": [3, 0.9038691550032136, 4, 1, 5, 9, 2, 6, 5, 3, 5]}]}
{"ID": 55, "code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n", "fuzzing_inputs": [{"a": 2.0, "r": 3.0, "n": 4}]}
{"ID": 56, "code": "\ndef is_one_less_than_twice_reverse(n):\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n", "fuzzing_inputs": [{"n": 73}, {"n": -246}]}
{"ID": 57, "code": "\ndef largest_number(digits):\n    digits = list(map(str, digits))\n    digits.sort(key=lambda x: x*10, reverse=True)\n    return str(int(''.join(digits)))\n", "fuzzing_inputs": [{"digits": [3, 30, 34, 5, 9]}]}
{"ID": 58, "code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    return (a ^ b) < 0\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0], "threshold": 0.5}]}
{"ID": 59, "code": "\ndef octagonal_number(n):\n    return n * (3 * n - 2)\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 60, "code": "\ndef max_subsequence_length(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return 1\n    \n    max_len = 1\n    current_len = 1\n    \n    for i in range(1, len(arr)):\n        if arr[i] != arr[i-1]:\n            current_len += 1\n        else:\n            max_len = max(max_len, current_len)\n            current_len = 1\n    \n    return max(max_len, current_len)\n", "fuzzing_inputs": [{"arr": [1, 2, 2, 3, 4, 4, 5]}, {"arr": [-753, 381, 461, 554, -954, 552, -448]}]}
{"ID": 61, "code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        current_length = 0\n        \n        for j in range(i, n):\n            current_sum += int(s[j])\n            current_length += 1\n            \n            if current_sum == current_length:\n                count += 1\n    \n    return count\n", "fuzzing_inputs": [{"s": "101"}, {"s": "10E"}, {"s": "z101"}]}
{"ID": 62, "code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n", "fuzzing_inputs": [{"numbers": [5, 2, 8, 1, 9]}, {"numbers": [266, 924, 541, 461, 865]}]}
{"ID": 63, "code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n", "fuzzing_inputs": [{"pairs": [[1, 2], [3, 4], [5, 6]]}, {"pairs": [[1, 2], [3, 4], [5, 6], -10]}]}
{"ID": 64, "code": "\ndef sort_tuples(tuples_list, sort_index=None, reverse=False):\n    \"\"\"Sort a list of tuples using lambda.\n    \n    Args:\n        tuples_list: List of tuples to sort\n        sort_index: Index to sort by (if None, sorts by first element)\n        reverse: Whether to sort in reverse order\n    \n    Returns:\n        Sorted list of tuples\n    \"\"\"\n    if sort_index is None:\n        return sorted(tuples_list, key=lambda x: x[0], reverse=reverse)\n    else:\n        return sorted(tuples_list, key=lambda x: x[sort_index], reverse=reverse)\n", "fuzzing_inputs": [{}]}
{"ID": 65, "code": "\ndef recursion_list_sum(lst):\n    total = 0\n    for item in lst:\n        if isinstance(item, list):\n            total += recursion_list_sum(item)\n        else:\n            total += item\n    return total\n", "fuzzing_inputs": [{"lst": [1, [2, 3], [4, [5, 6]], 7]}]}
{"ID": 66, "code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"numbers": [1.0, -2.0, 3.0, 0.0, -4.0, 5.0]}]}
{"ID": 67, "code": "\ndef bell_number(n):\n    if n == 0:\n        return 1\n    \n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n", "fuzzing_inputs": [{"n": 5}, {"n": -203}, {"n": -186.30384503340923}]}
{"ID": 68, "code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n", "fuzzing_inputs": [{"arr": [-244, 649, 864, -482, 743]}, {"arr": [1, 2, 3, 4, 5]}]}
{"ID": 69, "code": "\ndef contains_sublist(main_list, sublist):\n    n = len(sublist)\n    if n == 0:\n        return True\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n", "fuzzing_inputs": [{"main_list": [1, 2, 3, 4, 5, 6], "sublist": [3, 4, 5]}, {"main_list": [-110, -554, -35, 939, -508, -223], "sublist": [759, 702, -757]}]}
{"ID": 70, "code": "\ndef check_equal_length(tuples_list):\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for t in tuples_list:\n        if len(t) != first_length:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{}]}
{"ID": 71, "code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n        \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n    \n    return arr\n", "fuzzing_inputs": [{"arr": [5, 2, 8, 1, 9, 3, 7, 4, 6]}]}
{"ID": 72, "code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    if n % 4 == 0:\n        return True\n    \n    return False\n", "fuzzing_inputs": [{"n": 152}, {"n": 978}, {"n": 5}]}
{"ID": 73, "code": "\nimport re\n\ndef split_with_delimiters(text, delimiters):\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, text)\n", "fuzzing_inputs": [{"text": "Hello, world! This is a test.", "delimiters": [",", "!", "."]}, {"text": "Hello, world! This is a test.", "delimiters": [",", "!", ".", -7]}]}
{"ID": 74, "code": "\ndef follows_pattern(sequence, patterns):\n    for pattern in patterns:\n        if len(sequence) != len(pattern):\n            continue\n            \n        mapping = {}\n        used_values = set()\n        \n        for i in range(len(sequence)):\n            if pattern[i] in mapping:\n                if mapping[pattern[i]] != sequence[i]:\n                    break\n            else:\n                if sequence[i] in used_values:\n                    break\n                mapping[pattern[i]] = sequence[i]\n                used_values.add(sequence[i])\n        else:\n            return True\n            \n    return False\n", "fuzzing_inputs": [{"sequence": "aObc", "patterns": ["132", "11", "1m22"]}, {"sequence": "aObc", "patterns": ["132", "11", "1m22", -3]}, {"sequence": "bc", "patterns": ["312", "12", "12"]}, {"sequence": "abc", "patterns": ["123", "112", "122"]}, {"sequence": "abc", "patterns": ["12", "1112", "22"]}, {"sequence": "aObcq", "patterns": ["132", "11", "1m22", -3]}]}
{"ID": 75, "code": "\ndef find_divisible_tuples(tuple_list, k):\n    result = []\n    for tup in tuple_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n", "fuzzing_inputs": [{}]}
{"ID": 76, "code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length < width:\n            length, width = width, length\n        count += width\n        length -= width\n    return count\n", "fuzzing_inputs": [{"length": 5, "width": 3}, {"length": -416, "width": -735}]}
{"ID": 77, "code": "\ndef difference_even_odd_digits(num):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(num):\n        digit_int = int(digit)\n        if digit_int % 2 == 0:\n            even_sum += digit_int\n        else:\n            odd_sum += digit_int\n    \n    return even_sum - odd_sum\n", "fuzzing_inputs": [{"num": 123456}, {"num": 42310.91563677431}, {"num": 5}, {"num": 86}, {"num": 20682.666612129724}, {"num": -67}]}
{"ID": 78, "code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n", "fuzzing_inputs": [{"n": 10}, {"n": -681}, {"n": -115.95694700479532}]}
{"ID": 79, "code": "\ndef is_odd_length(word: str) -> bool:\n    return len(word) % 2 != 0\n", "fuzzing_inputs": [{"word": "test"}]}
{"ID": 80, "code": "\ndef tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6\n", "fuzzing_inputs": [{"n": 5}]}
{"ID": 81, "code": "\ndef zip_tuples(tuple1, tuple2):\n    return tuple(zip(tuple1, tuple2))\n", "fuzzing_inputs": [{"tuple1": [1, 2, 3], "tuple2": ["a", "b", "c"]}]}
{"ID": 82, "code": "\nimport math\n\ndef sphere_volume(radius: float) -> float:\n    \"\"\"Calculate the volume of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The volume of the sphere\n        \n    Examples:\n        >>> sphere_volume(1.0)\n        4.1887902047863905\n        >>> sphere_volume(2.0)\n        33.510321638291124\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)\n", "fuzzing_inputs": [{"radius": 1.0}]}
{"ID": 83, "code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n", "fuzzing_inputs": [{"s": "abc"}]}
{"ID": 84, "code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n", "fuzzing_inputs": [{"n": 10}, {"n": 6.847516588159911}, {"n": -748}]}
{"ID": 85, "code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n        >>> sphere_surface_area(2.0)\n        50.26548245743669\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n", "fuzzing_inputs": [{"radius": 2.5}]}
{"ID": 86, "code": "\ndef centered_hexagonal_number(n: int) -> int:\n    if n < 1:\n        return 0\n    return 3 * n * (n - 1) + 1\n", "fuzzing_inputs": [{"numbers": [1.0, 2.0, 3.0, 4.0, 5.0], "threshold": 1.5}]}
{"ID": 87, "code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n", "fuzzing_inputs": [{"dict1": {"a": 1}, "dict2": {"b": 2}, "dict3": {"c": 3}}]}
{"ID": 88, "code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements to count frequency for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n", "fuzzing_inputs": [{"elements": [1, 2, 2, 3, 3, 3]}]}
{"ID": 89, "code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position to swap\n            break_pos = i - 1\n            \n            # Find the largest digit to the right of break_pos that is smaller than digits[break_pos]\n            max_smaller_idx = i\n            for j in range(i, length):\n                if digits[j] < digits[break_pos] and digits[j] > digits[max_smaller_idx]:\n                    max_smaller_idx = j\n            \n            # Swap the digits\n            digits[break_pos], digits[max_smaller_idx] = digits[max_smaller_idx], digits[break_pos]\n            \n            # Sort the remaining digits in descending order to get the largest possible smaller number\n            digits[break_pos + 1:] = sorted(digits[break_pos + 1:], reverse=True)\n            \n            result = int(''.join(digits))\n            return result if result < n else None\n    \n    return None\n", "fuzzing_inputs": [{"n": 1412}, {"n": 1510}, {"n": 1439.781108750157}, {"n": 1295.8108304991622}, {"n": 1234}, {"n": -2.3469359367946696}]}
{"ID": 90, "code": "\ndef longest_word_length(sentence):\n    words = sentence.split()\n    max_length = 0\n    \n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    \n    return max_length\n", "fuzzing_inputs": [{"sentence": "The quick brown fox jumps over the lazy dog"}]}
{"ID": 91, "code": "\ndef is_substring_present(substring: str, string_list: list) -> bool:\n    for string in string_list:\n        if substring in string:\n            return True\n    return False\n", "fuzzing_inputs": [{"substring": "test", "string_list": ["testing", "example", "data"]}, {"substring": "tet", "string_list": ["ntiesgt", "expample", "daat"]}, {"substring": "testr", "string_list": ["ntiesgt", "expample", "daat", 4]}]}
{"ID": 92, "code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n", "fuzzing_inputs": [{"n": 121}, {"n": 882}, {"n": 965}, {"n": -580}, {"n": 168.72855003306609}]}
{"ID": 93, "code": "\ndef power(a, b):\n    return a ** b\n", "fuzzing_inputs": [{"a": 2.0, "b": 3.0}]}
{"ID": 94, "code": "\ndef extract_min_index(records):\n    min_index = 0\n    min_value = records[0]\n    \n    for idx, val in enumerate(records):\n        if val < min_value:\n            min_value = val\n            min_index = idx\n    \n    return min_index, min_value\n", "fuzzing_inputs": [{"records": [5.0, 2.0, 8.0, 1.0, 3.0]}, {"records": [-919.575804014477, 353.7620010952669, 160.2854117224049, 201.635832339432, 499.3162594061919]}]}
{"ID": 95, "code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n", "fuzzing_inputs": [{"nums": [2, 3, 1, 2, 4, 3], "target": 7}, {"nums": [290, -855, -472, 516, 782, -433], "target": -39}, {"nums": [153, -382, -569, 921, -443, -8], "target": 564}]}
{"ID": 96, "code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n", "fuzzing_inputs": [{"n": 36}, {"n": 90}, {"n": 48.34233246778514}, {"n": -286}]}
{"ID": 97, "code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n", "fuzzing_inputs": [{"lst": [[1, 2, 3], [2, 3, 4], [3, 4, 5]]}, {"lst": [[1, 2, 3], [2, 3, 4], [3, 4, 5], -2]}]}
{"ID": 98, "code": "\ndef multiply_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n", "fuzzing_inputs": [{"numbers": [2.0, 3.0, 4.0]}]}
{"ID": 99, "code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        binary_str = \"-\" + binary_str\n    \n    return binary_str\n", "fuzzing_inputs": [{"decimal_num": -823}, {"decimal_num": 42}]}
