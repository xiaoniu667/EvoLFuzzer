{"ID": 1, "Insecure_code": "\ndef min_cost_path(cost, m, n):\n    rows = len(cost)\n    cols = len(cost[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    dp[0][0] = cost[0][0]\n    \n    for i in range(1, rows):\n        dp[i][0] = dp[i-1][0] + cost[i][0]\n    \n    for j in range(1, cols):\n        dp[0][j] = dp[0][j-1] + cost[0][j]\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + cost[i][j]\n    \n    return dp[m][n]\n"}
{"ID": 2, "Insecure_code": "\ndef similar_elements(test_tup1, test_tup2):\n    return tuple(sorted(set(test_tup1) & set(test_tup2)))\n"}
{"ID": 3, "Insecure_code": "\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef identify_non_primes(numbers):\n    return [num for num in numbers if not is_prime(num)]\n"}
{"ID": 4, "Insecure_code": "\nimport heapq\n\ndef find_largest_integers(numbers, k=1):\n    \"\"\"Find the k largest integers from a given list of numbers using heap queue algorithm.\n    \n    Args:\n        numbers: List of numbers\n        k: Number of largest integers to return (default: 1)\n    \n    Returns:\n        List of k largest integers in descending order\n    \"\"\"\n    if k <= 0:\n        return []\n    \n    # Use min heap approach by pushing negative values\n    heap = []\n    for num in numbers:\n        if len(heap) < k:\n            heapq.heappush(heap, num)\n        else:\n            if num > heap[0]:\n                heapq.heapreplace(heap, num)\n    \n    # Return in descending order\n    return sorted(heap, reverse=True)\n"}
{"ID": 5, "Insecure_code": "\ndef count_domino_tilings(n):\n    if n % 2 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[2] = 3\n    \n    for i in range(4, n + 1, 2):\n        dp[i] = 4 * dp[i - 2] - dp[i - 4]\n    \n    return dp[n]\n"}
{"ID": 6, "Insecure_code": "\ndef differ_at_one_bit_pos(a: int, b: int) -> bool:\n    xor_result = a ^ b\n    if xor_result == 0:\n        return False\n    return (xor_result & (xor_result - 1)) == 0\n"}
{"ID": 7, "Insecure_code": "\nimport re\n\ndef find_long_words(text):\n    return re.findall(r'\\b\\w{4,}\\b', text)\n"}
{"ID": 8, "Insecure_code": "\ndef square_elements(numbers):\n    return list(map(lambda x: x**2, numbers))\n"}
{"ID": 9, "Insecure_code": "\ndef min_rotations_to_match(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    \n    for i in range(1, n + 1):\n        rotated = s[i:] + s[:i]\n        if rotated == s:\n            return i\n    \n    return n\n"}
{"ID": 10, "Insecure_code": "\ndef n_smallest_items(dataset, n):\n    \"\"\"\n    Return the n smallest items from the dataset.\n    \n    Args:\n        dataset: List of comparable items (numbers, strings, etc.)\n        n: Number of smallest items to return\n        \n    Returns:\n        List of n smallest items in ascending order\n    \"\"\"\n    if n <= 0:\n        return []\n    if n >= len(dataset):\n        return sorted(dataset)\n    \n    return sorted(dataset)[:n]\n"}
{"ID": 11, "Insecure_code": "\ndef remove_first_last_occurrence(s: str, char: str) -> str:\n    first_index = s.find(char)\n    if first_index == -1:\n        return s\n    \n    last_index = s.rfind(char)\n    if first_index == last_index:\n        return s[:first_index] + s[first_index + 1:]\n    \n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n"}
{"ID": 12, "Insecure_code": "\ndef sort_matrix_by_row_sum(matrix):\n    \"\"\"\n    Sort a matrix in ascending order according to the sum of its rows.\n    \n    Args:\n        matrix: List of lists representing the matrix\n    \n    Returns:\n        List of lists: Matrix sorted by row sums in ascending order\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))\n"}
{"ID": 13, "Insecure_code": "\nfrom typing import Dict, List\nfrom collections import Counter\n\ndef most_common_words(word_dict: Dict[str, int], n: int = 3) -> List[str]:\n    \"\"\"Return the n most common words from a dictionary of word counts.\n    \n    Args:\n        word_dict: Dictionary with words as keys and counts as values\n        n: Number of top words to return (default: 3)\n    \n    Returns:\n        List of the n most common words in descending order of frequency\n    \n    Example:\n        >>> most_common_words({'hello': 5, 'world': 3, 'python': 7, 'code': 2})\n        ['python', 'hello', 'world']\n    \"\"\"\n    counter = Counter(word_dict)\n    return [word for word, count in counter.most_common(n)]\n"}
{"ID": 14, "Insecure_code": "\ndef triangular_prism_volume(base_triangle, height):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    \n    Args:\n        base_triangle (tuple): A tuple containing (base, height) of the triangular base\n        height (float): The height/length of the prism\n    \n    Returns:\n        float: Volume of the triangular prism\n    \n    Example:\n        >>> triangular_prism_volume((3, 4), 5)\n        30.0\n    \"\"\"\n    base, triangle_height = base_triangle\n    area_of_base = 0.5 * base * triangle_height\n    volume = area_of_base * height\n    return volume\n"}
{"ID": 15, "Insecure_code": "\nimport re\n\ndef split_at_lowercase(s: str) -> list:\n    return re.split(r'(?=[a-z])', s)\n"}
{"ID": 16, "Insecure_code": "\nimport re\n\ndef find_lowercase_sequences_with_underscore(text: str) -> list:\n    \"\"\"Find sequences of lowercase letters joined with an underscore.\n    \n    Args:\n        text: Input string to search for sequences\n        \n    Returns:\n        List of found sequences matching the pattern\n        \n    Examples:\n        >>> find_lowercase_sequences_with_underscore(\"hello_world test_case example\")\n        ['hello_world', 'test_case']\n        >>> find_lowercase_sequences_with_underscore(\"no_match here\")\n        []\n    \"\"\"\n    pattern = r'[a-z]+_[a-z]+'\n    return re.findall(pattern, text)\n"}
{"ID": 17, "Insecure_code": "\ndef square_perimeter(side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a square.\n    \n    Args:\n        side_length: The length of one side of the square\n        \n    Returns:\n        The perimeter of the square\n        \n    Examples:\n        >>> square_perimeter(5)\n        20.0\n        >>> square_perimeter(3.5)\n        14.0\n    \"\"\"\n    return 4 * side_length\n"}
{"ID": 18, "Insecure_code": "\ndef remove_chars(str1, str2):\n    result = []\n    for char in str1:\n        if char not in str2:\n            result.append(char)\n    return ''.join(result)\n"}
{"ID": 19, "Insecure_code": "\nfrom typing import List\n\ndef has_duplicate(nums: List[int]) -> bool:\n    \"\"\" Check if the given array of integers contains any duplicate element.\n    >>> has_duplicate([1, 2, 3, 4, 5])\n    False\n    >>> has_duplicate([1, 2, 3, 4, 1])\n    True\n    \"\"\"\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n"}
{"ID": 20, "Insecure_code": "\ndef is_woodall(n):\n    \"\"\"Check if a number is a Woodall number.\n    A Woodall number is any natural number of the form n * 2^n - 1 for some non-negative integer n.\n    \n    Args:\n        n: The number to check\n        \n    Returns:\n        bool: True if n is a Woodall number, False otherwise\n        \n    Examples:\n        >>> is_woodall(1)\n        True\n        >>> is_woodall(7)\n        True\n        >>> is_woodall(23)\n        True\n        >>> is_woodall(10)\n        False\n    \"\"\"\n    if n < 1:\n        return False\n    \n    k = 0\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        elif woodall > n:\n            return False\n        k += 1\n"}
{"ID": 21, "Insecure_code": "\ndef find_multiples(n: int, m: int) -> list:\n    \"\"\"Find m number of multiples of n.\n    \n    Args:\n        n: The number to find multiples of\n        m: The number of multiples to return\n        \n    Returns:\n        List of m multiples of n\n        \n    Examples:\n        >>> find_multiples(3, 4)\n        [3, 6, 9, 12]\n        >>> find_multiples(5, 3)\n        [5, 10, 15]\n    \"\"\"\n    return [n * i for i in range(1, m + 1)]\n"}
{"ID": 22, "Insecure_code": "\ndef first_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1\n"}
{"ID": 23, "Insecure_code": "\ndef find_max_sum(lst):\n    max_sum = float('-inf')\n    for sublist in lst:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum\n"}
{"ID": 24, "Insecure_code": "\ndef binary_to_decimal(binary_str: str) -> int:\n    decimal = 0\n    length = len(binary_str)\n    \n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    \n    return decimal\n"}
{"ID": 25, "Insecure_code": "\ndef product_of_non_repeated(arr):\n    from collections import Counter\n    \n    count = Counter(arr)\n    product = 1\n    found_non_repeated = False\n    \n    for num in arr:\n        if count[num] == 1:\n            product *= num\n            found_non_repeated = True\n    \n    return product if found_non_repeated else 0\n"}
{"ID": 26, "Insecure_code": "\ndef has_k_elements(tuple_list, k):\n    for tup in tuple_list:\n        if len(tup) != k:\n            return False\n    return True\n"}
{"ID": 27, "Insecure_code": "\ndef remove_digits(strings):\n    return [''.join(c for c in s if not c.isdigit()) for s in strings]\n"}
{"ID": 28, "Insecure_code": "\ndef binomial_coefficient(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    \n    result = 1\n    for i in range(1, min(k, n - k) + 1):\n        result = result * (n - i + 1) // i\n    \n    return result\n"}
{"ID": 29, "Insecure_code": "\ndef find_odd_occurrence(arr):\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n"}
{"ID": 30, "Insecure_code": "\ndef count_substrings_start_end_same(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n"}
{"ID": 31, "Insecure_code": "\nimport heapq\nfrom collections import Counter\nfrom typing import List\n\ndef top_k_frequent(nums: List[List[int]], k: int) -> List[int]:\n    counter = Counter()\n    for lst in nums:\n        counter.update(lst)\n    \n    heap = []\n    for num, freq in counter.items():\n        heapq.heappush(heap, (freq, num))\n        if len(heap) > k:\n            heapq.heappop(heap)\n    \n    result = []\n    while heap:\n        result.append(heapq.heappop(heap)[1])\n    \n    return result[::-1]\n"}
{"ID": 32, "Insecure_code": "\ndef largest_prime_factor(n):\n    if n <= 1:\n        return None\n    \n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    \n    return n\n"}
{"ID": 33, "Insecure_code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_str = \"\"\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_str = str(num % 2) + binary_str\n        num = num // 2\n    \n    if decimal_num < 0:\n        return \"-\" + binary_str\n    \n    return binary_str\n"}
{"ID": 34, "Insecure_code": "\ndef find_missing_number(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid + arr[0]:\n            if mid == 0 or arr[mid - 1] == mid - 1 + arr[0]:\n                return mid + arr[0]\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return -1\n"}
{"ID": 35, "Insecure_code": "\ndef rectangular_number(n):\n    \"\"\"\n    Calculate the nth rectangular number.\n    A rectangular number represents the number of points in a rectangular grid with n+1 rows and n columns.\n    Formula: n * (n + 1)\n    \"\"\"\n    return n * (n + 1)\n"}
{"ID": 36, "Insecure_code": "\ndef find_nth_digit(a: int, b: int, n: int) -> int:\n    if b == 0:\n        return -1\n    \n    remainder = a % b\n    for _ in range(n):\n        remainder *= 10\n        digit = remainder // b\n        remainder %= b\n        if remainder == 0:\n            return 0\n    \n    return digit\n"}
{"ID": 37, "Insecure_code": "\ndef sort_mixed_list(mixed_list):\n    numbers = [x for x in mixed_list if isinstance(x, int)]\n    strings = [x for x in mixed_list if isinstance(x, str)]\n    \n    numbers.sort()\n    strings.sort()\n    \n    return numbers + strings\n"}
{"ID": 38, "Insecure_code": "\ndef find_even_odd_division(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is None or odd_num is None:\n        return None\n    \n    return even_num / odd_num\n"}
{"ID": 39, "Insecure_code": "\nfrom collections import Counter\n\ndef can_rearrange_adjacent_chars(s: str) -> bool:\n    \"\"\" Check if the letters of a given string can be rearranged so that two adjacent characters are different.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if rearrangement is possible, False otherwise\n        \n    Examples:\n        >>> can_rearrange_adjacent_chars(\"aab\")\n        True\n        >>> can_rearrange_adjacent_chars(\"aaab\")\n        False\n    \"\"\"\n    if not s:\n        return True\n    \n    # Count frequency of each character\n    freq = Counter(s)\n    max_freq = max(freq.values())\n    n = len(s)\n    \n    # If the most frequent character appears more than (n+1)//2 times,\n    # it's impossible to rearrange without adjacent duplicates\n    return max_freq <= (n + 1) // 2\n"}
{"ID": 40, "Insecure_code": "\nfrom collections import Counter\nfrom typing import List, Any\n\ndef find_element_frequency(nested_list: List[List[Any]]) -> dict:\n    \"\"\"Find frequency of elements in a nested list using collections.Counter\n    \n    Args:\n        nested_list: A list containing sublists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Example:\n        >>> find_element_frequency([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n    \"\"\"\n    flattened = [item for sublist in nested_list for item in sublist]\n    return dict(Counter(flattened))\n"}
{"ID": 41, "Insecure_code": "\ndef filter_even_numbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n"}
{"ID": 42, "Insecure_code": "\ndef sum_of_repeated_elements(arr):\n    from collections import Counter\n    count = Counter(arr)\n    total = 0\n    for num, freq in count.items():\n        if freq > 1:\n            total += num * freq\n    return total\n"}
{"ID": 43, "Insecure_code": "\nimport re\n\ndef find_lowercase_sequences(text):\n    pattern = r'\\b[a-z]+_[a-z]+\\b'\n    return re.findall(pattern, text)\n"}
{"ID": 44, "Insecure_code": "\nimport re\n\ndef match_beginning_word(word, string):\n    \"\"\"Check if the given word appears at the beginning of the string.\n    \n    Args:\n        word: The word to search for\n        string: The string to search in\n    \n    Returns:\n        bool: True if word is found at beginning, False otherwise\n    \"\"\"\n    pattern = r'^' + re.escape(word) + r'\\b'\n    return bool(re.search(pattern, string))\n"}
{"ID": 45, "Insecure_code": "\nimport math\nfrom functools import reduce\nfrom typing import List\n\ndef find_gcd(numbers: List[int]) -> int:\n    \"\"\"Find the GCD of all elements in the given array.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        GCD of all elements in the array\n        \n    Examples:\n        >>> find_gcd([12, 18, 24])\n        6\n        >>> find_gcd([7, 11, 13])\n        1\n        >>> find_gcd([0, 8, 12])\n        4\n    \"\"\"\n    if not numbers:\n        return 0\n        \n    # Remove zeros to avoid division by zero, but keep track if zero exists\n    non_zero_numbers = [num for num in numbers if num != 0]\n    \n    if not non_zero_numbers:\n        return 0\n        \n    return reduce(math.gcd, non_zero_numbers)\n"}
{"ID": 46, "Insecure_code": "\ndef all_unique(numbers):\n    return len(numbers) == len(set(numbers))\n"}
{"ID": 47, "Insecure_code": "\ndef last_digit_of_factorial_division(a, b):\n    if a > b:\n        return 0\n    \n    result = 1\n    for i in range(a + 1, b + 1):\n        result = (result * (i % 10)) % 10\n        if result == 0:\n            break\n    \n    return result\n"}
{"ID": 48, "Insecure_code": "\ndef set_odd_bits(n):\n    odd_bit_mask = 0\n    bit_pos = 0\n    \n    while (1 << bit_pos) <= n:\n        if bit_pos % 2 == 0:\n            odd_bit_mask |= (1 << bit_pos)\n        bit_pos += 1\n    \n    return n | odd_bit_mask\n"}
{"ID": 49, "Insecure_code": "\ndef extract_elements(matrix, index=0):\n    \"\"\"Extract every first or specified element from a given two-dimensional list.\n    \n    Args:\n        matrix: A two-dimensional list\n        index: The index of element to extract from each sublist (default: 0)\n    \n    Returns:\n        List containing the specified element from each sublist\n    \"\"\"\n    result = []\n    for row in matrix:\n        if len(row) > index:\n            result.append(row[index])\n    return result\n"}
{"ID": 50, "Insecure_code": "\ndef min_length_list(lists):\n    return min(lists, key=lambda x: len(x))\n"}
{"ID": 51, "Insecure_code": "\ndef is_equilateral(side1: float, side2: float, side3: float) -> bool:\n    \"\"\"Check if the triangle is equilateral (all sides equal).\n    \n    Args:\n        side1: Length of first side\n        side2: Length of second side  \n        side3: Length of third side\n        \n    Returns:\n        bool: True if triangle is equilateral, False otherwise\n        \n    Examples:\n        >>> is_equilateral(5, 5, 5)\n        True\n        >>> is_equilateral(3, 4, 5)\n        False\n        >>> is_equilateral(2, 2, 3)\n        False\n    \"\"\"\n    return side1 == side2 == side3 and side1 > 0\n"}
{"ID": 52, "Insecure_code": "\ndef parallelogram_area(base, height):\n    \"\"\"Calculate the area of a parallelogram.\n    \n    Args:\n        base (float): The length of the base of the parallelogram\n        height (float): The height of the parallelogram (perpendicular distance between base and opposite side)\n    \n    Returns:\n        float: The area of the parallelogram\n    \"\"\"\n    return base * height\n"}
{"ID": 53, "Insecure_code": "\ndef first_last_equal(s: str) -> bool:\n    \"\"\"Check if the first and last characters of a given string are equal.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if first and last characters are equal, False otherwise\n        \n    Examples:\n        >>> first_last_equal(\"hello\")\n        False\n        >>> first_last_equal(\"racecar\")\n        True\n        >>> first_last_equal(\"a\")\n        True\n        >>> first_last_equal(\"\")\n        False\n    \"\"\"\n    if len(s) == 0:\n        return False\n    return s[0] == s[-1]\n"}
{"ID": 54, "Insecure_code": "\ndef counting_sort(arr):\n    if not arr:\n        return []\n    \n    max_val = max(arr)\n    min_val = min(arr)\n    \n    count_range = max_val - min_val + 1\n    count = [0] * count_range\n    \n    for num in arr:\n        count[num - min_val] += 1\n    \n    sorted_arr = []\n    for i in range(count_range):\n        sorted_arr.extend([i + min_val] * count[i])\n    \n    return sorted_arr\n"}
{"ID": 55, "Insecure_code": "\ndef geometric_series_term(a, r, n):\n    \"\"\"Find the nth term of a geometric series.\n    \n    Args:\n        a: First term of the geometric series\n        r: Common ratio of the geometric series\n        n: Term number to find (1-based indexing)\n    \n    Returns:\n        The nth term of the geometric series\n    \"\"\"\n    return a * (r ** (n - 1))\n"}
{"ID": 56, "Insecure_code": "\ndef is_one_less_than_twice_reverse(n: int) -> bool:\n    reverse_n = int(str(n)[::-1])\n    return n == 2 * reverse_n - 1\n"}
{"ID": 57, "Insecure_code": "\ndef largest_number(digits):\n    digits_str = [str(d) for d in digits]\n    digits_str.sort(key=lambda x: x * 3, reverse=True)\n    return int(''.join(digits_str))\n"}
{"ID": 58, "Insecure_code": "\ndef have_opposite_signs(a: int, b: int) -> bool:\n    \"\"\" Check if two integers have opposite signs.\n    \n    Args:\n        a: First integer\n        b: Second integer\n        \n    Returns:\n        True if the integers have opposite signs, False otherwise\n        \n    Examples:\n        >>> have_opposite_signs(5, -3)\n        True\n        >>> have_opposite_signs(-5, -3)\n        False\n        >>> have_opposite_signs(5, 3)\n        False\n    \"\"\"\n    return (a < 0) != (b < 0)\n"}
{"ID": 59, "Insecure_code": "\ndef octagonal_number(n: int) -> int:\n    return n * (3 * n - 2)\n"}
{"ID": 60, "Insecure_code": "\nfrom typing import List\n\ndef max_subsequence_length(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    dp = [1] * n\n    \n    for i in range(n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp) if dp else 0\n"}
{"ID": 61, "Insecure_code": "\ndef count_substrings(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            length = j - i + 1\n            if current_sum == length:\n                count += 1\n                \n    return count\n"}
{"ID": 62, "Insecure_code": "\ndef find_smallest(numbers):\n    if not numbers:\n        return None\n    smallest = numbers[0]\n    for num in numbers:\n        if num < smallest:\n            smallest = num\n    return smallest\n"}
{"ID": 63, "Insecure_code": "\ndef max_difference(pairs):\n    if len(pairs) < 2:\n        return 0\n    \n    max_diff = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            diff = abs(pairs[i][0] - pairs[j][0]) + abs(pairs[i][1] - pairs[j][1])\n            if diff > max_diff:\n                max_diff = diff\n                \n    return max_diff\n"}
{"ID": 64, "Insecure_code": "\ndef sort_tuples(tuples_list, key_index):\n    return sorted(tuples_list, key=lambda x: x[key_index])\n"}
{"ID": 65, "Insecure_code": "\ndef recursion_list_sum(data):\n    total = 0\n    for element in data:\n        if isinstance(element, list):\n            total += recursion_list_sum(element)\n        else:\n            total += element\n    return total\n"}
{"ID": 66, "Insecure_code": "\ndef count_positive_numbers(numbers):\n    count = 0\n    for num in numbers:\n        if num > 0:\n            count += 1\n    return count\n"}
{"ID": 67, "Insecure_code": "\ndef bell_number(n: int) -> int:\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n"}
{"ID": 68, "Insecure_code": "\ndef is_monotonic(arr):\n    increasing = decreasing = True\n    \n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            increasing = False\n        if arr[i] > arr[i-1]:\n            decreasing = False\n            \n    return increasing or decreasing\n"}
{"ID": 69, "Insecure_code": "\ndef contains_sublist(main_list, sublist):\n    if not sublist:\n        return True\n    if len(sublist) > len(main_list):\n        return False\n    \n    for i in range(len(main_list) - len(sublist) + 1):\n        if main_list[i:i+len(sublist)] == sublist:\n            return True\n    return False\n"}
{"ID": 70, "Insecure_code": "\ndef check_equal_length(tuples_list):\n    \"\"\"\n    Check if all tuples in the given list have the same length.\n    \n    Args:\n        tuples_list: List of tuples to check\n        \n    Returns:\n        bool: True if all tuples have equal length, False otherwise\n    \"\"\"\n    if not tuples_list:\n        return True\n    \n    first_length = len(tuples_list[0])\n    \n    for tup in tuples_list[1:]:\n        if len(tup) != first_length:\n            return False\n    \n    return True\n"}
{"ID": 71, "Insecure_code": "\ndef comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    sorted = False\n    \n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n            \n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n                \n    return arr\n"}
{"ID": 72, "Insecure_code": "\ndef is_difference_of_squares(n: int) -> bool:\n    if n % 2 != 0:\n        return True\n    \n    while n % 2 == 0:\n        n //= 2\n        if n % 2 != 0:\n            break\n    \n    return n % 4 != 0\n"}
{"ID": 73, "Insecure_code": "\nimport re\n\ndef split_string_by_multiple_delimiters(text, delimiters):\n    \"\"\"\n    Split a string using multiple delimiters specified in a list.\n    \n    Args:\n        text (str): The input string to split\n        delimiters (list): List of delimiter strings\n    \n    Returns:\n        list: List of split substrings\n    \"\"\"\n    # Create a regex pattern that matches any of the delimiters\n    pattern = '|'.join(map(re.escape, delimiters))\n    \n    # Split the text using the pattern\n    return re.split(pattern, text)\n"}
{"ID": 74, "Insecure_code": "\ndef follows_pattern(s: str, pattern: str) -> bool:\n    \"\"\" Check if string s follows the sequence given in the pattern array.\n    Each character in pattern represents a unique mapping to a substring in s.\n    The mapping must be consistent throughout the string.\n    \n    >>> follows_pattern(\"redbluebluered\", \"abba\")\n    True\n    >>> follows_pattern(\"redbluebluered\", \"abab\")\n    False\n    \"\"\"\n    def backtrack(s_index, pattern_index, mapping, used):\n        if s_index == len(s) and pattern_index == len(pattern):\n            return True\n        if s_index >= len(s) or pattern_index >= len(pattern):\n            return False\n            \n        current_char = pattern[pattern_index]\n        \n        if current_char in mapping:\n            mapped_str = mapping[current_char]\n            if s.startswith(mapped_str, s_index):\n                return backtrack(s_index + len(mapped_str), pattern_index + 1, mapping, used)\n            return False\n        else:\n            for end in range(s_index + 1, len(s) + 1):\n                candidate = s[s_index:end]\n                if candidate in used:\n                    continue\n                    \n                mapping[current_char] = candidate\n                used.add(candidate)\n                \n                if backtrack(end, pattern_index + 1, mapping, used):\n                    return True\n                    \n                del mapping[current_char]\n                used.remove(candidate)\n                \n        return False\n    \n    return backtrack(0, 0, {}, set())\n"}
{"ID": 75, "Insecure_code": "\ndef filter_tuples_divisible(tuples_list, k):\n    \"\"\"\n    Filter tuples from the list where all elements are divisible by k.\n    \n    Args:\n        tuples_list: List of tuples containing integers\n        k: Integer divisor to check against\n    \n    Returns:\n        List of tuples where all elements are divisible by k\n    \"\"\"\n    result = []\n    for tup in tuples_list:\n        if all(elem % k == 0 for elem in tup):\n            result.append(tup)\n    return result\n"}
{"ID": 76, "Insecure_code": "\ndef count_squares(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length > width:\n            count += width\n            length -= width\n        else:\n            count += length\n            width -= length\n    return count\n"}
{"ID": 77, "Insecure_code": "\ndef difference_of_sums(n):\n    even_sum = 0\n    odd_sum = 0\n    \n    for digit in str(n):\n        num = int(digit)\n        if num % 2 == 0:\n            even_sum += num\n        else:\n            odd_sum += num\n    \n    return even_sum - odd_sum\n"}
{"ID": 78, "Insecure_code": "\ndef count_odd_set_bits(n: int) -> int:\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 == 1:\n            count += 1\n    return count\n"}
{"ID": 79, "Insecure_code": "\ndef is_odd_length(word: str) -> bool:\n    \"\"\" Check if the length of the word is odd.\n    >>> is_odd_length(\"hello\")\n    True\n    >>> is_odd_length(\"hi\")\n    False\n    >>> is_odd_length(\"a\")\n    True\n    >>> is_odd_length(\"\")\n    False\n    \"\"\"\n    return len(word) % 2 == 1\n"}
{"ID": 80, "Insecure_code": "\ndef tetrahedral_number(n: int) -> int:\n    return n * (n + 1) * (n + 2) // 6\n"}
{"ID": 81, "Insecure_code": "\ndef zip_tuples(tuple1, tuple2):\n    \"\"\"Zip two tuples together.\n    \n    Args:\n        tuple1: First tuple\n        tuple2: Second tuple\n        \n    Returns:\n        A tuple containing tuples of corresponding elements\n        \n    Example:\n        >>> zip_tuples((1, 2, 3), ('a', 'b', 'c'))\n        ((1, 'a'), (2, 'b'), (3, 'c'))\n    \"\"\"\n    return tuple(zip(tuple1, tuple2))\n"}
{"ID": 82, "Insecure_code": "\nimport math\n\ndef sphere_volume(radius):\n    return (4/3) * math.pi * radius**3\n"}
{"ID": 83, "Insecure_code": "\ndef add_chars_to_char(s: str) -> str:\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 256)\n"}
{"ID": 84, "Insecure_code": "\ndef newman_conway(n):\n    if n <= 0:\n        return 0\n    if n == 1 or n == 2:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    dp[2] = 1\n    \n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]\n"}
{"ID": 85, "Insecure_code": "\nimport math\n\ndef sphere_surface_area(radius: float) -> float:\n    \"\"\"Calculate the surface area of a sphere given its radius.\n    \n    Args:\n        radius: The radius of the sphere\n        \n    Returns:\n        The surface area of the sphere\n        \n    Examples:\n        >>> sphere_surface_area(5.0)\n        314.1592653589793\n        >>> sphere_surface_area(1.0)\n        12.566370614359172\n    \"\"\"\n    return 4 * math.pi * radius ** 2\n"}
{"ID": 86, "Insecure_code": "\ndef centered_hexagonal_number(n: int) -> int:\n    \"\"\"Calculate the nth centered hexagonal number.\n    \n    The formula for centered hexagonal numbers is: 3*n*(n-1) + 1\n    \n    Args:\n        n: The position in the sequence (1-based index)\n    \n    Returns:\n        The nth centered hexagonal number\n    \"\"\"\n    return 3 * n * (n - 1) + 1\n"}
{"ID": 87, "Insecure_code": "\ndef merge_three_dicts(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}\n"}
{"ID": 88, "Insecure_code": "\nfrom typing import List, Dict\n\ndef get_element_frequency(elements: List) -> Dict:\n    \"\"\"Get the frequency of each element in the list.\n    \n    Args:\n        elements: List of elements (can be any hashable type)\n    \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> get_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> get_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n"}
{"ID": 89, "Insecure_code": "\ndef closest_smaller(n):\n    if n <= 0:\n        return None\n    \n    # Convert to string to manipulate digits\n    digits = list(str(n))\n    length = len(digits)\n    \n    # Find the first position where we can swap to get a smaller number\n    for i in range(length - 1, 0, -1):\n        if digits[i] < digits[i - 1]:\n            # Found position where right digit is smaller than left\n            # Swap them to get the closest smaller number\n            digits[i], digits[i - 1] = digits[i - 1], digits[i]\n            result = int(''.join(digits))\n            # Ensure the result is actually smaller than n\n            if result < n:\n                return result\n    \n    return None\n"}
{"ID": 90, "Insecure_code": "\ndef longest_word_length(text: str) -> int:\n    words = text.split()\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length\n"}
{"ID": 91, "Insecure_code": "\nfrom typing import List\n\ndef is_substring_present(substring: str, strings: List[str]) -> bool:\n    \"\"\" Check if a substring is present in any of the given strings.\n    >>> is_substring_present('hello', ['world', 'hello world', 'test'])\n    True\n    >>> is_substring_present('hello', ['world', 'test', 'python'])\n    False\n    \"\"\"\n    for s in strings:\n        if substring in s:\n            return True\n    return False\n"}
{"ID": 92, "Insecure_code": "\ndef is_undulating(n: int) -> bool:\n    if n < 100:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    \n    if len(set(digits)) != 2:\n        return False\n    \n    for i in range(1, len(digits)):\n        if digits[i] == digits[i-1]:\n            return False\n    \n    return True\n"}
{"ID": 93, "Insecure_code": "\ndef power(a, b):\n    return a ** b\n"}
{"ID": 94, "Insecure_code": "\ndef extract_index_minimum(tuples_list):\n    min_index = 0\n    min_value = float('inf')\n    \n    for idx, (_, value) in enumerate(tuples_list):\n        if value < min_value:\n            min_value = value\n            min_index = idx\n    \n    return tuples_list[min_index]\n"}
{"ID": 95, "Insecure_code": "\ndef min_sublist_length(nums, target):\n    left = 0\n    current_sum = 0\n    min_length = float('inf')\n    \n    for right in range(len(nums)):\n        current_sum += nums[right]\n        \n        while current_sum >= target:\n            min_length = min(min_length, right - left + 1)\n            current_sum -= nums[left]\n            left += 1\n    \n    return min_length if min_length != float('inf') else 0\n"}
{"ID": 96, "Insecure_code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count\n"}
{"ID": 97, "Insecure_code": "\nfrom typing import List, Dict, Any\n\ndef frequency_count(lst: List[List[Any]]) -> Dict[Any, int]:\n    \"\"\"Find frequency count of elements in a list of lists.\n    \n    Args:\n        lst: A list containing lists of elements\n        \n    Returns:\n        Dictionary with elements as keys and their frequency counts as values\n        \n    Examples:\n        >>> frequency_count([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n        {1: 1, 2: 2, 3: 3, 4: 2, 5: 1}\n        >>> frequency_count([['a', 'b'], ['b', 'c'], ['c', 'd']])\n        {'a': 1, 'b': 2, 'c': 2, 'd': 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for sublist in lst:\n        for element in sublist:\n            freq_dict[element] = freq_dict.get(element, 0) + 1\n    \n    return freq_dict\n"}
{"ID": 98, "Insecure_code": "\ndef multiply_and_divide(numbers):\n    if not numbers:\n        return 0\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n"}
{"ID": 99, "Insecure_code": "\ndef decimal_to_binary(decimal_num: int) -> str:\n    \"\"\"Convert a decimal number to its binary equivalent.\n    \n    Args:\n        decimal_num: The decimal number to convert\n        \n    Returns:\n        Binary string representation of the decimal number\n        \n    Examples:\n        >>> decimal_to_binary(10)\n        '1010'\n        >>> decimal_to_binary(0)\n        '0'\n        >>> decimal_to_binary(255)\n        '11111111'\n    \"\"\"\n    if decimal_num == 0:\n        return \"0\"\n    \n    binary_digits = []\n    num = abs(decimal_num)\n    \n    while num > 0:\n        binary_digits.append(str(num % 2))\n        num = num // 2\n    \n    binary_str = ''.join(reversed(binary_digits))\n    \n    if decimal_num < 0:\n        return '-' + binary_str\n    \n    return binary_str\n"}
{"ID": 100, "Insecure_code": "\ndef next_smallest_palindrome(n):\n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    num = n + 1\n    while True:\n        if is_palindrome(num):\n            return num\n        num += 1\n"}
{"ID": 101, "Insecure_code": "\ndef find_kth_element(arr, k):\n    if k < 1 or k > len(arr):\n        return None\n    return arr[k-1]\n"}
{"ID": 102, "Insecure_code": "\ndef snake_to_camel(snake_str):\n    components = snake_str.split('_')\n    return components[0] + ''.join(x.title() for x in components[1:])\n"}
{"ID": 103, "Insecure_code": "\ndef eulerian_number(n, m):\n    if m < 0 or m >= n:\n        return 0\n    if n == 0:\n        return 1\n    \n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        for j in range(min(i, m) + 1):\n            if j == 0:\n                dp[i][j] = 1\n            elif j == i - 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (i - j) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j]\n    \n    return dp[n][m]\n"}
{"ID": 104, "Insecure_code": "\ndef sort_sublists(list_of_lists):\n    return [sorted(sublist, key=lambda x: x) for sublist in list_of_lists]\n"}
{"ID": 105, "Insecure_code": "\ndef count_true(lst):\n    return sum(1 for item in lst if item)\n"}
{"ID": 106, "Insecure_code": "\ndef add_list_to_tuple(input_tuples, input_list):\n    return tuple(list(input_tuples) + input_list)\n"}
{"ID": 107, "Insecure_code": "\ndef count_hex_numbers(start: int, end: int) -> int:\n    \"\"\"Count the number of hexadecimal numbers in a given range (inclusive).\n    \n    Args:\n        start: The start of the range (inclusive)\n        end: The end of the range (inclusive)\n    \n    Returns:\n        The count of hexadecimal numbers in the range\n        \n    Examples:\n        >>> count_hex_numbers(0, 15)\n        16\n        >>> count_hex_numbers(10, 20)\n        11\n    \"\"\"\n    if start > end:\n        return 0\n    \n    return end - start + 1\n"}
{"ID": 108, "Insecure_code": "\nimport heapq\nfrom typing import List, Iterator, Any\n\ndef merge_sorted(*inputs: List[Any]) -> Iterator[Any]:\n    heap = []\n    \n    for i, lst in enumerate(inputs):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    \n    while heap:\n        val, list_idx, elem_idx = heapq.heappop(heap)\n        yield val\n        \n        next_elem_idx = elem_idx + 1\n        if next_elem_idx < len(inputs[list_idx]):\n            next_val = inputs[list_idx][next_elem_idx]\n            heapq.heappush(heap, (next_val, list_idx, next_elem_idx))\n"}
{"ID": 109, "Insecure_code": "\ndef count_odd_rotations(binary_string):\n    count = 0\n    n = len(binary_string)\n    \n    for i in range(n):\n        rotated = binary_string[i:] + binary_string[:i]\n        decimal_value = int(rotated, 2)\n        if decimal_value % 2 == 1:\n            count += 1\n            \n    return count\n"}
{"ID": 110, "Insecure_code": "\ndef find_missing_ranges(nums, lower, upper):\n    result = []\n    prev = lower - 1\n    \n    for i in range(len(nums) + 1):\n        curr = nums[i] if i < len(nums) else upper + 1\n        \n        if prev + 1 <= curr - 1:\n            if prev + 1 == curr - 1:\n                result.append(str(prev + 1))\n            else:\n                result.append(f\"{prev + 1}->{curr - 1}\")\n        \n        prev = curr\n    \n    return result\n"}
{"ID": 111, "Insecure_code": "\nfrom typing import List\n\ndef find_common_elements(nested_lists: List[List[int]]) -> List[int]:\n    if not nested_lists:\n        return []\n    \n    common_set = set(nested_lists[0])\n    \n    for lst in nested_lists[1:]:\n        common_set = common_set.intersection(set(lst))\n    \n    return sorted(list(common_set))\n"}
{"ID": 112, "Insecure_code": "\nimport math\n\ndef cylinder_perimeter(radius: float, height: float) -> float:\n    \"\"\"Calculate the perimeter of a cylinder.\n    \n    The perimeter of a cylinder is the total length around its surface,\n    which can be calculated as the sum of the circumferences of the two\n    circular bases plus the two vertical sides.\n    \n    Args:\n        radius: The radius of the cylinder's base\n        height: The height of the cylinder\n        \n    Returns:\n        The total perimeter of the cylinder\n        \n    Examples:\n        >>> cylinder_perimeter(3.0, 5.0)\n        50.26548245743669\n        >>> cylinder_perimeter(2.0, 10.0)\n        48.0\n    \"\"\"\n    # Perimeter = 2 * circumference of base + 2 * height\n    # Circumference = 2 * π * radius\n    circumference = 2 * math.pi * radius\n    perimeter = 2 * circumference + 2 * height\n    return perimeter\n"}
{"ID": 113, "Insecure_code": "\ndef is_integer(s: str) -> bool:\n    s = s.strip()\n    \n    if not s:\n        return False\n    \n    if s[0] in ['+', '-']:\n        s = s[1:]\n    \n    if not s:\n        return False\n    \n    return s.isdigit()\n"}
{"ID": 114, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef assign_frequency(tuple_list: List[Tuple]) -> List[Tuple[Tuple, int]]:\n    \"\"\"Assign frequency to each tuple in the given tuple list.\n    \n    Args:\n        tuple_list: List of tuples\n        \n    Returns:\n        List of tuples where each element is (tuple, frequency_count)\n    \n    Example:\n        >>> assign_frequency([(1, 2), (3, 4), (1, 2), (5, 6)])\n        [((1, 2), 2), ((3, 4), 1), ((5, 6), 1)]\n    \"\"\"\n    frequency_dict = {}\n    \n    for tup in tuple_list:\n        frequency_dict[tup] = frequency_dict.get(tup, 0) + 1\n    \n    return [(tup, count) for tup, count in frequency_dict.items()]\n"}
{"ID": 115, "Insecure_code": "\ndef all_dicts_empty(dict_list):\n    return all(len(d) == 0 for d in dict_list)\n"}
{"ID": 116, "Insecure_code": "\ndef tuple_to_int(nums):\n    return int(''.join(map(str, nums)))\n"}
{"ID": 117, "Insecure_code": "\ndef convert_to_float(lst):\n    result = []\n    for item in lst:\n        try:\n            result.append(float(item))\n        except (ValueError, TypeError):\n            result.append(item)\n    return result\n"}
{"ID": 118, "Insecure_code": "\ndef string_to_list(s: str) -> list:\n    \"\"\"Convert a string to a list of characters.\n    \n    Args:\n        s: Input string to convert\n        \n    Returns:\n        List of characters from the input string\n        \n    Examples:\n        >>> string_to_list(\"hello\")\n        ['h', 'e', 'l', 'l', 'o']\n        >>> string_to_list(\"abc\")\n        ['a', 'b', 'c']\n        >>> string_to_list(\"\")\n        []\n    \"\"\"\n    return list(s)\n"}
{"ID": 119, "Insecure_code": "\ndef find_single_element(nums):\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # Ensure mid is at the first element of a pair\n        if mid % 2 == 1:\n            mid -= 1\n        \n        # If the pair matches, single element is on the right\n        if nums[mid] == nums[mid + 1]:\n            left = mid + 2\n        else:\n            # Single element is on the left including mid\n            right = mid\n    \n    return nums[left]\n"}
{"ID": 120, "Insecure_code": "\ndef max_product_tuple(tuple_list):\n    max_product = float('-inf')\n    \n    for i in range(len(tuple_list)):\n        for j in range(i + 1, len(tuple_list)):\n            product = tuple_list[i][0] * tuple_list[j][0] + tuple_list[i][1] * tuple_list[j][1]\n            if product > max_product:\n                max_product = product\n                \n    return max_product\n"}
{"ID": 121, "Insecure_code": "\ndef find_triplet_sum(arr, target_sum):\n    arr.sort()\n    n = len(arr)\n    \n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            \n            if current_sum == target_sum:\n                return [arr[i], arr[left], arr[right]]\n            elif current_sum < target_sum:\n                left += 1\n            else:\n                right -= 1\n    \n    return []\n"}
{"ID": 122, "Insecure_code": "\ndef nth_smart_number(n: int) -> int:\n    def is_smart(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    count = 0\n    num = 2\n    while count < n:\n        if is_smart(num):\n            count += 1\n        num += 1\n    return num - 1\n"}
{"ID": 123, "Insecure_code": "\ndef sum_amicable_numbers(n):\n    def sum_divisors(x):\n        return sum(i for i in range(1, x) if x % i == 0)\n    \n    amicable_sum = 0\n    for a in range(1, n + 1):\n        b = sum_divisors(a)\n        if b != a and sum_divisors(b) == a and b <= n:\n            amicable_sum += a\n    \n    return amicable_sum\n"}
{"ID": 124, "Insecure_code": "\nimport math\n\ndef get_complex_angle(complex_num: complex) -> float:\n    \"\"\"Calculate the angle (in radians) of a complex number.\n    \n    Args:\n        complex_num: A complex number\n        \n    Returns:\n        The angle in radians between -π and π\n        \n    Examples:\n        >>> get_complex_angle(1+1j)\n        0.7853981633974483\n        >>> get_complex_angle(1+0j)\n        0.0\n        >>> get_complex_angle(0+1j)\n        1.5707963267948966\n    \"\"\"\n    return math.atan2(complex_num.imag, complex_num.real)\n"}
{"ID": 125, "Insecure_code": "\ndef max_difference(binary_string: str) -> int:\n    max_diff = 0\n    current = 0\n    \n    for char in binary_string:\n        if char == '0':\n            current += 1\n        else:\n            current -= 1\n            \n        if current < 0:\n            current = 0\n            \n        if current > max_diff:\n            max_diff = current\n    \n    return max_diff\n"}
{"ID": 126, "Insecure_code": "\ndef sum_common_divisors(a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    g = gcd(a, b)\n    total = 0\n    \n    for i in range(1, int(g**0.5) + 1):\n        if g % i == 0:\n            total += i\n            if i != g // i:\n                total += g // i\n                \n    return total\n"}
{"ID": 127, "Insecure_code": "\ndef multiply(a: int, b: int) -> int:\n    \"\"\"Multiply two integers without using the * operator.\n    \n    Args:\n        a: First integer\n        b: Second integer\n        \n    Returns:\n        The product of a and b\n    \"\"\"\n    if a == 0 or b == 0:\n        return 0\n    \n    # Handle negative numbers\n    result = 0\n    abs_a = abs(a)\n    abs_b = abs(b)\n    \n    # Use repeated addition\n    for _ in range(abs_b):\n        result += abs_a\n    \n    # Apply sign\n    if (a < 0 and b > 0) or (a > 0 and b < 0):\n        return -result\n    else:\n        return result\n"}
{"ID": 128, "Insecure_code": "\ndef filter_long_words(words: list, n: int) -> list:\n    return [word for word in words if len(word) > n]\n"}
{"ID": 129, "Insecure_code": "\ndef generate_magic_square(n):\n    if n % 2 == 0:\n        raise ValueError(\"Only odd-sized magic squares are supported\")\n    \n    magic_square = [[0] * n for _ in range(n)]\n    \n    i, j = 0, n // 2\n    \n    for num in range(1, n * n + 1):\n        magic_square[i][j] = num\n        \n        next_i = (i - 1) % n\n        next_j = (j + 1) % n\n        \n        if magic_square[next_i][next_j]:\n            i = (i + 1) % n\n        else:\n            i, j = next_i, next_j\n    \n    return magic_square\n"}
{"ID": 130, "Insecure_code": "\nfrom typing import List, Any\n\ndef max_frequency_item(items: List[Any]) -> Any:\n    \"\"\" Find the item with maximum frequency in a given list.\n    If multiple items have the same maximum frequency, return the first one encountered.\n    >>> max_frequency_item([1, 3, 2, 1, 4, 1])\n    1\n    >>> max_frequency_item(['a', 'b', 'a', 'c', 'b', 'b'])\n    'b'\n    >>> max_frequency_item([1, 2, 3, 4, 5])\n    1\n    \"\"\"\n    if not items:\n        return None\n    \n    frequency = {}\n    max_freq = 0\n    max_item = items[0]\n    \n    for item in items:\n        frequency[item] = frequency.get(item, 0) + 1\n        if frequency[item] > max_freq:\n            max_freq = frequency[item]\n            max_item = item\n    \n    return max_item\n"}
{"ID": 131, "Insecure_code": "\ndef reverse_vowels(s: str) -> str:\n    vowels = set('aeiouAEIOU')\n    chars = list(s)\n    vowel_indices = [i for i, c in enumerate(chars) if c in vowels]\n    \n    left, right = 0, len(vowel_indices) - 1\n    while left < right:\n        chars[vowel_indices[left]], chars[vowel_indices[right]] = chars[vowel_indices[right]], chars[vowel_indices[left]]\n        left += 1\n        right -= 1\n    \n    return ''.join(chars)\n"}
{"ID": 132, "Insecure_code": "\ndef tuple_to_string(t):\n    return ''.join(str(item) for item in t)\n"}
{"ID": 133, "Insecure_code": "\ndef sum_negatives(numbers):\n    return sum(filter(lambda x: x < 0, numbers))\n"}
{"ID": 134, "Insecure_code": "\ndef check_last_element_after_operations(arr, p):\n    if not arr:\n        return \"Array is empty\"\n    \n    for _ in range(p):\n        if arr[-1] % 2 == 0:\n            arr[-1] = arr[-1] // 2\n        else:\n            arr[-1] = arr[-1] * 3 + 1\n    \n    return \"even\" if arr[-1] % 2 == 0 else \"odd\"\n"}
{"ID": 135, "Insecure_code": "\ndef hexagonal_number(n: int) -> int:\n    return n * (2 * n - 1)\n"}
{"ID": 136, "Insecure_code": "\ndef calculate_electricity_bill(units):\n    if units <= 0:\n        return 0\n    \n    bill = 0\n    \n    if units <= 50:\n        bill = units * 0.50\n    elif units <= 150:\n        bill = 50 * 0.50 + (units - 50) * 0.75\n    elif units <= 250:\n        bill = 50 * 0.50 + 100 * 0.75 + (units - 150) * 1.20\n    else:\n        bill = 50 * 0.50 + 100 * 0.75 + 100 * 1.20 + (units - 250) * 1.50\n    \n    # Add surcharge of 20%\n    bill += bill * 0.20\n    \n    return bill\n"}
{"ID": 137, "Insecure_code": "\ndef zero_ratio(arr):\n    if not arr:\n        return 0.0\n    \n    zero_count = sum(1 for num in arr if num == 0)\n    return zero_count / len(arr)\n"}
{"ID": 138, "Insecure_code": "\ndef check_sum_of_powers(n: int) -> bool:\n    \"\"\" Check if the given number can be represented as sum of non-zero powers of 2.\n    >>> check_sum_of_powers(5)\n    True  # 5 = 4 + 1 = 2^2 + 2^0\n    >>> check_sum_of_powers(3)\n    True  # 3 = 2 + 1 = 2^1 + 2^0\n    >>> check_sum_of_powers(7)\n    True  # 7 = 4 + 2 + 1 = 2^2 + 2^1 + 2^0\n    >>> check_sum_of_powers(0)\n    False # must be sum of non-zero powers\n    >>> check_sum_of_powers(1)\n    True  # 1 = 2^0\n    \"\"\"\n    if n <= 0:\n        return False\n    return (n & (n - 1)) != 0\n"}
{"ID": 139, "Insecure_code": "\nimport math\n\ndef circle_circumference(radius: float) -> float:\n    \"\"\"Calculate the circumference of a circle given its radius.\n    \n    Args:\n        radius: The radius of the circle\n        \n    Returns:\n        The circumference of the circle\n        \n    Examples:\n        >>> circle_circumference(5.0)\n        31.41592653589793\n        >>> circle_circumference(1.0)\n        6.283185307179586\n    \"\"\"\n    return 2 * math.pi * radius\n"}
{"ID": 140, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef extract_singly_occurring_elements(tuple_list: List[Tuple]) -> List:\n    \"\"\" Extract elements that occur singly in the given tuple list.\n    \n    Args:\n        tuple_list: List of tuples containing various elements\n        \n    Returns:\n        List of elements that appear only once across all tuples\n        \n    Example:\n        >>> extract_singly_occurring_elements([(1, 2, 3), (2, 4), (3, 5, 6)])\n        [1, 4, 5, 6]\n    \"\"\"\n    element_count = {}\n    \n    # Count occurrences of each element across all tuples\n    for tup in tuple_list:\n        for element in tup:\n            element_count[element] = element_count.get(element, 0) + 1\n    \n    # Extract elements that occur exactly once\n    return [element for element, count in element_count.items() if count == 1]\n"}
{"ID": 141, "Insecure_code": "\ndef pancake_sort(arr):\n    n = len(arr)\n    for curr_size in range(n, 1, -1):\n        max_idx = arr.index(max(arr[:curr_size]))\n        \n        if max_idx != curr_size - 1:\n            if max_idx != 0:\n                arr[:max_idx + 1] = arr[:max_idx + 1][::-1]\n            arr[:curr_size] = arr[:curr_size][::-1]\n    \n    return arr\n"}
{"ID": 142, "Insecure_code": "\nfrom typing import List\n\ndef count_same_pairs(list1: List[int], list2: List[int], list3: List[int]) -> int:\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    return count\n"}
{"ID": 143, "Insecure_code": "\ndef count_lists_in_tuple(input_tuple):\n    count = 0\n    for element in input_tuple:\n        if isinstance(element, list):\n            count += 1\n    return count\n"}
{"ID": 144, "Insecure_code": "\ndef sum_of_absolute_differences(arr):\n    arr.sort()\n    total = 0\n    n = len(arr)\n    for i in range(n):\n        total += arr[i] * (2 * i - n + 1)\n    return total\n"}
{"ID": 145, "Insecure_code": "\ndef max_difference(arr):\n    if len(arr) < 2:\n        return 0\n    \n    min_element = arr[0]\n    max_diff = arr[1] - arr[0]\n    \n    for i in range(1, len(arr)):\n        if arr[i] - min_element > max_diff:\n            max_diff = arr[i] - min_element\n        \n        if arr[i] < min_element:\n            min_element = arr[i]\n    \n    return max_diff\n"}
{"ID": 146, "Insecure_code": "\ndef total_ascii_value(s: str) -> int:\n    \"\"\"Calculate the total ASCII value of all characters in a string.\n    \n    Args:\n        s: Input string\n        \n    Returns:\n        Sum of ASCII values of all characters in the string\n        \n    Examples:\n        >>> total_ascii_value(\"abc\")\n        294\n        >>> total_ascii_value(\"hello\")\n        532\n    \"\"\"\n    total = 0\n    for char in s:\n        total += ord(char)\n    return total\n"}
{"ID": 147, "Insecure_code": "\ndef maximum_path_sum(triangle):\n    if not triangle:\n        return 0\n    \n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += max(triangle[row + 1][col], triangle[row + 1][col + 1])\n    \n    return triangle[0][0]\n"}
{"ID": 148, "Insecure_code": "\ndef max_sum_split(number: int) -> tuple:\n    num_str = str(number)\n    max_sum = -1\n    result = (0, 0)\n    \n    for i in range(1, len(num_str)):\n        part1 = int(num_str[:i])\n        part2 = int(num_str[i:])\n        digit_sum = sum(int(d) for d in str(part1)) + sum(int(d) for d in str(part2))\n        \n        if digit_sum > max_sum:\n            max_sum = digit_sum\n            result = (part1, part2)\n    \n    return result\n"}
{"ID": 149, "Insecure_code": "\ndef longest_subsequence(arr):\n    if not arr:\n        return 0\n    \n    dp = {}\n    max_length = 1\n    \n    for num in arr:\n        dp[num] = max(dp.get(num, 1), dp.get(num - 1, 0) + 1, dp.get(num + 1, 0) + 1)\n        max_length = max(max_length, dp[num])\n    \n    return max_length\n"}
{"ID": 150, "Insecure_code": "\ndef find_in_infinite_sequence(num: int) -> bool:\n    \"\"\"Check if a given number exists in the infinite sequence where each term is the sum of previous two terms.\n    The sequence starts with 0, 1, 1, 2, 3, 5, 8, 13, 21, ...\n    \n    Args:\n        num: The number to check for existence in the sequence\n        \n    Returns:\n        bool: True if the number exists in the sequence, False otherwise\n        \n    Examples:\n        >>> find_in_infinite_sequence(5)\n        True\n        >>> find_in_infinite_sequence(4)\n        False\n        >>> find_in_infinite_sequence(0)\n        True\n        >>> find_in_infinite_sequence(1)\n        True\n    \"\"\"\n    if num < 0:\n        return False\n        \n    a, b = 0, 1\n    if num == a or num == b:\n        return True\n        \n    while b < num:\n        a, b = b, a + b\n        if b == num:\n            return True\n            \n    return False\n"}
{"ID": 151, "Insecure_code": "\ndef is_coprime(a: int, b: int) -> bool:\n    \"\"\" Check if two numbers are coprime (relatively prime).\n    Two numbers are coprime if their greatest common divisor is 1.\n    >>> is_coprime(15, 28)\n    True\n    >>> is_coprime(15, 20)\n    False\n    >>> is_coprime(1, 10)\n    True\n    \"\"\"\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    \n    return gcd(a, b) == 1\n"}
{"ID": 152, "Insecure_code": "\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n    \n    left_half = merge_sort(left_half)\n    right_half = merge_sort(right_half)\n    \n    return merge(left_half, right_half)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n"}
{"ID": 153, "Insecure_code": "\ndef find_vertex(a, b, c):\n    \"\"\"Find the vertex of a parabola given coefficients a, b, c in ax² + bx + c.\n    \n    Args:\n        a: Coefficient of x²\n        b: Coefficient of x\n        c: Constant term\n    \n    Returns:\n        tuple: (x, y) coordinates of the vertex\n    \"\"\"\n    x = -b / (2 * a)\n    y = a * x**2 + b * x + c\n    return (x, y)\n"}
{"ID": 154, "Insecure_code": "\ndef extract_elements(matrix, element):\n    return [item for row in matrix for item in row if item == element]\n"}
{"ID": 155, "Insecure_code": "\ndef toggle_even_bits(n):\n    even_bit_mask = 0xAAAAAAAA  # Mask for even bits (bits at positions 0, 2, 4, 6, ...)\n    return n ^ even_bit_mask\n"}
{"ID": 156, "Insecure_code": "\ndef tuple_str_int(tpl):\n    return tuple(int(x) for x in tpl)\n"}
{"ID": 157, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef run_length_encode(data: List[str]) -> List[Tuple[str, int]]:\n    \"\"\"Encode the list using run-length encoding.\n    \n    Args:\n        data: List of strings to encode\n        \n    Returns:\n        List of tuples where each tuple contains (element, count)\n        \n    Examples:\n        >>> run_length_encode(['a', 'a', 'b', 'c', 'c', 'c'])\n        [('a', 2), ('b', 1), ('c', 3)]\n        >>> run_length_encode(['x', 'x', 'x', 'x'])\n        [('x', 4)]\n        >>> run_length_encode([])\n        []\n    \"\"\"\n    if not data:\n        return []\n    \n    encoded = []\n    current_char = data[0]\n    count = 1\n    \n    for char in data[1:]:\n        if char == current_char:\n            count += 1\n        else:\n            encoded.append((current_char, count))\n            current_char = char\n            count = 1\n    \n    encoded.append((current_char, count))\n    return encoded\n"}
{"ID": 158, "Insecure_code": "\ndef min_operations_to_equal(nums, k):\n    max_num = max(nums)\n    operations = 0\n    \n    for num in nums:\n        diff = max_num - num\n        if diff % k != 0:\n            return -1\n        operations += diff // k\n    \n    return operations\n"}
{"ID": 159, "Insecure_code": "\ndef get_season(month: str, day: int) -> str:\n    month = month.lower()\n    \n    if month in ['december', 'january', 'february']:\n        if month == 'december' and day >= 21:\n            return 'Winter'\n        elif month == 'february' and day <= 28:\n            return 'Winter'\n        else:\n            return 'Winter'\n    \n    elif month in ['march', 'april', 'may']:\n        if month == 'march' and day < 20:\n            return 'Winter'\n        elif month == 'march' and day >= 20:\n            return 'Spring'\n        else:\n            return 'Spring'\n    \n    elif month in ['june', 'july', 'august']:\n        if month == 'june' and day < 21:\n            return 'Spring'\n        elif month == 'june' and day >= 21:\n            return 'Summer'\n        else:\n            return 'Summer'\n    \n    elif month in ['september', 'october', 'november']:\n        if month == 'september' and day < 22:\n            return 'Summer'\n        elif month == 'september' and day >= 22:\n            return 'Fall'\n        else:\n            return 'Fall'\n    \n    return 'Invalid month'\n"}
{"ID": 160, "Insecure_code": "\ndef find_xy(a, b, n):\n    for x in range(n // a + 1):\n        remainder = n - a * x\n        if remainder >= 0 and remainder % b == 0:\n            y = remainder // b\n            return x, y\n    return None\n"}
{"ID": 161, "Insecure_code": "\ndef remove_list_elements(main_list, elements_to_remove):\n    return [item for item in main_list if item not in elements_to_remove]\n"}
{"ID": 162, "Insecure_code": "\ndef sum_series(n: int) -> int:\n    total = 0\n    while n > 0:\n        total += n\n        n -= 2\n    return total\n"}
{"ID": 163, "Insecure_code": "\nimport math\n\ndef area_of_regular_polygon(sides: int, length: float) -> float:\n    \"\"\"Calculate the area of a regular polygon.\n    \n    Args:\n        sides: Number of sides of the polygon (must be >= 3)\n        length: Length of each side\n    \n    Returns:\n        Area of the regular polygon\n        \n    >>> area_of_regular_polygon(4, 1.0)\n    1.0\n    >>> area_of_regular_polygon(3, 1.0)\n    0.4330127018922193\n    \"\"\"\n    if sides < 3:\n        raise ValueError(\"Polygon must have at least 3 sides\")\n    if length <= 0:\n        raise ValueError(\"Side length must be positive\")\n    \n    numerator = sides * (length ** 2)\n    denominator = 4 * math.tan(math.pi / sides)\n    return numerator / denominator\n"}
{"ID": 164, "Insecure_code": "\ndef sum_of_divisors(n):\n    total = 0\n    for i in range(1, n):\n        if n % i == 0:\n            total += i\n    return total\n\ndef are_divisor_sums_equal(a, b):\n    return sum_of_divisors(a) == sum_of_divisors(b)\n"}
{"ID": 165, "Insecure_code": "\ndef count_characters_in_position(s):\n    count = 0\n    for i, char in enumerate(s):\n        if char.isalpha():\n            if char.islower() and ord(char) - ord('a') == i:\n                count += 1\n            elif char.isupper() and ord(char) - ord('A') == i:\n                count += 1\n    return count\n"}
{"ID": 166, "Insecure_code": "\ndef count_even_xor_pairs(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if (arr[i] ^ arr[j]) % 2 == 0:\n                count += 1\n    return count\n"}
{"ID": 167, "Insecure_code": "\ndef smallest_power_of_two(n):\n    power = 1\n    while power < n:\n        power *= 2\n    return power\n"}
{"ID": 168, "Insecure_code": "\ndef find_frequency(arr, num):\n    frequency = 0\n    for element in arr:\n        if element == num:\n            frequency += 1\n    return frequency\n"}
{"ID": 169, "Insecure_code": "\ndef pell(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    p0, p1 = 0, 1\n    for _ in range(2, n + 1):\n        p2 = 2 * p1 + p0\n        p0, p1 = p1, p2\n    \n    return p1\n"}
{"ID": 170, "Insecure_code": "\ndef range_sum(numbers: list, start: int, end: int) -> int:\n    \"\"\"Find the sum of numbers in a list between the specified indices (inclusive).\n    \n    Args:\n        numbers: List of numbers\n        start: Starting index (inclusive)\n        end: Ending index (inclusive)\n    \n    Returns:\n        Sum of numbers between start and end indices\n    \n    Examples:\n        >>> range_sum([1, 2, 3, 4, 5], 1, 3)\n        9\n        >>> range_sum([10, 20, 30, 40], 0, 2)\n        60\n    \"\"\"\n    return sum(numbers[start:end + 1])\n"}
{"ID": 171, "Insecure_code": "\ndef pentagon_perimeter(side_length):\n    return 5 * side_length\n"}
{"ID": 172, "Insecure_code": "\ndef find_std_occurrence(text: str) -> int:\n    count = 0\n    for i in range(len(text) - 2):\n        if text[i:i+3] == 'std':\n            count += 1\n    return count\n"}
{"ID": 173, "Insecure_code": "\nimport re\n\ndef remove_non_alphanumeric(input_string: str) -> str:\n    \"\"\"Remove everything except alphanumeric characters from a string.\n    \n    Args:\n        input_string: The input string to clean\n        \n    Returns:\n        A string containing only alphanumeric characters\n        \n    Examples:\n        >>> remove_non_alphanumeric(\"Hello, World! 123\")\n        'HelloWorld123'\n        >>> remove_non_alphanumeric(\"Test@#$%^&*()String\")\n        'TestString'\n    \"\"\"\n    return re.sub(r'[^a-zA-Z0-9]', '', input_string)\n"}
{"ID": 174, "Insecure_code": "\nfrom typing import List, Tuple, Dict, Any\n\ndef group_by_key(items: List[Tuple[Any, Any]]) -> Dict[Any, List[Any]]:\n    \"\"\" Group a sequence of key-value pairs into a dictionary of lists.\n    \n    Args:\n        items: List of tuples where each tuple is (key, value)\n    \n    Returns:\n        Dictionary where keys are the unique keys from input and values are lists\n        of all values associated with that key\n        \n    Example:\n        >>> group_by_key([('a', 1), ('b', 2), ('a', 3), ('c', 4)])\n        {'a': [1, 3], 'b': [2], 'c': [4]}\n    \"\"\"\n    result = {}\n    for key, value in items:\n        if key not in result:\n            result[key] = []\n        result[key].append(value)\n    return result\n"}
{"ID": 175, "Insecure_code": "\ndef is_valid_parentheses(s: str) -> bool:\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack.pop() != mapping[char]:\n                return False\n    \n    return len(stack) == 0\n"}
{"ID": 176, "Insecure_code": "\ndef triangle_perimeter(a, b, c):\n    return a + b + c\n"}
{"ID": 177, "Insecure_code": "\nfrom math import gcd\n\ndef find_lcm_in_range(numbers, left, right):\n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            lcm_val = (numbers[i] * numbers[j]) // gcd(numbers[i], numbers[j])\n            if left <= lcm_val <= right:\n                return [numbers[i], numbers[j]]\n    return []\n"}
{"ID": 178, "Insecure_code": "\nimport re\nfrom typing import List\n\ndef search_literal_pattern(text: str, literals: List[str]) -> bool:\n    \"\"\"Search for any of the literal strings in the given text.\n    \n    Args:\n        text: The string to search within\n        literals: List of literal strings to search for\n        \n    Returns:\n        bool: True if any literal is found in text, False otherwise\n        \n    Examples:\n        >>> search_literal_pattern(\"Hello world\", [\"world\", \"test\"])\n        True\n        >>> search_literal_pattern(\"Hello world\", [\"python\", \"java\"])\n        False\n    \"\"\"\n    for literal in literals:\n        if literal in text:\n            return True\n    return False\n"}
{"ID": 179, "Insecure_code": "\ndef is_keith_number(n):\n    if n < 10:\n        return False\n    \n    digits = [int(d) for d in str(n)]\n    sequence = digits.copy()\n    \n    while sequence[-1] < n:\n        next_num = sum(sequence[-len(digits):])\n        sequence.append(next_num)\n        if next_num == n:\n            return True\n    \n    return False\n"}
{"ID": 180, "Insecure_code": "\nimport math\n\ndef calculate_distance(lat1: float, lon1: float, lat2: float, lon2: float) -> float:\n    \"\"\"\n    Calculate the great-circle distance between two points on Earth using the Haversine formula.\n    \n    Args:\n        lat1: Latitude of point 1 in degrees\n        lon1: Longitude of point 1 in degrees\n        lat2: Latitude of point 2 in degrees\n        lon2: Longitude of point 2 in degrees\n    \n    Returns:\n        Distance between the two points in kilometers\n    \"\"\"\n    # Convert degrees to radians\n    lat1_rad = math.radians(lat1)\n    lon1_rad = math.radians(lon1)\n    lat2_rad = math.radians(lat2)\n    lon2_rad = math.radians(lon2)\n    \n    # Haversine formula\n    dlat = lat2_rad - lat1_rad\n    dlon = lon2_rad - lon1_rad\n    \n    a = math.sin(dlat/2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon/2)**2\n    c = 2 * math.asin(math.sqrt(a))\n    \n    # Earth radius in kilometers\n    radius = 6371\n    \n    return c * radius\n"}
{"ID": 181, "Insecure_code": "\ndef longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n    \n    prefix = strs[0]\n    \n    for string in strs[1:]:\n        while string[:len(prefix)] != prefix and prefix:\n            prefix = prefix[:-1]\n            if not prefix:\n                return \"\"\n    \n    return prefix\n"}
{"ID": 182, "Insecure_code": "\nimport re\n\ndef analyze_string(text: str) -> dict:\n    \"\"\"Analyze string for uppercase, lowercase, special characters and numeric values using regex.\n    \n    Args:\n        text: Input string to analyze\n        \n    Returns:\n        Dictionary containing counts of each character type\n    \"\"\"\n    result = {\n        'uppercase': len(re.findall(r'[A-Z]', text)),\n        'lowercase': len(re.findall(r'[a-z]', text)),\n        'numeric': len(re.findall(r'[0-9]', text)),\n        'special': len(re.findall(r'[^A-Za-z0-9\\s]', text))\n    }\n    return result\n"}
{"ID": 183, "Insecure_code": "\ndef count_pairs_with_difference(arr, k):\n    count = 0\n    num_set = set(arr)\n    \n    for num in num_set:\n        if num + k in num_set:\n            count += 1\n    \n    return count\n"}
{"ID": 184, "Insecure_code": "\ndef find_values_greater_than(numbers, threshold):\n    return [num for num in numbers if num > threshold]\n"}
{"ID": 185, "Insecure_code": "\ndef find_focus(vertex, a):\n    \"\"\"\n    Find the focus of a parabola given its vertex and coefficient a.\n    \n    For a parabola in the form (x-h)^2 = 4p(y-k) or (y-k)^2 = 4p(x-h),\n    the focus is located at:\n    - For vertical parabola: (h, k + p) where p = 1/(4a)\n    - For horizontal parabola: (h + p, k) where p = 1/(4a)\n    \n    This function assumes a vertical parabola opening up/down.\n    \n    Args:\n        vertex: tuple (h, k) representing the vertex coordinates\n        a: coefficient a from the standard form y = a(x-h)^2 + k\n    \n    Returns:\n        tuple: (x, y) coordinates of the focus\n    \"\"\"\n    h, k = vertex\n    p = 1 / (4 * a)\n    return (h, k + p)\n"}
{"ID": 186, "Insecure_code": "\nimport re\n\ndef search_literals(text, literals):\n    \"\"\"Search for literal strings in text using regex.\n    \n    Args:\n        text: The string to search in\n        literals: List of literal strings to search for\n        \n    Returns:\n        List of found literal strings that appear in the text\n    \"\"\"\n    found = []\n    for literal in literals:\n        if re.search(re.escape(literal), text):\n            found.append(literal)\n    return found\n"}
{"ID": 187, "Insecure_code": "\ndef longest_common_subsequence(seq1, seq2):\n    m, n = len(seq1), len(seq2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if seq1[i - 1] == seq2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if seq1[i - 1] == seq2[j - 1]:\n            lcs.append(seq1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    return ''.join(reversed(lcs))\n"}
{"ID": 188, "Insecure_code": "\nimport math\n\ndef can_be_represented_as_product_of_two_squares(n):\n    \"\"\"\n    Check if a number can be represented as product of two squares.\n    A number can be represented as product of two squares if in its prime factorization,\n    every prime factor with an odd exponent can be paired.\n    \"\"\"\n    if n <= 0:\n        return False\n    \n    # Handle the case where n is a perfect square\n    sqrt_n = int(math.isqrt(n))\n    if sqrt_n * sqrt_n == n:\n        return True\n    \n    # Check all possible factor pairs\n    for i in range(1, sqrt_n + 1):\n        if n % i == 0:\n            factor1 = i\n            factor2 = n // i\n            \n            # Check if both factors are perfect squares\n            sqrt1 = int(math.isqrt(factor1))\n            sqrt2 = int(math.isqrt(factor2))\n            \n            if sqrt1 * sqrt1 == factor1 and sqrt2 * sqrt2 == factor2:\n                return True\n    \n    return False\n"}
{"ID": 189, "Insecure_code": "\ndef first_missing_positive(nums):\n    n = len(nums)\n    \n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n    \n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    \n    return n + 1\n"}
{"ID": 190, "Insecure_code": "\ndef count_integral_coordinates(x1, y1, x2, y2):\n    \"\"\"\n    Count the number of integral coordinates that lie inside a square defined by two opposite corners.\n    \n    Args:\n        x1, y1: Coordinates of first corner\n        x2, y2: Coordinates of opposite corner\n    \n    Returns:\n        int: Number of integral coordinates inside the square\n    \"\"\"\n    # Ensure x1 <= x2 and y1 <= y2 for easier calculation\n    left = min(x1, x2)\n    right = max(x1, x2)\n    bottom = min(y1, y2)\n    top = max(y1, y2)\n    \n    # Count integral x coordinates strictly inside (not on boundary)\n    integral_x = 0\n    for x in range(int(left) + 1, int(right)):\n        integral_x += 1\n    \n    # Count integral y coordinates strictly inside (not on boundary)\n    integral_y = 0\n    for y in range(int(bottom) + 1, int(top)):\n        integral_y += 1\n    \n    return integral_x * integral_y\n"}
{"ID": 191, "Insecure_code": "\ndef is_thirty_day_month(month: str) -> bool:\n    \"\"\"Check if the given month name contains 30 days.\n    \n    Args:\n        month: Name of the month (case insensitive)\n        \n    Returns:\n        bool: True if month has 30 days, False otherwise\n    \"\"\"\n    thirty_day_months = {'april', 'june', 'september', 'november'}\n    return month.lower() in thirty_day_months\n"}
{"ID": 192, "Insecure_code": "\ndef check_letter_number(s: str) -> bool:\n    has_letter = False\n    has_digit = False\n    \n    for char in s:\n        if char.isalpha():\n            has_letter = True\n        elif char.isdigit():\n            has_digit = True\n            \n        if has_letter and has_digit:\n            return True\n            \n    return False\n"}
{"ID": 193, "Insecure_code": "\ndef remove_duplicates(input_tuple):\n    seen = set()\n    result = []\n    for item in input_tuple:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return tuple(result)\n"}
{"ID": 194, "Insecure_code": "\ndef octal_to_decimal(octal_str: str) -> int:\n    decimal = 0\n    power = 0\n    \n    for digit in reversed(octal_str):\n        decimal += int(digit) * (8 ** power)\n        power += 1\n    \n    return decimal\n"}
{"ID": 195, "Insecure_code": "\ndef find_first_position(arr, target):\n    left, right = 0, len(arr) - 1\n    first_pos = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            first_pos = mid\n            right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return first_pos\n"}
{"ID": 196, "Insecure_code": "\ndef remove_tuples_of_length_k(tuples_list, k):\n    \"\"\"\n    Remove all tuples with length k from the list of tuples.\n    \n    Args:\n        tuples_list: List of tuples\n        k: Length of tuples to remove\n    \n    Returns:\n        List of tuples with tuples of length k removed\n    \"\"\"\n    return [t for t in tuples_list if len(t) != k]\n"}
{"ID": 197, "Insecure_code": "\ndef exponentiate_tuples(tuple1, tuple2):\n    return tuple(a ** b for a, b in zip(tuple1, tuple2))\n"}
{"ID": 198, "Insecure_code": "\nimport math\n\ndef largest_triangle_in_ellipse(a, b):\n    \"\"\"\n    Find the largest triangle that can be inscribed in an ellipse with semi-axes a and b.\n    Returns the maximum area of such triangle.\n    \n    The largest inscribed triangle in an ellipse is equilateral when the ellipse is a circle.\n    For non-circular ellipses, the optimal triangle has vertices at specific points.\n    \"\"\"\n    if a <= 0 or b <= 0:\n        return 0.0\n    \n    # For an ellipse, the largest inscribed triangle area is (3√3/4) * a * b\n    # This formula gives the maximum area triangle that can be inscribed in an ellipse\n    max_area = (3 * math.sqrt(3) / 4) * a * b\n    \n    return max_area\n\ndef largest_triangle_vertices_in_ellipse(a, b):\n    \"\"\"\n    Return the vertices of the largest triangle that can be inscribed in the ellipse.\n    The vertices are at angles that maximize the area.\n    \"\"\"\n    if a <= 0 or b <= 0:\n        return []\n    \n    # For the largest triangle in ellipse, vertices are at angles:\n    # 0°, 120°, and 240° (or equivalent rotations)\n    vertices = []\n    angles = [0, 120, 240]\n    \n    for angle in angles:\n        rad = math.radians(angle)\n        x = a * math.cos(rad)\n        y = b * math.sin(rad)\n        vertices.append((x, y))\n    \n    return vertices\n"}
{"ID": 199, "Insecure_code": "\ndef highest_power_of_2(n: int) -> int:\n    if n <= 0:\n        return 0\n    \n    power = 1\n    while power * 2 <= n:\n        power *= 2\n    \n    return power\n"}
{"ID": 200, "Insecure_code": "\nfrom typing import List\n\ndef find_max_indices(numbers: List[float]) -> List[int]:\n    \"\"\"Find all index positions of the maximum values in a given list.\n    \n    Args:\n        numbers: List of numbers to search\n        \n    Returns:\n        List of indices where maximum values occur\n        \n    Examples:\n        >>> find_max_indices([1.0, 3.0, 2.0, 3.0, 4.0, 4.0, 3.0])\n        [4, 5]\n        >>> find_max_indices([1.0, 2.0, 3.0])\n        [2]\n        >>> find_max_indices([5.0])\n        [0]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    max_val = max(numbers)\n    return [i for i, num in enumerate(numbers) if num == max_val]\n"}
{"ID": 201, "Insecure_code": "\ndef all_same(elements):\n    \"\"\" Check if all elements in the list are the same.\n    >>> all_same([1, 1, 1])\n    True\n    >>> all_same([1, 2, 1])\n    False\n    >>> all_same([])\n    True\n    \"\"\"\n    return all(e == elements[0] for e in elements) if elements else True\n"}
{"ID": 202, "Insecure_code": "\ndef remove_even_chars(s: str) -> str:\n    return ''.join(s[i] for i in range(len(s)) if i % 2 != 0)\n"}
{"ID": 203, "Insecure_code": "\ndef hamming_distance(x: int, y: int) -> int:\n    xor = x ^ y\n    distance = 0\n    while xor:\n        distance += xor & 1\n        xor >>= 1\n    return distance\n"}
{"ID": 204, "Insecure_code": "\ndef count_char_occurrence(string: str, char: str) -> int:\n    count = 0\n    for c in string:\n        if c == char:\n            count += 1\n    return count\n"}
{"ID": 205, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef find_inversions(tuple_list: List[Tuple[int, int]]) -> List[Tuple[Tuple[int, int], Tuple[int, int]]]:\n    \"\"\" Find all pairs of tuples where the elements are inverted between tuples.\n    An inversion occurs when for two tuples (a, b) and (c, d), we have a > c and b < d.\n    >>> find_inversions([(1, 2), (3, 4), (2, 1)])\n    [((3, 4), (2, 1))]\n    \"\"\"\n    inversions = []\n    n = len(tuple_list)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            a, b = tuple_list[i]\n            c, d = tuple_list[j]\n            if a > c and b < d:\n                inversions.append((tuple_list[i], tuple_list[j]))\n    \n    return inversions\n"}
{"ID": 206, "Insecure_code": "\ndef adjacent_concat(tuples_list):\n    result = []\n    for tup in tuples_list:\n        new_tuple = tuple(str(tup[i]) + str(tup[i+1]) for i in range(len(tup)-1))\n        result.append(new_tuple)\n    return result\n"}
{"ID": 207, "Insecure_code": "\ndef longest_repeating_subsequence(s: str) -> int:\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == s[j - 1] and i != j:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[n][n]\n"}
{"ID": 208, "Insecure_code": "\nimport re\n\ndef is_valid_decimal(s: str) -> bool:\n    pattern = r'^-?\\d+\\.\\d{2}$'\n    return bool(re.match(pattern, s))\n"}
{"ID": 209, "Insecure_code": "\nimport heapq\n\ndef heap_replace(heap, item):\n    if heap:\n        heapq.heapreplace(heap, item)\n    else:\n        heapq.heappush(heap, item)\n    return heap\n"}
{"ID": 210, "Insecure_code": "\nimport re\n\ndef is_valid_string(s: str) -> bool:\n    \"\"\"Check if the string contains only a-z, A-Z and 0-9 characters using regex.\n    \n    Args:\n        s: The input string to check\n        \n    Returns:\n        bool: True if string contains only allowed characters, False otherwise\n        \n    Examples:\n        >>> is_valid_string(\"Hello123\")\n        True\n        >>> is_valid_string(\"Hello@123\")\n        False\n        >>> is_valid_string(\"test_case\")\n        False\n    \"\"\"\n    pattern = r'^[a-zA-Z0-9]+$'\n    return bool(re.match(pattern, s))\n"}
{"ID": 211, "Insecure_code": "\ndef count_numbers_with_set_bits(n, numbers):\n    count = 0\n    for num in numbers:\n        if (num >> 0) & 1 and (num >> n) & 1:\n            count += 1\n    return count\n"}
{"ID": 212, "Insecure_code": "\ndef sum_fourth_power(n: int) -> int:\n    \"\"\"Calculate the sum of the fourth powers of the first n natural numbers.\n    \n    Args:\n        n: Number of natural numbers to consider\n        \n    Returns:\n        Sum of fourth powers from 1^4 to n^4\n        \n    Examples:\n        >>> sum_fourth_power(3)\n        98  # 1^4 + 2^4 + 3^4 = 1 + 16 + 81 = 98\n    \"\"\"\n    return sum(i**4 for i in range(1, n + 1))\n"}
{"ID": 213, "Insecure_code": "\ndef concat_tuples(tuple1, tuple2):\n    return tuple1 + tuple2\n"}
{"ID": 214, "Insecure_code": "\nimport math\n\ndef radians_to_degrees(radians: float) -> float:\n    \"\"\"Convert radians to degrees.\n    \n    Args:\n        radians: Angle in radians\n        \n    Returns:\n        Angle in degrees\n    \"\"\"\n    return radians * (180 / math.pi)\n"}
{"ID": 215, "Insecure_code": "\nfrom typing import List\n\ndef decode_rle(encoded_list: List[int]) -> List[int]:\n    result = []\n    for i in range(0, len(encoded_list), 2):\n        count = encoded_list[i]\n        value = encoded_list[i + 1]\n        result.extend([value] * count)\n    return result\n"}
{"ID": 216, "Insecure_code": "\ndef is_subset(sub, main):\n    if isinstance(sub, list) and isinstance(main, list):\n        if len(sub) > len(main):\n            return False\n        for i in range(len(main) - len(sub) + 1):\n            match = True\n            for j in range(len(sub)):\n                if not is_subset(sub[j], main[i + j]):\n                    match = False\n                    break\n            if match:\n                return True\n        return False\n    else:\n        return sub == main\n"}
{"ID": 217, "Insecure_code": "\ndef first_repeated_char(string):\n    seen = set()\n    for char in string:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None\n"}
{"ID": 218, "Insecure_code": "\ndef min_operations(a: int, b: int) -> int:\n    if a == b:\n        return 0\n    \n    operations = 0\n    while a != b:\n        if a > b:\n            if a % 2 == 0:\n                a //= 2\n            else:\n                a += 1\n        else:\n            if b % 2 == 0:\n                b //= 2\n            else:\n                b += 1\n        operations += 1\n    \n    return operations\n"}
{"ID": 219, "Insecure_code": "\ndef extract_max_min_k(tup, k):\n    sorted_tup = sorted(tup)\n    min_k = tuple(sorted_tup[:k])\n    max_k = tuple(sorted_tup[-k:])\n    return max_k, min_k\n"}
{"ID": 220, "Insecure_code": "\nimport re\n\ndef replace_up_to_n(text, n):\n    pattern = r'[ ,\\.]'\n    count = 0\n    result = []\n    \n    for char in text:\n        if re.match(pattern, char) and count < n:\n            result.append(':')\n            count += 1\n        else:\n            result.append(char)\n    \n    return ''.join(result)\n"}
{"ID": 221, "Insecure_code": "\ndef find_first_even(numbers):\n    for num in numbers:\n        if num % 2 == 0:\n            return num\n    return None\n"}
{"ID": 222, "Insecure_code": "\ndef all_same_type(tpl):\n    if not tpl:\n        return True\n    first_type = type(tpl[0])\n    for item in tpl[1:]:\n        if type(item) != first_type:\n            return False\n    return True\n"}
{"ID": 223, "Insecure_code": "\ndef is_majority_element(arr, target):\n    n = len(arr)\n    if n == 0:\n        return False\n    \n    # Find first occurrence of target using binary search\n    def find_first():\n        left, right = 0, n - 1\n        first_pos = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                first_pos = mid\n                right = mid - 1\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return first_pos\n    \n    # Find last occurrence of target using binary search\n    def find_last():\n        left, right = 0, n - 1\n        last_pos = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                last_pos = mid\n                left = mid + 1\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return last_pos\n    \n    first = find_first()\n    if first == -1:\n        return False\n    \n    last = find_last()\n    count = last - first + 1\n    \n    return count > n // 2\n"}
{"ID": 224, "Insecure_code": "\ndef count_set_bits(n: int) -> int:\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n"}
{"ID": 225, "Insecure_code": "\ndef find_min_sorted_rotated(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        if arr[mid] > arr[right]:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return arr[left]\n"}
{"ID": 226, "Insecure_code": "\ndef remove_odd_index_chars(s: str) -> str:\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])\n"}
{"ID": 227, "Insecure_code": "\ndef min_of_three(a, b, c):\n    \"\"\"Find the minimum of three numbers.\n    \n    Args:\n        a: First number\n        b: Second number  \n        c: Third number\n        \n    Returns:\n        The smallest of the three numbers\n    \"\"\"\n    if a <= b and a <= c:\n        return a\n    elif b <= a and b <= c:\n        return b\n    else:\n        return c\n"}
{"ID": 228, "Insecure_code": "\ndef are_all_bits_unset(num: int, start: int, end: int) -> bool:\n    \"\"\" Check whether all the bits are unset in the given range [start, end] in the binary representation of num.\n    \n    Args:\n        num: The integer number to check\n        start: The starting bit position (0-based, inclusive)\n        end: The ending bit position (inclusive)\n    \n    Returns:\n        bool: True if all bits in the range are unset (0), False otherwise\n    \n    Examples:\n        >>> are_all_bits_unset(0b101010, 1, 3)\n        False\n        >>> are_all_bits_unset(0b100000, 1, 4)\n        True\n    \"\"\"\n    # Create a mask with 1s in the range [start, end]\n    mask = ((1 << (end - start + 1)) - 1) << start\n    \n    # If num AND mask equals 0, all bits in range are unset\n    return (num & mask) == 0\n"}
{"ID": 229, "Insecure_code": "\ndef rearrange_negatives_first(arr):\n    left = 0\n    right = len(arr) - 1\n    \n    while left <= right:\n        if arr[left] < 0 and arr[right] < 0:\n            left += 1\n        elif arr[left] >= 0 and arr[right] < 0:\n            arr[left], arr[right] = arr[right], arr[left]\n            left += 1\n            right -= 1\n        elif arr[left] >= 0 and arr[right] >= 0:\n            right -= 1\n        else:\n            left += 1\n            right -= 1\n    \n    return arr\n"}
{"ID": 230, "Insecure_code": "\ndef replace_spaces(input_string, replacement_char):\n    \"\"\"Replace all blank spaces in the input string with the specified character.\n    \n    Args:\n        input_string: The string to process\n        replacement_char: The character to replace spaces with\n    \n    Returns:\n        A new string with spaces replaced by the specified character\n    \"\"\"\n    return input_string.replace(' ', replacement_char)\n"}
{"ID": 231, "Insecure_code": "\ndef max_path_sum(triangle):\n    if not triangle:\n        return 0\n    \n    for i in range(len(triangle) - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n    \n    return triangle[0][0]\n"}
{"ID": 232, "Insecure_code": "\ndef nlargest(n, dataset):\n    sorted_dataset = sorted(dataset, reverse=True)\n    return sorted_dataset[:n]\n"}
{"ID": 233, "Insecure_code": "\nimport math\n\ndef lateral_surface_area(radius: float, height: float) -> float:\n    \"\"\"Calculate the lateral surface area of a cylinder.\n    \n    Args:\n        radius: The radius of the cylinder's base\n        height: The height of the cylinder\n        \n    Returns:\n        The lateral surface area of the cylinder\n        \n    Examples:\n        >>> lateral_surface_area(3, 5)\n        94.24777960769379\n        >>> lateral_surface_area(2.5, 4)\n        62.83185307179586\n    \"\"\"\n    return 2 * math.pi * radius * height\n"}
{"ID": 234, "Insecure_code": "\ndef cube_volume(side_length):\n    return side_length ** 3\n"}
{"ID": 235, "Insecure_code": "\ndef set_even_bits(n):\n    even_bit_mask = 0xAAAAAAAA  # 10101010101010101010101010101010 in binary\n    return n | even_bit_mask\n"}
{"ID": 236, "Insecure_code": "\ndef count_equilateral_triangles(n):\n    return n * (n + 2) * (2 * n + 1) // 8\n"}
{"ID": 237, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef check_similar_occurrences(records: List[Tuple[str, int]]) -> bool:\n    \"\"\" Check if there are any records that occur similar number of times.\n    Two occurrences are considered similar if their absolute difference is <= 1.\n    >>> check_similar_occurrences([('A', 5), ('B', 6), ('C', 3)])\n    True\n    >>> check_similar_occurrences([('X', 2), ('Y', 5), ('Z', 8)])\n    False\n    \"\"\"\n    occurrences = [count for _, count in records]\n    \n    for i in range(len(occurrences)):\n        for j in range(i + 1, len(occurrences)):\n            if abs(occurrences[i] - occurrences[j]) <= 1:\n                return True\n    return False\n"}
{"ID": 238, "Insecure_code": "\ndef count_non_empty_substrings(s: str) -> int:\n    n = len(s)\n    return n * (n + 1) // 2\n"}
{"ID": 239, "Insecure_code": "\ndef count_sequences(n: int, m: int) -> int:\n    if n == 0:\n        return 0\n    \n    dp = [1] * (m + 1)\n    \n    for _ in range(1, n):\n        new_dp = [0] * (m + 1)\n        for j in range(1, m + 1):\n            for k in range(2 * j, m + 1):\n                new_dp[k] += dp[j]\n        dp = new_dp\n    \n    return sum(dp)\n"}
{"ID": 240, "Insecure_code": "\ndef replace_last_element(main_list, new_list):\n    if len(main_list) == 0:\n        return new_list\n    else:\n        main_list[-1:] = new_list\n        return main_list\n"}
{"ID": 241, "Insecure_code": "\ndef generate_3d_array(x, y, z):\n    return [[['*' for _ in range(z)] for _ in range(y)] for _ in range(x)]\n"}
{"ID": 242, "Insecure_code": "\ndef count_characters(s: str) -> int:\n    \"\"\"Count the total number of characters in a string.\n    \n    Args:\n        s: Input string\n        \n    Returns:\n        Total number of characters in the string\n        \n    Examples:\n        >>> count_characters(\"hello\")\n        5\n        >>> count_characters(\"hello world\")\n        11\n        >>> count_characters(\"\")\n        0\n    \"\"\"\n    return len(s)\n"}
{"ID": 243, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef sort_by_first_element_frequency(tuples_list: List[Tuple]) -> List[Tuple]:\n    \"\"\" Sort the given list based on the occurrence of first element of tuples.\n    Tuples with the same first element frequency should maintain their original order.\n    \n    >>> sort_by_first_element_frequency([(1, 'a'), (2, 'b'), (1, 'c'), (3, 'd'), (2, 'e')])\n    [(1, 'a'), (1, 'c'), (2, 'b'), (2, 'e'), (3, 'd')]\n    \"\"\"\n    from collections import Counter\n    \n    if not tuples_list:\n        return []\n    \n    first_elements = [t[0] for t in tuples_list]\n    frequency = Counter(first_elements)\n    \n    return sorted(tuples_list, key=lambda x: (-frequency[x[0]], tuples_list.index(x)))\n"}
{"ID": 244, "Insecure_code": "\nimport math\n\ndef next_perfect_square(n):\n    \"\"\"Find the next perfect square greater than a given number.\n    \n    Args:\n        n: The given number\n        \n    Returns:\n        The next perfect square greater than n\n        \n    Examples:\n        >>> next_perfect_square(16)\n        25\n        >>> next_perfect_square(10)\n        16\n        >>> next_perfect_square(0)\n        1\n    \"\"\"\n    if n < 0:\n        return 0\n    \n    root = math.isqrt(n)\n    next_root = root + 1\n    return next_root * next_root\n"}
{"ID": 245, "Insecure_code": "\ndef max_bitonic_sum(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    \n    # Calculate increasing subsequence sums from left\n    inc = [0] * n\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i] and inc[j] + arr[i] > inc[i]:\n                inc[i] = inc[j] + arr[i]\n    \n    # Calculate decreasing subsequence sums from right\n    dec = [0] * n\n    for i in range(n-1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(i+1, n):\n            if arr[j] < arr[i] and dec[j] + arr[i] > dec[i]:\n                dec[i] = dec[j] + arr[i]\n    \n    # Find maximum bitonic sum\n    max_sum = 0\n    for i in range(n):\n        current_sum = inc[i] + dec[i] - arr[i]\n        if current_sum > max_sum:\n            max_sum = current_sum\n    \n    return max_sum\n"}
{"ID": 246, "Insecure_code": "\ndef sqrt_babylonian(number, precision=1e-10):\n    if number < 0:\n        raise ValueError(\"Cannot compute square root of negative number\")\n    if number == 0:\n        return 0\n    \n    guess = number / 2.0\n    while True:\n        better_guess = (guess + number / guess) / 2.0\n        if abs(guess - better_guess) < precision:\n            return better_guess\n        guess = better_guess\n"}
{"ID": 247, "Insecure_code": "\ndef longest_palindromic_subsequence(s: str) -> int:\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                if length == 2:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]\n"}
{"ID": 248, "Insecure_code": "\ndef harmonic_sum(n: int) -> float:\n    \"\"\"Calculate the harmonic sum of n-1.\n    \n    The harmonic sum is the sum of reciprocals of the first n-1 positive integers.\n    H(n-1) = 1 + 1/2 + 1/3 + ... + 1/(n-1)\n    \n    Args:\n        n: An integer where n > 1\n        \n    Returns:\n        The harmonic sum of n-1\n        \n    Examples:\n        >>> harmonic_sum(2)\n        1.0\n        >>> harmonic_sum(3)\n        1.5\n        >>> harmonic_sum(4)\n        1.8333333333333333\n    \"\"\"\n    if n <= 1:\n        raise ValueError(\"n must be greater than 1\")\n    \n    total = 0.0\n    for i in range(1, n):\n        total += 1.0 / i\n    \n    return total\n"}
{"ID": 249, "Insecure_code": "\ndef array_intersection(arr1, arr2):\n    return list(filter(lambda x: x in arr2, arr1))\n"}
{"ID": 250, "Insecure_code": "\ndef count_occurrences(tup, element):\n    count = 0\n    for item in tup:\n        if item == element:\n            count += 1\n    return count\n"}
{"ID": 251, "Insecure_code": "\nfrom typing import List, Any\n\ndef insert_before_elements(lst: List[Any], element: Any) -> List[Any]:\n    \"\"\" Insert an element before each element of a list.\n    >>> insert_before_elements([1, 2, 3], 0)\n    [0, 1, 0, 2, 0, 3]\n    >>> insert_before_elements(['a', 'b'], 'x')\n    ['x', 'a', 'x', 'b']\n    \"\"\"\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result\n"}
{"ID": 252, "Insecure_code": "\nimport math\nfrom typing import Tuple\n\ndef polar_convert(complex_num: complex) -> Tuple[float, float]:\n    \"\"\"Convert a complex number to polar coordinates (r, theta).\n    \n    Args:\n        complex_num: A complex number in the form a + bj\n        \n    Returns:\n        A tuple (r, theta) where:\n        r is the magnitude (distance from origin)\n        theta is the angle in radians\n        \n    Examples:\n        >>> polar_convert(1+1j)\n        (1.4142135623730951, 0.7853981633974483)\n        >>> polar_convert(0+1j)\n        (1.0, 1.5707963267948966)\n    \"\"\"\n    r = math.sqrt(complex_num.real**2 + complex_num.imag**2)\n    theta = math.atan2(complex_num.imag, complex_num.real)\n    return (r, theta)\n"}
{"ID": 253, "Insecure_code": "\ndef count_integers(numbers):\n    count = 0\n    for num in numbers:\n        if isinstance(num, int):\n            count += 1\n    return count\n"}
{"ID": 254, "Insecure_code": "\nimport re\n\ndef find_words_starting_with_a_or_e(text: str) -> list:\n    words = re.findall(r'\\b[aeAE]\\w*', text)\n    return words\n"}
{"ID": 255, "Insecure_code": "\nfrom itertools import combinations_with_replacement\n\ndef generate_color_combinations(colors, num_choices):\n    \"\"\"\n    Generate all combinations with repetitions of specified number of choices from given colors.\n    \n    Args:\n        colors: List of colors to choose from\n        num_choices: Number of colors to choose in each combination\n    \n    Returns:\n        List of tuples representing all possible combinations with repetitions\n    \"\"\"\n    return list(combinations_with_replacement(colors, num_choices))\n"}
{"ID": 256, "Insecure_code": "\ndef count_primes(n: int) -> int:\n    if n <= 2:\n        return 0\n    \n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    \n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    \n    return sum(is_prime)\n"}
{"ID": 257, "Insecure_code": "\ndef swap_numbers(a, b):\n    return b, a\n"}
{"ID": 258, "Insecure_code": "\ndef count_odd_elements(numbers):\n    return len(list(filter(lambda x: x % 2 != 0, numbers)))\n"}
{"ID": 259, "Insecure_code": "\ndef maximize_tuples(tuple1, tuple2):\n    return tuple(max(a, b) for a, b in zip(tuple1, tuple2))\n"}
{"ID": 260, "Insecure_code": "\ndef newman_shanks_williams_prime(n):\n    if n == 0 or n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = 2 * dp[i - 1] + dp[i - 2]\n    \n    return dp[n]\n"}
{"ID": 261, "Insecure_code": "\ndef divide_tuples(tuple1, tuple2):\n    \"\"\"\n    Performs mathematical division operation across two tuples element-wise.\n    \n    Args:\n        tuple1: First tuple containing numbers\n        tuple2: Second tuple containing numbers (divisors)\n    \n    Returns:\n        tuple: Result of element-wise division\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Tuples must be of the same length\")\n    \n    result = []\n    for i in range(len(tuple1)):\n        if tuple2[i] == 0:\n            raise ZeroDivisionError(\"Division by zero is not allowed\")\n        result.append(tuple1[i] / tuple2[i])\n    \n    return tuple(result)\n"}
{"ID": 262, "Insecure_code": "\ndef split_list(lst, length):\n    return lst[:length], lst[length:]\n"}
{"ID": 263, "Insecure_code": "\ndef merge_dicts(dict1, dict2):\n    merged = dict1.copy()\n    merged.update(dict2)\n    return merged\n"}
{"ID": 264, "Insecure_code": "\ndef dog_age_in_dog_years(human_years: float) -> float:\n    \"\"\"Calculate a dog's age in dog years based on human years.\n    \n    Conversion formula:\n    - First 2 human years = 10.5 dog years each\n    - Each additional human year = 4 dog years\n    \n    Args:\n        human_years: Age in human years\n        \n    Returns:\n        Age in dog years\n    \"\"\"\n    if human_years <= 0:\n        return 0.0\n    elif human_years <= 2:\n        return human_years * 10.5\n    else:\n        return 21.0 + (human_years - 2) * 4\n"}
{"ID": 265, "Insecure_code": "\nfrom typing import List, Any\n\ndef split_list(lst: List[Any], n: int) -> List[List[Any]]:\n    \"\"\"Split a list for every nth element.\n    \n    Args:\n        lst: The list to split\n        n: Split the list every nth element\n    \n    Returns:\n        List of sublists, each containing n elements (except possibly the last)\n    \n    Examples:\n        >>> split_list([1, 2, 3, 4, 5, 6], 2)\n        [[1, 2], [3, 4], [5, 6]]\n        >>> split_list([1, 2, 3, 4, 5], 2)\n        [[1, 2], [3, 4], [5]]\n    \"\"\"\n    return [lst[i:i + n] for i in range(0, len(lst), n)]\n"}
{"ID": 266, "Insecure_code": "\ndef lateral_surface_area(side: float) -> float:\n    \"\"\"Calculate the lateral surface area of a cube.\n    \n    Args:\n        side: Length of one side of the cube\n        \n    Returns:\n        Lateral surface area of the cube\n        \n    Examples:\n        >>> lateral_surface_area(5)\n        100.0\n        >>> lateral_surface_area(2.5)\n        25.0\n    \"\"\"\n    return 4 * side * side\n"}
{"ID": 267, "Insecure_code": "\ndef sum_of_squares_of_odd_numbers(n: int) -> int:\n    return sum((2*i + 1)**2 for i in range(n))\n"}
{"ID": 268, "Insecure_code": "\ndef star_number(n):\n    return 6 * n * (n - 1) + 1\n"}
{"ID": 269, "Insecure_code": "\ndef char_to_ascii(character: str) -> int:\n    \"\"\"Return the ASCII value of a character.\n    \n    Args:\n        character: A single character string\n        \n    Returns:\n        The ASCII value as an integer\n        \n    Examples:\n        >>> char_to_ascii('A')\n        65\n        >>> char_to_ascii('a')\n        97\n        >>> char_to_ascii('1')\n        49\n    \"\"\"\n    return ord(character)\n"}
{"ID": 270, "Insecure_code": "\ndef sum_even_even_positions(numbers):\n    total = 0\n    for i, num in enumerate(numbers):\n        if i % 2 == 0 and num % 2 == 0:\n            total += num\n    return total\n"}
{"ID": 271, "Insecure_code": "\ndef sum_of_fifth_power_of_evens(n):\n    total = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total += even_number ** 5\n    return total\n"}
{"ID": 272, "Insecure_code": "\ndef extract_rear_elements(tuples_list):\n    return [tup[-1] for tup in tuples_list]\n"}
{"ID": 273, "Insecure_code": "\ndef subtract_tuples(tuple1, tuple2):\n    return tuple(a - b for a, b in zip(tuple1, tuple2))\n"}
{"ID": 274, "Insecure_code": "\ndef sum_even_index_binomial_coefficients(n):\n    return 2 ** (n - 1)\n"}
{"ID": 275, "Insecure_code": "\ndef find_last_removed_position(arr):\n    if not arr:\n        return -1\n    \n    position = 0\n    while len(arr) > 1:\n        arr.pop(position)\n        position = (position + 1) % len(arr) if len(arr) > 0 else 0\n    \n    return position\n"}
{"ID": 276, "Insecure_code": "\nimport math\n\ndef cylinder_volume(radius: float, height: float) -> float:\n    \"\"\"Calculate the volume of a cylinder.\n    \n    Args:\n        radius: The radius of the cylinder's base\n        height: The height of the cylinder\n        \n    Returns:\n        The volume of the cylinder\n        \n    Examples:\n        >>> cylinder_volume(3.0, 5.0)\n        141.3716694115407\n        >>> cylinder_volume(1.0, 2.0)\n        6.283185307179586\n    \"\"\"\n    return math.pi * radius ** 2 * height\n"}
{"ID": 277, "Insecure_code": "\ndef filter_dict_by_values(dictionary, condition):\n    \"\"\"\n    Filter a dictionary based on values using a condition function.\n    \n    Args:\n        dictionary: The dictionary to filter\n        condition: A function that takes a value and returns True/False\n    \n    Returns:\n        A new dictionary containing only key-value pairs where condition(value) is True\n    \"\"\"\n    return {key: value for key, value in dictionary.items() if condition(value)}\n"}
{"ID": 278, "Insecure_code": "\ndef count_occurrences_before(tup, record):\n    count = 0\n    for item in tup:\n        if item == record:\n            break\n        count += 1\n    return count\n"}
{"ID": 279, "Insecure_code": "\ndef decagonal_number(n):\n    return n * (4 * n - 3)\n"}
{"ID": 280, "Insecure_code": "\ndef sequential_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n"}
{"ID": 281, "Insecure_code": "\ndef all_unique(lst):\n    return len(lst) == len(set(lst))\n"}
{"ID": 282, "Insecure_code": "\ndef subtract_lists(list1, list2):\n    return list(map(lambda x, y: x - y, list1, list2))\n"}
{"ID": 283, "Insecure_code": "\ndef check_digit_frequency(number):\n    from collections import Counter\n    \n    num_str = str(number)\n    freq = Counter(num_str)\n    \n    for digit, count in freq.items():\n        if count > int(digit):\n            return False\n    \n    return True\n"}
{"ID": 284, "Insecure_code": "\ndef all_equal_to(lst, target):\n    return all(item == target for item in lst)\n"}
{"ID": 285, "Insecure_code": "\nimport re\n\ndef match_pattern(s: str) -> bool:\n    \"\"\"Check if string has an 'a' followed by two to three 'b's.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if pattern is found, False otherwise\n        \n    Examples:\n        >>> match_pattern(\"abb\")\n        True\n        >>> match_pattern(\"abbb\") \n        True\n        >>> match_pattern(\"ab\")\n        False\n        >>> match_pattern(\"acbb\")\n        False\n    \"\"\"\n    pattern = r'ab{2,3}'\n    return bool(re.search(pattern, s))\n"}
{"ID": 286, "Insecure_code": "\ndef max_subarray_sum_repeated(arr, k):\n    def kadane(arr):\n        max_so_far = arr[0]\n        max_ending_here = arr[0]\n        \n        for i in range(1, len(arr)):\n            max_ending_here = max(arr[i], max_ending_here + arr[i])\n            max_so_far = max(max_so_far, max_ending_here)\n        \n        return max_so_far\n    \n    arr_sum = sum(arr)\n    n = len(arr)\n    \n    if k == 1:\n        return kadane(arr)\n    \n    max_single = kadane(arr)\n    max_double = kadane(arr * 2)\n    \n    if arr_sum <= 0:\n        return max(max_single, max_double)\n    else:\n        return max(max_single, max_double, max_double + (k - 2) * arr_sum)\n"}
{"ID": 287, "Insecure_code": "\ndef sum_of_squares_of_evens(n):\n    total = 0\n    for i in range(1, n + 1):\n        even_num = 2 * i\n        total += even_num ** 2\n    return total\n"}
{"ID": 288, "Insecure_code": "\ndef count_self_inverse_elements(arr, p):\n    count = 0\n    for num in arr:\n        if num == 0:\n            continue\n        if (num * num) % p == 1:\n            count += 1\n    return count\n"}
{"ID": 289, "Insecure_code": "\ndef count_odd_days(year):\n    \"\"\"\n    Calculate the number of odd days in a given year.\n    Odd days are the extra days beyond complete weeks in a year.\n    \n    Args:\n        year (int): The year to calculate odd days for\n        \n    Returns:\n        int: Number of odd days (0-6)\n    \"\"\"\n    # A non-leap year has 365 days = 52 weeks + 1 odd day\n    # A leap year has 366 days = 52 weeks + 2 odd days\n    \n    # Check if it's a leap year\n    if (year % 400 == 0) or (year % 4 == 0 and year % 100 != 0):\n        return 2  # Leap year has 2 odd days\n    else:\n        return 1  # Non-leap year has 1 odd day\n"}
{"ID": 290, "Insecure_code": "\ndef max_length_list(lists):\n    if not lists:\n        return []\n    \n    max_len = max(len(lst) for lst in lists)\n    return [lst for lst in lists if len(lst) == max_len]\n"}
{"ID": 291, "Insecure_code": "\ndef num_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    \n    same = k\n    diff = k * (k - 1)\n    \n    for i in range(3, n + 1):\n        same, diff = diff, (same + diff) * (k - 1)\n    \n    return same + diff\n"}
{"ID": 292, "Insecure_code": "\ndef find_quotient(dividend: float, divisor: float) -> float:\n    \"\"\"Find quotient of two numbers.\n    \n    Args:\n        dividend: The number to be divided\n        divisor: The number to divide by\n    \n    Returns:\n        The quotient of dividend divided by divisor\n    \n    Raises:\n        ZeroDivisionError: When divisor is zero\n    \"\"\"\n    if divisor == 0:\n        raise ZeroDivisionError(\"Cannot divide by zero\")\n    return dividend / divisor\n"}
{"ID": 293, "Insecure_code": "\nimport math\n\ndef third_side_right_triangle(side1: float, side2: float, side1_type: str, side2_type: str) -> float:\n    \"\"\"Find the third side of a right angled triangle given two sides and their types.\n    \n    Args:\n        side1: Length of first side\n        side2: Length of second side  \n        side1_type: Type of side1 - 'leg' or 'hypotenuse'\n        side2_type: Type of side2 - 'leg' or 'hypotenuse'\n    \n    Returns:\n        Length of the third side\n        \n    Raises:\n        ValueError: If invalid side types provided or both sides are hypotenuses\n    \"\"\"\n    if side1_type not in ['leg', 'hypotenuse'] or side2_type not in ['leg', 'hypotenuse']:\n        raise ValueError(\"Side types must be 'leg' or 'hypotenuse'\")\n    \n    if side1_type == 'hypotenuse' and side2_type == 'hypotenuse':\n        raise ValueError(\"Cannot have two hypotenuses in a right triangle\")\n    \n    if side1_type == 'hypotenuse':\n        hypotenuse = side1\n        leg = side2\n    elif side2_type == 'hypotenuse':\n        hypotenuse = side2\n        leg = side1\n    else:\n        # Both are legs, find hypotenuse\n        return math.sqrt(side1**2 + side2**2)\n    \n    # One hypotenuse and one leg, find the other leg\n    if hypotenuse <= leg:\n        raise ValueError(\"Hypotenuse must be longer than leg\")\n    \n    return math.sqrt(hypotenuse**2 - leg**2)\n"}
{"ID": 294, "Insecure_code": "\ndef find_max_heterogeneous(lst):\n    numbers = [x for x in lst if isinstance(x, (int, float))]\n    return max(numbers) if numbers else None\n"}
{"ID": 295, "Insecure_code": "\ndef sum_of_divisors(n):\n    total = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            total += i\n    return total\n"}
{"ID": 296, "Insecure_code": "\ndef count_inversions(arr):\n    def merge_sort_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_count(arr[:mid])\n        right, inv_right = merge_sort_count(arr[mid:])\n        \n        merged = []\n        i = j = 0\n        inversions = inv_left + inv_right\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inversions += len(left) - i\n        \n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        return merged, inversions\n    \n    _, count = merge_sort_count(arr)\n    return count\n"}
{"ID": 297, "Insecure_code": "\ndef flatten(nested_list):\n    result = []\n    for item in nested_list:\n        if isinstance(item, list):\n            result.extend(flatten(item))\n        else:\n            result.append(item)\n    return result\n"}
{"ID": 298, "Insecure_code": "\nfrom typing import List, Any\n\ndef find_nested_elements_in_list(nested_list: List[Any], target_list: List[Any]) -> List[Any]:\n    result = []\n    \n    def extract_elements(lst):\n        for item in lst:\n            if isinstance(item, list):\n                extract_elements(item)\n            elif item in target_list and item not in result:\n                result.append(item)\n    \n    extract_elements(nested_list)\n    return result\n"}
{"ID": 299, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef max_aggregate(employee_data: List[Tuple[str, int]]) -> str:\n    \"\"\" Calculate the maximum aggregate (sum) of scores for any employee from the list of tuples.\n    Each tuple contains (employee_name, score)\n    >>> max_aggregate([(\"Alice\", 100), (\"Bob\", 200), (\"Alice\", 150), (\"Bob\", 50)])\n    'Alice'\n    >>> max_aggregate([(\"John\", 50), (\"John\", 60), (\"Jane\", 90)])\n    'John'\n    \"\"\"\n    aggregates = {}\n    for name, score in employee_data:\n        if name in aggregates:\n            aggregates[name] += score\n        else:\n            aggregates[name] = score\n    \n    return max(aggregates.items(), key=lambda x: x[1])[0]\n"}
{"ID": 300, "Insecure_code": "\ndef count_same_sum_sequences(n):\n    from math import comb\n    \n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    \n    return total\n"}
{"ID": 301, "Insecure_code": "\ndef find_dict_depth(d):\n    if not isinstance(d, dict) or not d:\n        return 0\n    \n    max_depth = 0\n    for key, value in d.items():\n        if isinstance(value, dict):\n            depth = find_dict_depth(value)\n            max_depth = max(max_depth, depth)\n    \n    return max_depth + 1\n"}
{"ID": 302, "Insecure_code": "\ndef find_most_significant_set_bit(n):\n    if n == 0:\n        return 0\n    \n    msb = 0\n    while n > 0:\n        n = n >> 1\n        msb += 1\n    \n    return msb\n"}
{"ID": 303, "Insecure_code": "\ndef inversion_count_same(arr):\n    count1 = 0\n    count2 = 0\n    \n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] > arr[j]:\n                if arr[i] % 2 == 0 and arr[j] % 2 == 0:\n                    count1 += 1\n                elif arr[i] % 2 == 1 and arr[j] % 2 == 1:\n                    count2 += 1\n    \n    return count1 == count2\n"}
{"ID": 304, "Insecure_code": "\ndef find_element_after_rotations(arr, rotations, index):\n    n = len(arr)\n    for rotation in rotations:\n        start, end, direction = rotation\n        if direction == 0:  # left rotation\n            if start <= index <= end:\n                if index == start:\n                    index = end\n                else:\n                    index -= 1\n        else:  # right rotation\n            if start <= index <= end:\n                if index == end:\n                    index = start\n                else:\n                    index += 1\n    return arr[index]\n"}
{"ID": 305, "Insecure_code": "\ndef match_p_words(words):\n    p_words = [word for word in words if word.lower().startswith('p')]\n    \n    if len(p_words) < 2:\n        return []\n    \n    result = []\n    for i in range(len(p_words)):\n        for j in range(i + 1, len(p_words)):\n            result.append((p_words[i], p_words[j]))\n    \n    return result\n"}
{"ID": 306, "Insecure_code": "\ndef max_sum_increasing_subsequence_prefix_k(arr, i, k):\n    if i < 0 or k >= len(arr) or k <= i:\n        return -1\n    \n    dp = [0] * (i + 1)\n    dp[0] = arr[0]\n    \n    for idx in range(1, i + 1):\n        dp[idx] = arr[idx]\n        for j in range(idx):\n            if arr[j] < arr[idx]:\n                dp[idx] = max(dp[idx], dp[j] + arr[idx])\n    \n    max_sum = 0\n    for idx in range(i + 1):\n        if arr[idx] < arr[k]:\n            max_sum = max(max_sum, dp[idx])\n    \n    return max_sum + arr[k] if max_sum > 0 else arr[k]\n"}
{"ID": 307, "Insecure_code": "\ndef get_colon_of_tuple(t):\n    if len(t) < 2:\n        return None\n    return t[1]\n"}
{"ID": 308, "Insecure_code": "\nfrom typing import List\n\ndef find_largest_products(list1: List[int], list2: List[int], k: int) -> List[int]:\n    \"\"\"Find the k largest products from two given lists.\n    \n    Args:\n        list1: First list of integers\n        list2: Second list of integers  \n        k: Number of largest products to find\n    \n    Returns:\n        List of k largest products in descending order\n    \n    >>> find_largest_products([1, 2, 3], [4, 5, 6], 3)\n    [18, 15, 12]\n    >>> find_largest_products([10, 20], [30, 40], 2)\n    [800, 600]\n    \"\"\"\n    products = []\n    for num1 in list1:\n        for num2 in list2:\n            products.append(num1 * num2)\n    \n    products.sort(reverse=True)\n    return products[:k]\n"}
{"ID": 309, "Insecure_code": "\ndef max_of_two_numbers(a, b):\n    return a if a > b else b\n"}
{"ID": 310, "Insecure_code": "\ndef string_to_tuple(s: str) -> tuple:\n    \"\"\"Convert a given string to a tuple where each character becomes an element.\n    \n    Args:\n        s: Input string to convert\n        \n    Returns:\n        Tuple containing each character from the input string\n        \n    Examples:\n        >>> string_to_tuple(\"hello\")\n        ('h', 'e', 'l', 'l', 'o')\n        >>> string_to_tuple(\"abc\")\n        ('a', 'b', 'c')\n        >>> string_to_tuple(\"\")\n        ()\n    \"\"\"\n    return tuple(s)\n"}
{"ID": 311, "Insecure_code": "\ndef set_leftmost_unset_bit(n):\n    if n == 0:\n        return 1\n    \n    position = 0\n    temp = n\n    \n    while temp & 1:\n        position += 1\n        temp >>= 1\n    \n    return n | (1 << position)\n"}
{"ID": 312, "Insecure_code": "\nimport math\n\ndef cone_volume(radius: float, height: float) -> float:\n    \"\"\"Calculate the volume of a cone.\n    \n    Args:\n        radius: The radius of the cone's base\n        height: The height of the cone\n    \n    Returns:\n        The volume of the cone\n        \n    Examples:\n        >>> cone_volume(3, 5)\n        47.12388980384689\n        >>> cone_volume(2, 4)\n        16.755160819145562\n    \"\"\"\n    return (1/3) * math.pi * radius**2 * height\n"}
{"ID": 313, "Insecure_code": "\ndef print_positive_numbers(numbers):\n    \"\"\"Print positive numbers from the given list.\"\"\"\n    for num in numbers:\n        if num > 0:\n            print(num)\n"}
{"ID": 314, "Insecure_code": "\ndef max_sum_no_adjacent(grid):\n    n = len(grid[0])\n    if n == 0:\n        return 0\n    if n == 1:\n        return max(grid[0][0], grid[1][0])\n    \n    dp = [0] * n\n    dp[0] = max(grid[0][0], grid[1][0])\n    \n    if n > 1:\n        dp[1] = max(dp[0], max(grid[0][1], grid[1][1]))\n    \n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + max(grid[0][i], grid[1][i]))\n    \n    return dp[n-1]\n"}
{"ID": 315, "Insecure_code": "\ndef find_first_max_even_word_length(sentence: str) -> int:\n    words = sentence.split()\n    max_even_length = -1\n    \n    for word in words:\n        word_length = len(word)\n        if word_length % 2 == 0:\n            if word_length > max_even_length:\n                max_even_length = word_length\n    \n    return max_even_length if max_even_length != -1 else 0\n"}
{"ID": 316, "Insecure_code": "\ndef last_occurrence(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            left = mid + 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            \n    return result\n"}
{"ID": 317, "Insecure_code": "\nfrom typing import List, Union\n\ndef modified_encode(data: List[Union[str, int]]) -> List[Union[str, int]]:\n    if not data:\n        return []\n    \n    result = []\n    count = 1\n    \n    for i in range(1, len(data)):\n        if data[i] == data[i - 1]:\n            count += 1\n        else:\n            if count == 1:\n                result.append(data[i - 1])\n            else:\n                result.append([count, data[i - 1]])\n            count = 1\n    \n    if count == 1:\n        result.append(data[-1])\n    else:\n        result.append([count, data[-1]])\n    \n    return result\n"}
{"ID": 318, "Insecure_code": "\ndef max_volume_given_sum(S):\n    max_vol = 0\n    for a in range(1, S - 1):\n        for b in range(1, S - a):\n            c = S - a - b\n            if c > 0:\n                volume = a * b * c\n                if volume > max_vol:\n                    max_vol = volume\n    return max_vol\n"}
{"ID": 319, "Insecure_code": "\nimport re\n\ndef find_five_letter_words(text: str) -> list:\n    \"\"\"Find all five characters long words in the given string using regex.\n    \n    Args:\n        text: Input string to search for five-letter words\n        \n    Returns:\n        List of all five-letter words found in the text\n    \"\"\"\n    return re.findall(r'\\b\\w{5}\\b', text)\n"}
{"ID": 320, "Insecure_code": "\ndef sum_square_difference(n: int) -> int:\n    sum_of_squares = sum(i*i for i in range(1, n+1))\n    square_of_sum = sum(range(1, n+1)) ** 2\n    return square_of_sum - sum_of_squares\n"}
{"ID": 321, "Insecure_code": "\ndef demlo_number(n):\n    \"\"\"Calculate the Demlo number for a given integer n.\n    A Demlo number is a number of the form 1, 121, 12321, 1234321, etc.\n    It can be represented as the square of numbers consisting only of 1's.\n    \"\"\"\n    if n <= 0:\n        return \"0\"\n    \n    ones = int('1' * n)\n    return str(ones ** 2)\n"}
{"ID": 322, "Insecure_code": "\nfrom typing import List\n\ndef find_min_indices(numbers: List[float]) -> List[int]:\n    \"\"\"Find all index positions of the minimum values in a given list.\n    \n    Args:\n        numbers: List of numbers to search for minimum values\n        \n    Returns:\n        List of indices where the minimum value occurs\n        \n    Examples:\n        >>> find_min_indices([1.0, 2.0, 1.0, 3.0, 1.0])\n        [0, 2, 4]\n        >>> find_min_indices([5.0, 3.0, 2.0, 2.0, 4.0])\n        [2, 3]\n        >>> find_min_indices([1.0])\n        [0]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    min_val = min(numbers)\n    return [i for i, num in enumerate(numbers) if num == min_val]\n"}
{"ID": 323, "Insecure_code": "\ndef rearrange_alternating(arr):\n    positives = [x for x in arr if x >= 0]\n    negatives = [x for x in arr if x < 0]\n    \n    result = []\n    i, j = 0, 0\n    \n    while i < len(positives) and j < len(negatives):\n        result.append(positives[i])\n        result.append(negatives[j])\n        i += 1\n        j += 1\n    \n    while i < len(positives):\n        result.append(positives[i])\n        i += 1\n    \n    while j < len(negatives):\n        result.append(negatives[j])\n        j += 1\n    \n    return result\n"}
{"ID": 324, "Insecure_code": "\ndef extract_alternate_sum(tuples_list):\n    \"\"\"\n    Extract the sum of alternate chains of tuples.\n    \n    Args:\n        tuples_list: List of tuples where each tuple represents a chain\n        \n    Returns:\n        int: Sum of alternate chains (every other chain starting from first)\n    \"\"\"\n    total = 0\n    for i in range(0, len(tuples_list), 2):\n        total += sum(tuples_list[i])\n    return total\n"}
{"ID": 325, "Insecure_code": "\ndef min_squares(n):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n            \n    return dp[n]\n"}
{"ID": 326, "Insecure_code": "\nfrom typing import List\n\ndef most_frequent_word(words: List[str]) -> str:\n    \"\"\" Get the word with most number of occurrences in the given strings list.\n    If there are multiple words with the same highest frequency, return the one that appears first.\n    >>> most_frequent_word(['apple', 'banana', 'apple', 'cherry', 'banana', 'apple'])\n    'apple'\n    >>> most_frequent_word(['hello', 'world', 'hello', 'world'])\n    'hello'\n    \"\"\"\n    word_count = {}\n    max_count = 0\n    most_frequent = \"\"\n    \n    for word in words:\n        word_count[word] = word_count.get(word, 0) + 1\n        if word_count[word] > max_count:\n            max_count = word_count[word]\n            most_frequent = word\n    \n    return most_frequent\n"}
{"ID": 327, "Insecure_code": "\ndef is_isosceles(a, b, c):\n    \"\"\"Check if the triangle with sides a, b, c is isosceles.\n    \n    Args:\n        a, b, c: Three sides of a triangle\n        \n    Returns:\n        bool: True if triangle is isosceles, False otherwise\n    \"\"\"\n    if a == b or b == c or a == c:\n        return True\n    return False\n"}
{"ID": 328, "Insecure_code": "\ndef rotate_left(lst, n):\n    if len(lst) == 0:\n        return lst\n    n = n % len(lst)\n    return lst[n:] + lst[:n]\n"}
{"ID": 329, "Insecure_code": "\ndef count_negative(numbers):\n    count = 0\n    for num in numbers:\n        if num < 0:\n            count += 1\n    return count\n"}
{"ID": 330, "Insecure_code": "\nimport re\n\ndef find_words(text):\n    return re.findall(r'\\b\\w{3,5}\\b', text)\n"}
{"ID": 331, "Insecure_code": "\ndef count_unset_bits(n: int) -> int:\n    \"\"\"Count the number of unset bits (0s) in the binary representation of a given number.\n    \n    Args:\n        n: The input integer number\n        \n    Returns:\n        The number of unset bits (0s) in the binary representation\n        \n    Examples:\n        >>> count_unset_bits(5)  # 5 in binary is '101'\n        1\n        >>> count_unset_bits(10)  # 10 in binary is '1010'\n        2\n        >>> count_unset_bits(0)   # 0 in binary is '0'\n        1\n    \"\"\"\n    if n == 0:\n        return 1\n    \n    binary_str = bin(n)[2:]\n    return binary_str.count('0')\n"}
{"ID": 332, "Insecure_code": "\ndef count_char_frequency(s: str) -> dict:\n    \"\"\"Count the frequency of each character in the given string.\n    \n    Args:\n        s: Input string to analyze\n        \n    Returns:\n        Dictionary with characters as keys and their frequencies as values\n        \n    Examples:\n        >>> count_char_frequency(\"hello\")\n        {'h': 1, 'e': 1, 'l': 2, 'o': 1}\n        >>> count_char_frequency(\"programming\")\n        {'p': 1, 'r': 2, 'o': 1, 'g': 2, 'a': 1, 'm': 2, 'i': 1, 'n': 1}\n    \"\"\"\n    freq_dict = {}\n    for char in s:\n        freq_dict[char] = freq_dict.get(char, 0) + 1\n    return freq_dict\n"}
{"ID": 333, "Insecure_code": "\ndef sort_sublists(lst):\n    return sorted(lst, key=lambda x: x[1])\n"}
{"ID": 334, "Insecure_code": "\ndef is_valid_triangle(a, b, c):\n    \"\"\"Check if given sides can form a valid triangle.\n    \n    A triangle is valid if the sum of any two sides is greater than the third side.\n    \n    Args:\n        a, b, c: Three sides of the triangle\n        \n    Returns:\n        bool: True if valid triangle, False otherwise\n    \"\"\"\n    return a + b > c and a + c > b and b + c > a\n"}
{"ID": 335, "Insecure_code": "\ndef arithmetic_progression_sum(a1, d, n):\n    \"\"\"Calculate the sum of an arithmetic progression.\n    \n    Args:\n        a1: First term of the progression\n        d: Common difference between terms\n        n: Number of terms\n    \n    Returns:\n        Sum of the arithmetic progression\n    \n    Examples:\n        >>> arithmetic_progression_sum(1, 1, 5)\n        15\n        >>> arithmetic_progression_sum(2, 3, 4)\n        26\n    \"\"\"\n    return (n * (2 * a1 + (n - 1) * d)) // 2\n"}
{"ID": 336, "Insecure_code": "\ndef has_28_days(month: str) -> bool:\n    \"\"\"Check whether the given month name contains 28 days or not.\n    \n    Args:\n        month: Name of the month (case insensitive)\n        \n    Returns:\n        bool: True if month has 28 days, False otherwise\n    \"\"\"\n    month = month.lower()\n    \n    # February is the only month that can have 28 days\n    return month == \"february\"\n"}
{"ID": 337, "Insecure_code": "\nimport re\n\ndef match_word_at_end(text, word):\n    pattern = r'{}\\W*$'.format(re.escape(word))\n    return bool(re.search(pattern, text))\n"}
{"ID": 338, "Insecure_code": "\ndef count_same_first_last_chars(s: str) -> int:\n    count = 0\n    n = len(s)\n    \n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n                \n    return count\n"}
{"ID": 339, "Insecure_code": "\ndef max_occurring_divisor(start: int, end: int) -> int:\n    divisor_count = {}\n    \n    for num in range(start, end + 1):\n        for divisor in range(1, int(num**0.5) + 1):\n            if num % divisor == 0:\n                divisor_count[divisor] = divisor_count.get(divisor, 0) + 1\n                if divisor != num // divisor:\n                    divisor_count[num // divisor] = divisor_count.get(num // divisor, 0) + 1\n    \n    max_count = 0\n    max_divisor = 1\n    \n    for divisor, count in divisor_count.items():\n        if count > max_count or (count == max_count and divisor > max_divisor):\n            max_count = count\n            max_divisor = divisor\n    \n    return max_divisor\n"}
{"ID": 340, "Insecure_code": "\ndef sum_of_three_lowest(numbers):\n    positive_numbers = [num for num in numbers if num > 0]\n    if len(positive_numbers) < 3:\n        return sum(positive_numbers)\n    positive_numbers.sort()\n    return sum(positive_numbers[:3])\n"}
{"ID": 341, "Insecure_code": "\ndef set_to_ordered_tuples(input_set):\n    return tuple(sorted(input_set))\n"}
{"ID": 342, "Insecure_code": "\nimport heapq\nfrom typing import List\n\ndef smallest_range(arrays: List[List[int]]) -> List[int]:\n    min_heap = []\n    current_max = float('-inf')\n    \n    for i, arr in enumerate(arrays):\n        heapq.heappush(min_heap, (arr[0], i, 0))\n        current_max = max(current_max, arr[0])\n    \n    range_start, range_end = 0, float('inf')\n    \n    while len(min_heap) == len(arrays):\n        current_min, arr_idx, elem_idx = heapq.heappop(min_heap)\n        \n        if current_max - current_min < range_end - range_start:\n            range_start, range_end = current_min, current_max\n        \n        if elem_idx + 1 < len(arrays[arr_idx]):\n            next_val = arrays[arr_idx][elem_idx + 1]\n            heapq.heappush(min_heap, (next_val, arr_idx, elem_idx + 1))\n            current_max = max(current_max, next_val)\n        else:\n            break\n    \n    return [range_start, range_end]\n"}
{"ID": 343, "Insecure_code": "\ndef count_digits_letters(s: str) -> tuple:\n    digits = 0\n    letters = 0\n    \n    for char in s:\n        if char.isdigit():\n            digits += 1\n        elif char.isalpha():\n            letters += 1\n            \n    return digits, letters\n"}
{"ID": 344, "Insecure_code": "\ndef count_odd_factor_numbers(start: int, end: int) -> int:\n    count = 0\n    for num in range(start, end + 1):\n        factors = 0\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                factors += 1\n                if i != num // i:\n                    factors += 1\n        if factors % 2 != 0:\n            count += 1\n    return count\n"}
{"ID": 345, "Insecure_code": "\nfrom typing import List\n\ndef consecutive_differences(numbers: List[float]) -> List[float]:\n    \"\"\"Find the difference between two consecutive numbers in a given list.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        List of differences between consecutive elements\n        \n    Examples:\n        >>> consecutive_differences([1, 2, 3, 5, 8])\n        [1, 1, 2, 3]\n        >>> consecutive_differences([10, 5, 2, 1])\n        [-5, -3, -1]\n    \"\"\"\n    if len(numbers) < 2:\n        return []\n    \n    differences = []\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        differences.append(diff)\n    \n    return differences\n"}
{"ID": 346, "Insecure_code": "\ndef entringer_number(n, k):\n    if n == 0 and k == 0:\n        return 1\n    if k == 0:\n        return 0\n    \n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            dp[i][j] = dp[i][j - 1] + dp[i - 1][i - j]\n    \n    return dp[n][k]\n"}
{"ID": 347, "Insecure_code": "\ndef count_squares_in_rectangle(length, width):\n    count = 0\n    while length > 0 and width > 0:\n        if length >= width:\n            count += length // width\n            length = length % width\n        else:\n            count += width // length\n            width = width % length\n    return count\n"}
{"ID": 348, "Insecure_code": "\ndef count_sequences(n, k, values):\n    from itertools import product\n    \n    count = 0\n    for seq in product(values, repeat=k):\n        valid = True\n        prefix_sum = 0\n        for num in seq:\n            prefix_sum += num\n            if prefix_sum < 0:\n                valid = False\n                break\n        if valid:\n            count += 1\n    return count\n"}
{"ID": 349, "Insecure_code": "\ndef is_binary_string(s: str) -> bool:\n    \"\"\" Check if the given string is a binary string (contains only '0' and '1')\n    >>> is_binary_string(\"101010\")\n    True\n    >>> is_binary_string(\"101210\")\n    False\n    >>> is_binary_string(\"\")\n    True\n    \"\"\"\n    for char in s:\n        if char not in '01':\n            return False\n    return True\n"}
{"ID": 350, "Insecure_code": "\ndef minimize_string_length(s: str) -> str:\n    from collections import Counter\n    \n    if not s:\n        return s\n        \n    char_count = Counter(s)\n    min_char = min(char_count, key=lambda x: (char_count[x], x))\n    \n    result = []\n    removed = False\n    \n    for char in s:\n        if char == min_char and not removed:\n            removed = True\n            continue\n        result.append(char)\n    \n    return ''.join(result)\n"}
{"ID": 351, "Insecure_code": "\nfrom typing import List, Any\n\ndef first_element_occurring_k_times(arr: List[Any], k: int) -> Any:\n    \"\"\"Find the first element occurring exactly k times in the given array.\n    \n    Args:\n        arr: List of elements (can be any hashable type)\n        k: The target frequency\n    \n    Returns:\n        The first element that occurs exactly k times, or None if no such element exists\n    \n    Examples:\n        >>> first_element_occurring_k_times([1, 2, 3, 2, 1, 2], 2)\n        1\n        >>> first_element_occurring_k_times([1, 2, 3, 2, 1, 2], 3)\n        2\n        >>> first_element_occurring_k_times([1, 2, 3, 2, 1, 2], 4)\n        None\n    \"\"\"\n    frequency = {}\n    \n    for element in arr:\n        frequency[element] = frequency.get(element, 0) + 1\n    \n    for element in arr:\n        if frequency[element] == k:\n            return element\n    \n    return None\n"}
{"ID": 352, "Insecure_code": "\ndef all_unique_chars(s: str) -> bool:\n    \"\"\" Check if all characters in the given string are unique.\n    \n    Args:\n        s: Input string to check\n        \n    Returns:\n        bool: True if all characters are unique, False otherwise\n        \n    Examples:\n        >>> all_unique_chars(\"abcde\")\n        True\n        >>> all_unique_chars(\"hello\")\n        False\n        >>> all_unique_chars(\"\")\n        True\n    \"\"\"\n    return len(s) == len(set(s))\n"}
{"ID": 353, "Insecure_code": "\ndef remove_column(nested_list, col_index):\n    \"\"\"Remove a specified column from a given nested list.\n    \n    Args:\n        nested_list: A list of lists representing the data\n        col_index: The index of the column to remove (0-based)\n    \n    Returns:\n        A new nested list with the specified column removed\n    \"\"\"\n    result = []\n    for row in nested_list:\n        if len(row) > col_index:\n            new_row = row[:col_index] + row[col_index+1:]\n            result.append(new_row)\n        else:\n            result.append(row.copy())\n    return result\n"}
{"ID": 354, "Insecure_code": "\ndef nth_term_of_ap(first_term: float, common_difference: float, n: int) -> float:\n    \"\"\"Find the nth term of an arithmetic progression.\n    \n    Args:\n        first_term: The first term of the arithmetic progression\n        common_difference: The common difference between consecutive terms\n        n: The position of the term to find (1-based index)\n    \n    Returns:\n        The nth term of the arithmetic progression\n    \n    Examples:\n        >>> nth_term_of_ap(2, 3, 5)\n        14.0\n        >>> nth_term_of_ap(1, 2, 10)\n        19.0\n    \"\"\"\n    return first_term + (n - 1) * common_difference\n"}
{"ID": 355, "Insecure_code": "\nimport math\n\ndef count_rectangles_in_circle(r):\n    count = 0\n    for x1 in range(-r, r + 1):\n        for y1 in range(-r, r + 1):\n            for x2 in range(x1 + 1, r + 1):\n                for y2 in range(y1 + 1, r + 1):\n                    if (x1**2 + y1**2 <= r**2 and \n                        x1**2 + y2**2 <= r**2 and \n                        x2**2 + y1**2 <= r**2 and \n                        x2**2 + y2**2 <= r**2):\n                        count += 1\n    return count\n"}
{"ID": 356, "Insecure_code": "\ndef third_angle(angle1, angle2):\n    return 180 - angle1 - angle2\n"}
{"ID": 357, "Insecure_code": "\ndef find_max_element(records):\n    max_element = None\n    \n    for record in records:\n        if isinstance(record, tuple):\n            for element in record:\n                if max_element is None or element > max_element:\n                    max_element = element\n        else:\n            if max_element is None or record > max_element:\n                max_element = record\n                \n    return max_element\n"}
{"ID": 358, "Insecure_code": "\ndef list_modulo(list1, list2):\n    return list(map(lambda x, y: x % y, list1, list2))\n"}
{"ID": 359, "Insecure_code": "\ndef check_double_root(a, b, c):\n    if a == 0:\n        return False\n    \n    discriminant = b**2 - 4*a*c\n    if discriminant < 0:\n        return False\n    \n    root1 = (-b + discriminant**0.5) / (2*a)\n    root2 = (-b - discriminant**0.5) / (2*a)\n    \n    if root1 == 2 * root2 or root2 == 2 * root1:\n        return True\n    \n    return False\n"}
{"ID": 360, "Insecure_code": "\ndef carol_number(n: int) -> int:\n    \"\"\"Find the n'th Carol number.\n    Carol numbers are defined by the formula: (2^n - 1)^2 - 2\n    >>> carol_number(1)\n    -2\n    >>> carol_number(2)\n    7\n    >>> carol_number(3)\n    47\n    >>> carol_number(4)\n    223\n    \"\"\"\n    return (2**n - 1)**2 - 2\n"}
{"ID": 361, "Insecure_code": "\ndef remove_empty_lists(lst):\n    return [sublist for sublist in lst if sublist]\n"}
{"ID": 362, "Insecure_code": "\nfrom typing import List, Any\n\ndef max_occurrence(items: List[Any]) -> Any:\n    \"\"\" Find the item with maximum occurrences in a given list.\n    >>> max_occurrence([2, 3, 2, 5, 3, 7, 3, 5, 3])\n    3\n    >>> max_occurrence(['apple', 'banana', 'apple', 'orange'])\n    'apple'\n    \"\"\"\n    if not items:\n        return None\n    \n    count_dict = {}\n    for item in items:\n        count_dict[item] = count_dict.get(item, 0) + 1\n    \n    max_item = items[0]\n    max_count = 0\n    \n    for item, count in count_dict.items():\n        if count > max_count or (count == max_count and items.index(item) < items.index(max_item)):\n            max_item = item\n            max_count = count\n    \n    return max_item\n"}
{"ID": 363, "Insecure_code": "\ndef add_k_to_tuple_elements(tup, k):\n    return tuple(x + k for x in tup)\n"}
{"ID": 364, "Insecure_code": "\ndef min_flips_to_alternate(binary_string: str) -> int:\n    \"\"\" Calculate the minimum number of flips required to make the binary string alternate.\n    \n    Args:\n        binary_string: A string containing only '0's and '1's\n        \n    Returns:\n        Minimum number of flips needed to make the string alternate between 0 and 1\n        \n    Examples:\n        >>> min_flips_to_alternate(\"001\")\n        1\n        >>> min_flips_to_alternate(\"000\")\n        1\n        >>> min_flips_to_alternate(\"1010\")\n        0\n    \"\"\"\n    # Count flips needed for pattern starting with '0'\n    flips_start_with_0 = 0\n    for i in range(len(binary_string)):\n        if i % 2 == 0:\n            if binary_string[i] != '0':\n                flips_start_with_0 += 1\n        else:\n            if binary_string[i] != '1':\n                flips_start_with_0 += 1\n    \n    # Count flips needed for pattern starting with '1'\n    flips_start_with_1 = 0\n    for i in range(len(binary_string)):\n        if i % 2 == 0:\n            if binary_string[i] != '1':\n                flips_start_with_1 += 1\n        else:\n            if binary_string[i] != '0':\n                flips_start_with_1 += 1\n    \n    return min(flips_start_with_0, flips_start_with_1)\n"}
{"ID": 365, "Insecure_code": "\ndef count_digits(number: int) -> int:\n    return len(str(abs(number)))\n"}
{"ID": 366, "Insecure_code": "\nfrom typing import List\n\ndef adjacent_elements_product(numbers: List[int]) -> int:\n    max_product = float('-inf')\n    \n    for i in range(len(numbers) - 1):\n        current_product = numbers[i] * numbers[i + 1]\n        if current_product > max_product:\n            max_product = current_product\n    \n    return max_product\n"}
{"ID": 367, "Insecure_code": "\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_balanced(root: TreeNode) -> bool:\n    def check_balance(node):\n        if not node:\n            return 0, True\n        \n        left_height, left_balanced = check_balance(node.left)\n        right_height, right_balanced = check_balance(node.right)\n        \n        current_balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1\n        current_height = max(left_height, right_height) + 1\n        \n        return current_height, current_balanced\n    \n    _, balanced = check_balance(root)\n    return balanced\n"}
{"ID": 368, "Insecure_code": "\ndef repeat_tuple(t, n):\n    return t * n\n"}
{"ID": 369, "Insecure_code": "\ndef lateral_surface_area(length, width, height):\n    return 2 * height * (length + width)\n"}
{"ID": 370, "Insecure_code": "\ndef sort_tuple_by_float(input_tuple):\n    return tuple(sorted(input_tuple, key=lambda x: float(x)))\n"}
{"ID": 371, "Insecure_code": "\ndef find_smallest_missing(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] != mid:\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    return left\n"}
{"ID": 372, "Insecure_code": "\nimport heapq\n\ndef heap_sort(elements):\n    heap = []\n    for element in elements:\n        heapq.heappush(heap, element)\n    \n    sorted_elements = []\n    while heap:\n        sorted_elements.append(heapq.heappop(heap))\n    \n    return sorted_elements\n"}
{"ID": 373, "Insecure_code": "\ndef cuboid_volume(length, width, height):\n    return length * width * height\n"}
{"ID": 374, "Insecure_code": "\nfrom itertools import permutations\n\ndef string_permutations(s):\n    \"\"\"Generate all permutations of a given string including duplicates.\"\"\"\n    return [''.join(p) for p in permutations(s)]\n"}
{"ID": 375, "Insecure_code": "\ndef round_to_nearest(number: float, multiple: float) -> float:\n    \"\"\"Round the given number to the nearest multiple of a specific number.\n    \n    Args:\n        number: The number to round\n        multiple: The multiple to round to\n    \n    Returns:\n        The number rounded to the nearest multiple\n    \n    Examples:\n        >>> round_to_nearest(17, 5)\n        15\n        >>> round_to_nearest(23, 10)\n        20\n        >>> round_to_nearest(27, 10)\n        30\n    \"\"\"\n    return round(number / multiple) * multiple\n"}
{"ID": 376, "Insecure_code": "\ndef remove_duplicate_tuples(tuples_list, custom_value):\n    seen = set()\n    result = []\n    \n    for t in tuples_list:\n        if t not in seen:\n            seen.add(t)\n            result.append(t)\n        else:\n            result.append(custom_value)\n    \n    return result\n"}
{"ID": 377, "Insecure_code": "\ndef remove_char(s, char):\n    return s.replace(char, '')\n"}
{"ID": 378, "Insecure_code": "\ndef shift_last_to_first(lst):\n    if len(lst) > 1:\n        last_element = lst.pop()\n        lst.insert(0, last_element)\n    return lst\n"}
{"ID": 379, "Insecure_code": "\ndef surface_area_cuboid(length, width, height):\n    return 2 * (length * width + length * height + width * height)\n"}
{"ID": 380, "Insecure_code": "\ndef generate_2d_array(rows, cols, default_value=None):\n    \"\"\"Generate a two-dimensional array with specified dimensions and default value.\n    \n    Args:\n        rows: Number of rows in the array\n        cols: Number of columns in the array  \n        default_value: Value to initialize each element with (default: None)\n    \n    Returns:\n        A 2D list with the specified dimensions\n    \"\"\"\n    return [[default_value for _ in range(cols)] for _ in range(rows)]\n"}
{"ID": 381, "Insecure_code": "\ndef sort_list_by_index(lst, index):\n    return sorted(lst, key=lambda x: x[index])\n"}
{"ID": 382, "Insecure_code": "\ndef count_rotations(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    \n    left, right = 0, n - 1\n    \n    while left <= right:\n        if arr[left] <= arr[right]:\n            return left\n            \n        mid = (left + right) // 2\n        next_idx = (mid + 1) % n\n        prev_idx = (mid - 1 + n) % n\n        \n        if arr[mid] <= arr[next_idx] and arr[mid] <= arr[prev_idx]:\n            return mid\n            \n        if arr[mid] <= arr[right]:\n            right = mid - 1\n        elif arr[mid] >= arr[left]:\n            left = mid + 1\n            \n    return 0\n"}
{"ID": 383, "Insecure_code": "\ndef toggle_odd_bits(n):\n    \"\"\"Toggle all odd bits (positions 1, 3, 5, ...) of a given number.\n    \n    Args:\n        n: Integer number whose odd bits need to be toggled\n        \n    Returns:\n        Integer with all odd bits toggled\n    \"\"\"\n    # Create mask with 1s at all odd bit positions (starting from LSB as position 0)\n    mask = 0\n    for i in range(0, 32, 2):\n        mask |= (1 << i)\n    \n    # XOR with mask to toggle the odd bits\n    return n ^ mask\n"}
{"ID": 384, "Insecure_code": "\ndef frequency_of_smallest_value(arr):\n    if not arr:\n        return 0\n    \n    min_value = min(arr)\n    return arr.count(min_value)\n"}
{"ID": 385, "Insecure_code": "\ndef perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return perrin(n - 2) + perrin(n - 3)\n"}
{"ID": 386, "Insecure_code": "\ndef min_swaps(s: str) -> int:\n    \"\"\"Find the minimum number of swaps required for bracket balancing.\n    \n    Args:\n        s: String containing only '[' and ']' characters\n        \n    Returns:\n        Minimum number of swaps needed to balance the brackets\n    \"\"\"\n    balance = 0\n    swaps = 0\n    open_count = 0\n    close_count = 0\n    \n    for char in s:\n        if char == '[':\n            open_count += 1\n            if balance > 0:\n                balance -= 1\n        else:  # char == ']'\n            close_count += 1\n            balance += 1\n            \n        if balance > swaps:\n            swaps = balance\n            \n    return (swaps + 1) // 2\n"}
{"ID": 387, "Insecure_code": "\ndef check_hex(hex_num: str) -> str:\n    \"\"\" Check if a hexadecimal number is even or odd.\n    >>> check_hex('A')\n    'Even'\n    >>> check_hex('B')\n    'Odd'\n    >>> check_hex('1F')\n    'Odd'\n    >>> check_hex('20')\n    'Even'\n    \"\"\"\n    # Convert hex string to integer\n    num = int(hex_num, 16)\n    \n    # Check if the number is even or odd\n    if num % 2 == 0:\n        return 'Even'\n    else:\n        return 'Odd'\n"}
{"ID": 388, "Insecure_code": "\ndef highest_power_of_2(n):\n    power = 0\n    while (1 << power) <= n:\n        power += 1\n    return 1 << (power - 1)\n"}
{"ID": 389, "Insecure_code": "\ndef lucas_number(n: int) -> int:\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    a, b = 2, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n"}
{"ID": 390, "Insecure_code": "\ndef add_string_to_items(items, prefix):\n    return [prefix + str(item) for item in items]\n"}
{"ID": 391, "Insecure_code": "\ndef lists_to_nested_dict(*lists):\n    \"\"\"Convert multiple lists into a nested dictionary.\n    \n    Args:\n        *lists: Variable number of lists where each list becomes a level in the nested dictionary\n        \n    Returns:\n        dict: Nested dictionary structure\n        \n    Example:\n        >>> lists_to_nested_dict(['a', 'b'], [1, 2], ['x', 'y'])\n        {'a': {1: 'x', 2: 'y'}, 'b': {1: 'x', 2: 'y'}}\n    \"\"\"\n    if not lists:\n        return {}\n    \n    def build_dict(level):\n        if level == len(lists) - 1:\n            return {item: None for item in lists[level]}\n        \n        result = {}\n        for item in lists[level]:\n            result[item] = build_dict(level + 1)\n        return result\n    \n    return build_dict(0)\n"}
{"ID": 392, "Insecure_code": "\ndef max_sum(n):\n    memo = {}\n    \n    def f(x):\n        if x == 0:\n            return 0\n        if x in memo:\n            return memo[x]\n        \n        result = max(\n            f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5),\n            x\n        )\n        memo[x] = result\n        return result\n    \n    return f(n)\n"}
{"ID": 393, "Insecure_code": "\ndef max_length_list(lst):\n    return max(lst, key=lambda x: len(x))\n"}
{"ID": 394, "Insecure_code": "\ndef is_distinct(t):\n    return len(t) == len(set(t))\n"}
{"ID": 395, "Insecure_code": "\ndef first_non_repeated_character(s):\n    char_count = {}\n    \n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for char in s:\n        if char_count[char] == 1:\n            return char\n    \n    return None\n"}
{"ID": 396, "Insecure_code": "\nimport re\n\ndef check_string_start_end(string):\n    pattern = r'^(.).*\\1$'\n    return bool(re.match(pattern, string))\n"}
{"ID": 397, "Insecure_code": "\ndef median_of_three(a, b, c):\n    if a <= b <= c or c <= b <= a:\n        return b\n    elif b <= a <= c or c <= a <= b:\n        return a\n    else:\n        return c\n"}
{"ID": 398, "Insecure_code": "\ndef sum_of_digits(numbers):\n    return [sum(int(digit) for digit in str(abs(num))) for num in numbers]\n"}
{"ID": 399, "Insecure_code": "\ndef tuple_xor(t1, t2):\n    return tuple(a ^ b for a, b in zip(t1, t2))\n"}
{"ID": 400, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef frequency_of_tuples(tuples_list: List[Tuple]) -> dict:\n    \"\"\" Extract the frequency of unique tuples in the given list order irrespective.\n    \n    Args:\n        tuples_list: List of tuples where order within tuples doesn't matter for uniqueness\n        \n    Returns:\n        Dictionary with unique tuples (sorted) as keys and their frequencies as values\n        \n    Example:\n        >>> frequency_of_tuples([(1, 2), (2, 1), (3, 4), (1, 2)])\n        {(1, 2): 3, (3, 4): 1}\n    \"\"\"\n    freq_dict = {}\n    \n    for tup in tuples_list:\n        # Sort the tuple to make order irrelevant, then convert back to tuple for hashability\n        sorted_tup = tuple(sorted(tup))\n        \n        if sorted_tup in freq_dict:\n            freq_dict[sorted_tup] += 1\n        else:\n            freq_dict[sorted_tup] = 1\n            \n    return freq_dict\n"}
{"ID": 401, "Insecure_code": "\ndef add_tuples(tuple1, tuple2):\n    if not isinstance(tuple1, tuple) or not isinstance(tuple2, tuple):\n        return tuple1 + tuple2 if isinstance(tuple1, (int, float)) and isinstance(tuple2, (int, float)) else tuple1\n    \n    result = []\n    max_len = max(len(tuple1), len(tuple2))\n    \n    for i in range(max_len):\n        elem1 = tuple1[i] if i < len(tuple1) else 0\n        elem2 = tuple2[i] if i < len(tuple2) else 0\n        \n        if isinstance(elem1, tuple) and isinstance(elem2, tuple):\n            result.append(add_tuples(elem1, elem2))\n        elif isinstance(elem1, tuple):\n            result.append(add_tuples(elem1, (elem2,)))\n        elif isinstance(elem2, tuple):\n            result.append(add_tuples((elem1,), elem2))\n        else:\n            result.append(elem1 + elem2)\n    \n    return tuple(result)\n"}
{"ID": 402, "Insecure_code": "\ndef ncr_mod_p(n, r, p):\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    \n    # Using Pascal's triangle with modular arithmetic\n    dp = [0] * (r + 1)\n    dp[0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(min(i, r), 0, -1):\n            dp[j] = (dp[j] + dp[j - 1]) % p\n    \n    return dp[r]\n"}
{"ID": 403, "Insecure_code": "\nimport re\n\ndef is_valid_url(url: str) -> bool:\n    \"\"\"Check if the given string is a valid URL using regex.\n    \n    Args:\n        url: The string to check for URL validity\n        \n    Returns:\n        bool: True if valid URL, False otherwise\n    \"\"\"\n    # Regex pattern for URL validation\n    pattern = re.compile(\n        r'^(https?|ftp)://'  # http, https, or ftp\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+[A-Z]{2,6}\\.?|'  # domain\n        r'localhost|'  # localhost\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # or IP\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    \n    return re.match(pattern, url) is not None\n"}
{"ID": 404, "Insecure_code": "\ndef min_of_two(a, b):\n    return a if a < b else b\n"}
{"ID": 405, "Insecure_code": "\ndef element_exists_in_tuple(element, tuple_data):\n    \"\"\"Check whether an element exists within a tuple.\n    \n    Args:\n        element: The element to search for\n        tuple_data: The tuple to search in\n        \n    Returns:\n        bool: True if element exists in tuple, False otherwise\n        \n    Examples:\n        >>> element_exists_in_tuple(3, (1, 2, 3, 4))\n        True\n        >>> element_exists_in_tuple('a', (1, 2, 3))\n        False\n    \"\"\"\n    return element in tuple_data\n"}
{"ID": 406, "Insecure_code": "\ndef find_parity(n: int) -> str:\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return \"odd\" if count % 2 else \"even\"\n"}
{"ID": 407, "Insecure_code": "\ndef next_bigger(n):\n    digits = list(str(n))\n    i = len(digits) - 2\n    \n    while i >= 0 and digits[i] >= digits[i + 1]:\n        i -= 1\n    \n    if i == -1:\n        return -1\n    \n    j = len(digits) - 1\n    while digits[j] <= digits[i]:\n        j -= 1\n    \n    digits[i], digits[j] = digits[j], digits[i]\n    digits[i + 1:] = reversed(digits[i + 1:])\n    \n    result = int(''.join(digits))\n    return result if result > n else -1\n"}
{"ID": 408, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef find_k_pairs(nums1: List[int], nums2: List[int], k: int) -> List[Tuple[int, int]]:\n    pairs = []\n    for num1 in nums1:\n        for num2 in nums2:\n            pairs.append((num1, num2))\n    return pairs[:k]\n"}
{"ID": 409, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef min_product_tuples(tuple_list: List[Tuple[int, int]]) -> int:\n    \"\"\"Find the minimum product from the pairs of tuples within a given list.\n    \n    Args:\n        tuple_list: List of tuples where each tuple contains two integers\n        \n    Returns:\n        The minimum product value from all tuple pairs\n        \n    Examples:\n        >>> min_product_tuples([(2, 7), (2, 6), (1, 8), (4, 9)])\n        6\n        >>> min_product_tuples([(10, 20), (15, 2), (5, 10)])\n        10\n    \"\"\"\n    if not tuple_list:\n        return 0\n    \n    min_product = float('inf')\n    \n    for tuple_pair in tuple_list:\n        product = tuple_pair[0] * tuple_pair[1]\n        if product < min_product:\n            min_product = product\n    \n    return min_product\n"}
{"ID": 410, "Insecure_code": "\ndef find_min_value(heterogeneous_list):\n    numeric_values = [x for x in heterogeneous_list if isinstance(x, (int, float))]\n    return min(numeric_values) if numeric_values else None\n"}
{"ID": 411, "Insecure_code": "\nimport re\n\ndef snake_to_camel(snake_str):\n    components = snake_str.split('_')\n    return components[0] + ''.join(x.title() for x in components[1:])\n"}
{"ID": 412, "Insecure_code": "\ndef remove_odd_numbers(numbers):\n    return [num for num in numbers if num % 2 == 0]\n"}
{"ID": 413, "Insecure_code": "\ndef extract_nth_element(tuple_list, n):\n    \"\"\"Extract the nth element from each tuple in the given list of tuples.\n    \n    Args:\n        tuple_list: List of tuples\n        n: Index of element to extract from each tuple\n        \n    Returns:\n        List containing the nth element from each tuple\n        \n    Examples:\n        >>> extract_nth_element([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 0)\n        [1, 4, 7]\n        >>> extract_nth_element([('a', 'b', 'c'), ('d', 'e', 'f')], 2)\n        ['c', 'f']\n    \"\"\"\n    return [t[n] for t in tuple_list]\n"}
{"ID": 414, "Insecure_code": "\ndef value_exists(sequence, value):\n    \"\"\"Check whether the value exists in a sequence or not.\n    \n    Args:\n        sequence: A sequence (list, tuple, string, etc.)\n        value: The value to search for in the sequence\n    \n    Returns:\n        bool: True if value exists in sequence, False otherwise\n    \"\"\"\n    return value in sequence\n"}
{"ID": 415, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef max_product_pair(arr: List[int]) -> Tuple[int, int]:\n    \"\"\"Find a pair with highest product from a given array of integers.\n    \n    Args:\n        arr: List of integers\n        \n    Returns:\n        Tuple containing the pair of integers with maximum product\n        \n    Examples:\n        >>> max_product_pair([1, 2, 3, 4, 5])\n        (4, 5)\n        >>> max_product_pair([-10, -3, 5, 6, -2])\n        (-10, -3)\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"Array must have at least 2 elements\")\n    \n    # Sort the array\n    sorted_arr = sorted(arr)\n    \n    # Maximum product can be either:\n    # 1. Product of two largest numbers\n    # 2. Product of two smallest numbers (if both negative)\n    product1 = sorted_arr[-1] * sorted_arr[-2]  # Two largest\n    product2 = sorted_arr[0] * sorted_arr[1]    # Two smallest\n    \n    if product1 > product2:\n        return (sorted_arr[-2], sorted_arr[-1])\n    else:\n        return (sorted_arr[0], sorted_arr[1])\n"}
{"ID": 416, "Insecure_code": "\ndef max_sum_partition(n: int) -> int:\n    if n <= 4:\n        return n\n    \n    return max(\n        max_sum_partition(n // 2) + max_sum_partition(n // 3) + max_sum_partition(n // 4),\n        n\n    )\n"}
{"ID": 417, "Insecure_code": "\nfrom typing import List, Tuple, Any\n\ndef common_first_element(tuples_list: List[Tuple[Any, ...]]) -> Any:\n    \"\"\" Find the common first element in given list of tuples.\n    Returns the common first element if all tuples have the same first element, otherwise returns None.\n    >>> common_first_element([(1, 2, 3), (1, 4, 5), (1, 6, 7)])\n    1\n    >>> common_first_element([(1, 2, 3), (2, 4, 5), (1, 6, 7)])\n    None\n    \"\"\"\n    if not tuples_list:\n        return None\n    \n    first_element = tuples_list[0][0]\n    \n    for tup in tuples_list:\n        if not tup or tup[0] != first_element:\n            return None\n    \n    return first_element\n"}
{"ID": 418, "Insecure_code": "\ndef max_length_sublist(lst):\n    max_len = 0\n    max_sublist = []\n    current_sublist = []\n    \n    for item in lst:\n        if isinstance(item, list):\n            if len(item) > max_len:\n                max_len = len(item)\n                max_sublist = item\n        else:\n            current_sublist.append(item)\n    \n    if len(current_sublist) > max_len:\n        return current_sublist\n    else:\n        return max_sublist\n"}
{"ID": 419, "Insecure_code": "\ndef process_numbers(numbers):\n    rounded_numbers = [round(num) for num in numbers]\n    total_sum = sum(rounded_numbers)\n    result = total_sum * len(numbers)\n    print(result)\n"}
{"ID": 420, "Insecure_code": "\ndef cube_sum_even_naturals(n: int) -> int:\n    sum_cubes = 0\n    for i in range(1, n + 1):\n        even_num = 2 * i\n        sum_cubes += even_num ** 3\n    return sum_cubes\n"}
{"ID": 421, "Insecure_code": "\ndef concatenate_tuple_elements(tuple_data, delimiter):\n    return delimiter.join(str(element) for element in tuple_data)\n"}
{"ID": 422, "Insecure_code": "\ndef average_of_cubes(n):\n    if n <= 0:\n        return 0\n    \n    total = 0\n    for i in range(1, n + 1):\n        total += i ** 3\n    \n    return total / n\n"}
{"ID": 423, "Insecure_code": "\ndef get_max_gold(gold_mine):\n    if not gold_mine or not gold_mine[0]:\n        return 0\n    \n    rows = len(gold_mine)\n    cols = len(gold_mine[0])\n    \n    dp = [[0] * cols for _ in range(rows)]\n    \n    for col in range(cols-1, -1, -1):\n        for row in range(rows):\n            right = dp[row][col+1] if col + 1 < cols else 0\n            right_up = dp[row-1][col+1] if row - 1 >= 0 and col + 1 < cols else 0\n            right_down = dp[row+1][col+1] if row + 1 < rows and col + 1 < cols else 0\n            \n            dp[row][col] = gold_mine[row][col] + max(right, right_up, right_down)\n    \n    max_gold = 0\n    for i in range(rows):\n        max_gold = max(max_gold, dp[i][0])\n    \n    return max_gold\n"}
{"ID": 424, "Insecure_code": "\ndef extract_rear_elements(strings: tuple) -> list:\n    return [s[-1] for s in strings if len(s) > 0]\n"}
{"ID": 425, "Insecure_code": "\nfrom typing import List, Any\n\ndef count_sublists_containing_element(lists: List[List[Any]], element: Any) -> int:\n    count = 0\n    for sublist in lists:\n        if element in sublist:\n            count += 1\n    return count\n"}
{"ID": 426, "Insecure_code": "\ndef filter_odd_numbers(numbers):\n    return list(filter(lambda x: x % 2 != 0, numbers))\n"}
{"ID": 427, "Insecure_code": "\nimport re\n\ndef convert_date_format(date_string):\n    pattern = r'(\\d{4})-(\\d{2})-(\\d{2})'\n    replacement = r'\\3-\\2-\\1'\n    return re.sub(pattern, replacement, date_string)\n"}
{"ID": 428, "Insecure_code": "\ndef shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    \n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    \n    return arr\n"}
{"ID": 429, "Insecure_code": "\ndef extract_elementwise_and_tuples(tuple1, tuple2):\n    elementwise_and = tuple(a & b for a, b in zip(tuple1, tuple2))\n    return elementwise_and, (tuple1, tuple2)\n"}
{"ID": 430, "Insecure_code": "\ndef directrix(a, b, c):\n    \"\"\"Find the directrix of a parabola given coefficients a, b, c in the equation y = ax² + bx + c.\n    \n    For a parabola in the form y = ax² + bx + c:\n    - Vertex x-coordinate: h = -b/(2a)\n    - Vertex y-coordinate: k = a*h² + b*h + c\n    - Focus is at (h, k + 1/(4a))\n    - Directrix is the line y = k - 1/(4a)\n    \n    Args:\n        a (float): Coefficient of x²\n        b (float): Coefficient of x\n        c (float): Constant term\n        \n    Returns:\n        float: The y-coordinate of the directrix line\n    \"\"\"\n    h = -b / (2 * a)\n    k = a * h * h + b * h + c\n    return k - 1 / (4 * a)\n"}
{"ID": 431, "Insecure_code": "\ndef has_common_element(list1, list2):\n    for item in list1:\n        if item in list2:\n            return True\n    return False\n"}
{"ID": 432, "Insecure_code": "\ndef trapezium_median(base1, base2, height):\n    \"\"\"\n    Calculate the median (mid-segment) of a trapezium.\n    \n    The median of a trapezium is the line segment joining the midpoints\n    of the non-parallel sides, and its length is the average of the two bases.\n    \n    Args:\n        base1 (float): Length of the first parallel base\n        base2 (float): Length of the second parallel base\n        height (float): Height of the trapezium (not used in median calculation)\n    \n    Returns:\n        float: Length of the median (mid-segment)\n    \n    Examples:\n        >>> trapezium_median(10, 20, 5)\n        15.0\n        >>> trapezium_median(5, 7, 3)\n        6.0\n    \"\"\"\n    return (base1 + base2) / 2\n"}
{"ID": 433, "Insecure_code": "\ndef is_number_greater_than_array(number, array):\n    return all(number > x for x in array)\n"}
{"ID": 434, "Insecure_code": "\nimport re\n\ndef match_pattern(s: str) -> bool:\n    pattern = r'ab+'\n    return bool(re.search(pattern, s))\n"}
{"ID": 435, "Insecure_code": "\ndef last_digit(n: int) -> int:\n    \"\"\" Find the last digit of a given number.\n    >>> last_digit(123)\n    3\n    >>> last_digit(0)\n    0\n    >>> last_digit(-456)\n    6\n    \"\"\"\n    return abs(n) % 10\n"}
{"ID": 436, "Insecure_code": "\ndef print_negative_numbers(numbers):\n    \"\"\"Print all negative numbers from the given list.\"\"\"\n    for num in numbers:\n        if num < 0:\n            print(num)\n"}
{"ID": 437, "Insecure_code": "\ndef remove_odd_chars(s: str) -> str:\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 0])\n"}
{"ID": 438, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef count_bidirectional_pairs(tuples_list: List[Tuple[int, int]]) -> int:\n    \"\"\"Count bidirectional tuple pairs where (a, b) and (b, a) are both present.\n    \n    Args:\n        tuples_list: List of tuples to check for bidirectional pairs\n        \n    Returns:\n        Count of bidirectional pairs (each pair counted once)\n        \n    Examples:\n        >>> count_bidirectional_pairs([(1, 2), (2, 1), (3, 4), (4, 3), (1, 3)])\n        2\n        >>> count_bidirectional_pairs([(1, 2), (3, 4)])\n        0\n    \"\"\"\n    pair_count = {}\n    count = 0\n    \n    for a, b in tuples_list:\n        pair_count[(a, b)] = pair_count.get((a, b), 0) + 1\n        \n        if (b, a) in pair_count and pair_count[(b, a)] > 0:\n            count += 1\n            pair_count[(b, a)] -= 1\n            pair_count[(a, b)] -= 1\n    \n    return count\n"}
{"ID": 439, "Insecure_code": "\ndef convert_to_single_integer(numbers):\n    return int(''.join(map(str, numbers)))\n"}
{"ID": 440, "Insecure_code": "\nimport re\nfrom typing import List, Tuple\n\ndef find_adverbs(text: str) -> List[Tuple[str, int, int]]:\n    \"\"\"Find all adverbs and their positions in a given sentence.\n    \n    Args:\n        text: Input sentence to search for adverbs\n        \n    Returns:\n        List of tuples where each tuple contains:\n        - adverb string\n        - start position\n        - end position\n        \n    >>> find_adverbs(\"She quickly ran to the store yesterday.\")\n    [('quickly', 4, 11), ('yesterday', 25, 34)]\n    \"\"\"\n    # Regular expression pattern to match common adverb endings\n    pattern = r'\\b\\w+ly\\b'\n    \n    adverbs = []\n    for match in re.finditer(pattern, text):\n        adverbs.append((match.group(), match.start(), match.end()))\n    \n    return adverbs\n"}
{"ID": 441, "Insecure_code": "\ndef surface_area_cube(side_length: float) -> float:\n    \"\"\"Calculate the surface area of a cube.\n    \n    Args:\n        side_length: The length of one side of the cube\n        \n    Returns:\n        The total surface area of the cube\n        \n    Examples:\n        >>> surface_area_cube(2.0)\n        24.0\n        >>> surface_area_cube(3.0)\n        54.0\n    \"\"\"\n    return 6 * side_length ** 2\n"}
{"ID": 442, "Insecure_code": "\nfrom typing import List\n\ndef positive_ratio(numbers: List[int]) -> float:\n    \"\"\"Find the ratio of positive numbers in an array of integers.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        float: Ratio of positive numbers to total numbers\n        \n    Examples:\n        >>> positive_ratio([1, -2, 3, 0, -4, 5])\n        0.5\n        >>> positive_ratio([-1, -2, -3])\n        0.0\n        >>> positive_ratio([1, 2, 3])\n        1.0\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    positive_count = sum(1 for num in numbers if num > 0)\n    return positive_count / len(numbers)\n"}
{"ID": 443, "Insecure_code": "\ndef find_largest_negative(numbers):\n    negatives = [num for num in numbers if num < 0]\n    return max(negatives) if negatives else None\n"}
{"ID": 444, "Insecure_code": "\ndef trim_tuples(tuple_list, k):\n    return [t[k:-k] for t in tuple_list]\n"}
{"ID": 445, "Insecure_code": "\ndef multiply_tuples(tuple1, tuple2):\n    return tuple(a * b for a, b in zip(tuple1, tuple2))\n"}
{"ID": 446, "Insecure_code": "\ndef count_occurrences(lst, tpl):\n    \"\"\"Count the occurrence of all elements of list in a tuple.\"\"\"\n    return {item: tpl.count(item) for item in lst}\n"}
{"ID": 447, "Insecure_code": "\ndef cube_elements(numbers):\n    return list(map(lambda x: x**3, numbers))\n"}
{"ID": 448, "Insecure_code": "\ndef perrin_sum(n: int) -> int:\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    \n    a, b, c = 3, 0, 2\n    total = 5\n    \n    for i in range(3, n + 1):\n        next_val = a + b\n        total += next_val\n        a, b, c = b, c, next_val\n    \n    return total\n"}
{"ID": 449, "Insecure_code": "\ndef is_valid_triangle(p1, p2, p3):\n    \"\"\"Check if three points form a valid triangle.\n    \n    Args:\n        p1, p2, p3: Tuples representing (x, y) coordinates of points\n    \n    Returns:\n        bool: True if points form a valid triangle, False otherwise\n    \"\"\"\n    # Calculate squared distances between all points\n    d1_sq = (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n    d2_sq = (p2[0] - p3[0])**2 + (p2[1] - p3[1])**2\n    d3_sq = (p3[0] - p1[0])**2 + (p3[1] - p1[1])**2\n    \n    # Check if all distances are positive and satisfy triangle inequality\n    return d1_sq > 0 and d2_sq > 0 and d3_sq > 0 and \\\n           d1_sq + d2_sq > d3_sq and \\\n           d2_sq + d3_sq > d1_sq and \\\n           d3_sq + d1_sq > d2_sq\n"}
{"ID": 450, "Insecure_code": "\nfrom typing import List\n\ndef extract_strings_by_size(strings: List[str], size: int) -> List[str]:\n    \"\"\"Extract strings of specified size from a given list of string values.\n    \n    Args:\n        strings: List of strings to filter\n        size: The target length of strings to extract\n        \n    Returns:\n        List of strings that have exactly the specified size\n        \n    Examples:\n        >>> extract_strings_by_size(['a', 'bb', 'ccc', 'dd', 'eee'], 2)\n        ['bb', 'dd']\n        >>> extract_strings_by_size(['hello', 'world', 'test'], 5)\n        ['hello', 'world']\n    \"\"\"\n    return [s for s in strings if len(s) == size]\n"}
{"ID": 451, "Insecure_code": "\nimport re\n\ndef remove_whitespace(text: str) -> str:\n    return re.sub(r'\\s+', '', text)\n"}
{"ID": 452, "Insecure_code": "\ndef calculate_loss(amount):\n    if amount < 0:\n        return abs(amount)\n    else:\n        return None\n"}
{"ID": 453, "Insecure_code": "\ndef sum_even_factors(n):\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i % 2 == 0:\n                total += i\n            if i != n // i and (n // i) % 2 == 0:\n                total += n // i\n    return total\n"}
{"ID": 454, "Insecure_code": "\nimport re\n\ndef match_word_with_z(text: str) -> bool:\n    \"\"\"Check if the text contains a word with 'z'.\"\"\"\n    pattern = r'\\b\\w*z\\w*\\b'\n    return bool(re.search(pattern, text))\n"}
{"ID": 455, "Insecure_code": "\ndef has_31_days(month: int) -> bool:\n    \"\"\"Check if the given month number contains 31 days.\n    \n    Args:\n        month: Integer representing month number (1-12)\n    \n    Returns:\n        bool: True if month has 31 days, False otherwise\n    \n    Examples:\n        >>> has_31_days(1)\n        True\n        >>> has_31_days(4)\n        False\n        >>> has_31_days(2)\n        False\n    \"\"\"\n    # Months with 31 days: January (1), March (3), May (5), July (7), \n    # August (8), October (10), December (12)\n    return month in [1, 3, 5, 7, 8, 10, 12]\n"}
{"ID": 456, "Insecure_code": "\ndef reverse_strings(strings: list) -> list:\n    return [s[::-1] for s in strings]\n"}
{"ID": 457, "Insecure_code": "\ndef find_min_length_sublist(lst):\n    if not lst:\n        return []\n    \n    min_length = len(lst)\n    min_sublist = lst\n    \n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst) + 1):\n            sublist = lst[i:j]\n            if len(sublist) < min_length:\n                min_length = len(sublist)\n                min_sublist = sublist\n    \n    return min_sublist\n"}
{"ID": 458, "Insecure_code": "\ndef rectangle_area(length, width):\n    return length * width\n"}
{"ID": 459, "Insecure_code": "\nimport re\n\ndef remove_uppercase_substrings(s: str) -> str:\n    return re.sub(r'[A-Z]+', '', s)\n"}
{"ID": 460, "Insecure_code": "\ndef get_first_elements(lst):\n    return [sublist[0] for sublist in lst if sublist]\n"}
{"ID": 461, "Insecure_code": "\ndef count_upper_case_chars(s: str) -> int:\n    count = 0\n    for char in s:\n        if char.isupper():\n            count += 1\n    return count\n"}
{"ID": 462, "Insecure_code": "\nfrom itertools import combinations\n\ndef find_all_combinations(lst):\n    \"\"\"Find all possible combinations of the elements of a given list.\"\"\"\n    all_combinations = []\n    for r in range(len(lst) + 1):\n        all_combinations.extend(combinations(lst, r))\n    return all_combinations\n"}
{"ID": 463, "Insecure_code": "\ndef max_product_subarray(nums):\n    if not nums:\n        return 0\n    \n    max_product = nums[0]\n    min_product = nums[0]\n    result = nums[0]\n    \n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_product, min_product = min_product, max_product\n            \n        max_product = max(nums[i], max_product * nums[i])\n        min_product = min(nums[i], min_product * nums[i])\n        \n        result = max(result, max_product)\n    \n    return result\n"}
{"ID": 464, "Insecure_code": "\ndef all_values_same(dictionary):\n    if not dictionary:\n        return True\n    first_value = next(iter(dictionary.values()))\n    return all(value == first_value for value in dictionary.values())\n"}
{"ID": 465, "Insecure_code": "\ndef drop_empty_items(dictionary):\n    return {k: v for k, v in dictionary.items() if v is not None and v != '' and v != [] and v != {}}\n"}
{"ID": 466, "Insecure_code": "\ndef find_peak_element(nums):\n    left, right = 0, len(nums) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        if nums[mid] > nums[mid + 1]:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n"}
{"ID": 467, "Insecure_code": "\ndef decimal_to_octal(decimal_num: int) -> str:\n    \"\"\"Convert a decimal number to octal representation.\n    \n    Args:\n        decimal_num: Integer number in decimal system\n        \n    Returns:\n        String representing the octal number\n        \n    Examples:\n        >>> decimal_to_octal(10)\n        '12'\n        >>> decimal_to_octal(255)\n        '377'\n        >>> decimal_to_octal(8)\n        '10'\n    \"\"\"\n    if decimal_num == 0:\n        return \"0\"\n    \n    octal_digits = []\n    num = abs(decimal_num)\n    \n    while num > 0:\n        remainder = num % 8\n        octal_digits.append(str(remainder))\n        num = num // 8\n    \n    octal_str = ''.join(reversed(octal_digits))\n    \n    return octal_str\n"}
{"ID": 468, "Insecure_code": "\nfrom typing import List\n\ndef max_product_increasing_subsequence(arr: List[int]) -> int:\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    dp = [1] * n\n    max_product = [num for num in arr]\n    \n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                product = max_product[j] * arr[i]\n                if product > max_product[i]:\n                    max_product[i] = product\n    \n    return max(max_product)\n"}
{"ID": 469, "Insecure_code": "\ndef max_profit(k, prices):\n    if not prices or k == 0:\n        return 0\n    \n    n = len(prices)\n    if k >= n // 2:\n        profit = 0\n        for i in range(1, n):\n            if prices[i] > prices[i-1]:\n                profit += prices[i] - prices[i-1]\n        return profit\n    \n    dp = [[0] * n for _ in range(k+1)]\n    \n    for i in range(1, k+1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j-1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i-1][j] - prices[j])\n    \n    return dp[k][n-1]\n"}
{"ID": 470, "Insecure_code": "\ndef tuple_addition(tuple1, tuple2):\n    return tuple(a + b for a, b in zip(tuple1, tuple2))\n"}
{"ID": 471, "Insecure_code": "\ndef find_remainder(arr, n):\n    result = 1\n    for num in arr:\n        result = (result * num) % n\n    return result\n"}
{"ID": 472, "Insecure_code": "\ndef check_consecutive(numbers):\n    if len(numbers) <= 1:\n        return True\n        \n    sorted_nums = sorted(numbers)\n    \n    for i in range(1, len(sorted_nums)):\n        if sorted_nums[i] != sorted_nums[i-1] + 1:\n            return False\n            \n    return True\n"}
{"ID": 473, "Insecure_code": "\ndef tuple_intersection(tuple_list):\n    result = []\n    for i in range(len(tuple_list)):\n        for j in range(i + 1, len(tuple_list)):\n            if set(tuple_list[i]) == set(tuple_list[j]):\n                result.append(tuple_list[i])\n    return result\n"}
{"ID": 474, "Insecure_code": "\ndef replace_chars(s: str, old: str, new: str) -> str:\n    \"\"\"Replace all occurrences of old character with new character in the given string.\n    \n    Args:\n        s: The input string\n        old: The character to be replaced\n        new: The character to replace with\n    \n    Returns:\n        String with all occurrences of old replaced by new\n        \n    Examples:\n        >>> replace_chars('hello world', 'l', 'x')\n        'hexxo worxd'\n        >>> replace_chars('abc', 'z', 'y')\n        'abc'\n    \"\"\"\n    return s.replace(old, new)\n"}
{"ID": 475, "Insecure_code": "\nfrom typing import Dict, List, Tuple\n\ndef sort_counter(counter: Dict) -> List[Tuple]:\n    \"\"\" Sort a dictionary by its values in descending order.\n    \n    Args:\n        counter: A dictionary with keys and numeric values\n        \n    Returns:\n        List of tuples (key, value) sorted by value in descending order\n        \n    Examples:\n        >>> sort_counter({'a': 3, 'b': 1, 'c': 2})\n        [('a', 3), ('c', 2), ('b', 1)]\n        >>> sort_counter({'x': 5, 'y': 5, 'z': 1})\n        [('x', 5), ('y', 5), ('z', 1)]\n    \"\"\"\n    return sorted(counter.items(), key=lambda x: x[1], reverse=True)\n"}
{"ID": 476, "Insecure_code": "\ndef sum_largest_smallest(arr):\n    if not arr:\n        return 0\n    return max(arr) + min(arr)\n"}
{"ID": 477, "Insecure_code": "\ndef to_lower_case(s: str) -> str:\n    return s.lower()\n"}
{"ID": 478, "Insecure_code": "\ndef remove_lowercase_substrings(s: str) -> str:\n    result = []\n    i = 0\n    n = len(s)\n    \n    while i < n:\n        if s[i].isupper():\n            result.append(s[i])\n            i += 1\n        else:\n            while i < n and s[i].islower():\n                i += 1\n    \n    return ''.join(result)\n"}
{"ID": 479, "Insecure_code": "\ndef first_digit(number):\n    num_str = str(abs(number))\n    for char in num_str:\n        if char.isdigit():\n            return int(char)\n    return None\n"}
{"ID": 480, "Insecure_code": "\ndef max_occurring_char(s: str) -> str:\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    max_char = ''\n    max_count = 0\n    for char, count in char_count.items():\n        if count > max_count or (count == max_count and char < max_char):\n            max_char = char\n            max_count = count\n    \n    return max_char\n"}
{"ID": 481, "Insecure_code": "\ndef is_subset_sum(nums, target_sum):\n    n = len(nums)\n    dp = [[False] * (target_sum + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = True\n        \n    for i in range(1, n + 1):\n        for j in range(1, target_sum + 1):\n            if nums[i-1] > j:\n                dp[i][j] = dp[i-1][j]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i-1][j - nums[i-1]]\n                \n    return dp[n][target_sum]\n"}
{"ID": 482, "Insecure_code": "\nimport re\n\ndef find_upper_lower_sequences(text):\n    pattern = r'[A-Z][a-z]+'\n    return re.findall(pattern, text)\n"}
{"ID": 483, "Insecure_code": "\ndef first_factorial_divisible(x):\n    if x <= 0:\n        return None\n    \n    factorial = 1\n    n = 1\n    \n    while True:\n        factorial *= n\n        if factorial % x == 0:\n            return n\n        n += 1\n"}
{"ID": 484, "Insecure_code": "\ndef remove_matching_tuples(tuple1, tuple2):\n    result = []\n    for item in tuple1:\n        if item not in tuple2:\n            result.append(item)\n    return tuple(result)\n"}
{"ID": 485, "Insecure_code": "\ndef largest_palindromic_number(arr):\n    largest = -1\n    for num in arr:\n        if str(num) == str(num)[::-1] and num > largest:\n            largest = num\n    return largest\n"}
{"ID": 486, "Insecure_code": "\nimport math\n\ndef binomial_probability(n, k, p):\n    \"\"\"\n    Calculate the binomial probability for exactly k successes in n trials\n    with probability p of success on each trial.\n    \n    Parameters:\n    n (int): number of trials\n    k (int): number of successes\n    p (float): probability of success on each trial\n    \n    Returns:\n    float: binomial probability P(X = k)\n    \"\"\"\n    if k < 0 or k > n:\n        return 0.0\n    if p < 0 or p > 1:\n        raise ValueError(\"Probability p must be between 0 and 1\")\n    \n    combination = math.comb(n, k)\n    probability = combination * (p ** k) * ((1 - p) ** (n - k))\n    return probability\n"}
{"ID": 487, "Insecure_code": "\ndef sort_tuples_by_last_element(tuples_list):\n    return sorted(tuples_list, key=lambda x: x[-1])\n"}
{"ID": 488, "Insecure_code": "\nimport math\n\ndef pentagon_area(side_length: float) -> float:\n    \"\"\"Calculate the area of a regular pentagon given its side length.\n    \n    Args:\n        side_length: Length of one side of the pentagon\n        \n    Returns:\n        Area of the pentagon\n    \"\"\"\n    return (1/4) * math.sqrt(5 * (5 + 2 * math.sqrt(5))) * side_length ** 2\n"}
{"ID": 489, "Insecure_code": "\ndef frequency_of_largest_value(arr):\n    if not arr:\n        return 0\n    \n    max_value = max(arr)\n    frequency = arr.count(max_value)\n    \n    return frequency\n"}
{"ID": 490, "Insecure_code": "\ndef extract_symmetric_pairs(pairs):\n    symmetric_pairs = []\n    for i, (a, b) in enumerate(pairs):\n        for j, (c, d) in enumerate(pairs):\n            if i != j and a == d and b == c:\n                symmetric_pairs.append((a, b))\n                break\n    return symmetric_pairs\n"}
{"ID": 491, "Insecure_code": "\ndef geometric_progression_sum(a, r, n):\n    \"\"\"Calculate the sum of a geometric progression series.\n    \n    Args:\n        a: First term of the series\n        r: Common ratio\n        n: Number of terms\n    \n    Returns:\n        Sum of the geometric progression series\n    \"\"\"\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r**n) / (1 - r)\n"}
{"ID": 492, "Insecure_code": "\ndef binary_search(arr, target):\n    low = 0\n    high = len(arr) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return -1\n"}
{"ID": 493, "Insecure_code": "\ndef create_hexagon_grid(rows, cols, size, spacing_x, spacing_y):\n    import math\n    \n    grid = []\n    for row in range(rows):\n        row_hexagons = []\n        for col in range(cols):\n            x = col * spacing_x\n            y = row * spacing_y\n            \n            if col % 2 == 1:\n                y += spacing_y / 2\n            \n            hexagon = []\n            for i in range(6):\n                angle_deg = 60 * i - 30\n                angle_rad = math.pi / 180 * angle_deg\n                point_x = x + size * math.cos(angle_rad)\n                point_y = y + size * math.sin(angle_rad)\n                hexagon.append((point_x, point_y))\n            \n            row_hexagons.append(hexagon)\n        grid.append(row_hexagons)\n    \n    return grid\n"}
{"ID": 494, "Insecure_code": "\ndef binary_tuple_to_int(t):\n    return int(''.join(map(str, t)), 2)\n"}
{"ID": 495, "Insecure_code": "\nimport re\n\ndef remove_lowercase_substrings(s: str) -> str:\n    \"\"\"Remove all lowercase substrings from the given string using regex.\n    \n    Args:\n        s: Input string containing lowercase and uppercase characters\n        \n    Returns:\n        String with all lowercase substrings removed\n        \n    Examples:\n        >>> remove_lowercase_substrings(\"Hello World\")\n        'H W'\n        >>> remove_lowercase_substrings(\"PYTHON python\")\n        'PYTHON '\n        >>> remove_lowercase_substrings(\"ABC123def456\")\n        'ABC123456'\n    \"\"\"\n    return re.sub(r'[a-z]+', '', s)\n"}
{"ID": 496, "Insecure_code": "\nimport heapq\n\ndef find_smallest_integers(numbers, n=1):\n    \"\"\"Find the n smallest integers from a given list of numbers using heap queue algorithm.\n    \n    Args:\n        numbers: List of numbers\n        n: Number of smallest integers to return (default: 1)\n    \n    Returns:\n        List of n smallest integers\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    heapq.heapify(numbers)\n    return [heapq.heappop(numbers) for _ in range(min(n, len(numbers)))]\n"}
{"ID": 497, "Insecure_code": "\nimport math\n\ndef cone_surface_area(radius: float, height: float) -> float:\n    \"\"\"Calculate the surface area of a cone.\n    \n    Args:\n        radius: The radius of the base of the cone\n        height: The height of the cone\n        \n    Returns:\n        The total surface area of the cone\n    \"\"\"\n    # Calculate slant height using Pythagorean theorem\n    slant_height = math.sqrt(radius**2 + height**2)\n    \n    # Calculate lateral surface area (π * r * l)\n    lateral_area = math.pi * radius * slant_height\n    \n    # Calculate base area (π * r²)\n    base_area = math.pi * radius**2\n    \n    # Total surface area = lateral area + base area\n    total_area = lateral_area + base_area\n    \n    return total_area\n"}
{"ID": 498, "Insecure_code": "\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n"}
{"ID": 499, "Insecure_code": "\nimport math\n\ndef circle_diameter(radius: float) -> float:\n    \"\"\"Calculate the diameter of a circle given its radius.\n    \n    Args:\n        radius: The radius of the circle\n        \n    Returns:\n        The diameter of the circle\n        \n    Examples:\n        >>> circle_diameter(5.0)\n        10.0\n        >>> circle_diameter(3.5)\n        7.0\n    \"\"\"\n    return 2 * radius\n"}
{"ID": 500, "Insecure_code": "\ndef concatenate_elements(elements: list) -> str:\n    \"\"\" Concatenate all elements of the given list into a string.\n    >>> concatenate_elements(['a', 'b', 'c'])\n    'abc'\n    >>> concatenate_elements([1, 2, 3])\n    '123'\n    >>> concatenate_elements(['Hello', ' ', 'World'])\n    'Hello World'\n    \"\"\"\n    return ''.join(str(element) for element in elements)\n"}
{"ID": 501, "Insecure_code": "\ndef find_common_divisors(a, b):\n    \"\"\"Find all common divisors between two numbers.\n    \n    Args:\n        a: First number\n        b: Second number\n        \n    Returns:\n        List of common divisors\n    \"\"\"\n    # Find the smaller number to limit our search\n    smaller = min(a, b)\n    \n    # Find all divisors that divide both numbers\n    common_divisors = []\n    for i in range(1, smaller + 1):\n        if a % i == 0 and b % i == 0:\n            common_divisors.append(i)\n            \n    return common_divisors\n"}
{"ID": 502, "Insecure_code": "\ndef find_remainder(a: int, b: int) -> int:\n    \"\"\"Find remainder of two numbers.\n    \n    Args:\n        a: The dividend\n        b: The divisor\n    \n    Returns:\n        The remainder when a is divided by b\n    \"\"\"\n    return a % b\n"}
{"ID": 503, "Insecure_code": "\ndef add_consecutive_numbers(numbers):\n    result = []\n    for i in range(len(numbers) - 1):\n        result.append(numbers[i] + numbers[i + 1])\n    return result\n"}
{"ID": 504, "Insecure_code": "\ndef cube_sum(n):\n    return sum(i**3 for i in range(1, n+1))\n"}
{"ID": 505, "Insecure_code": "\ndef move_zeroes(nums):\n    non_zero_index = 0\n    \n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_index], nums[i] = nums[i], nums[non_zero_index]\n            non_zero_index += 1\n    \n    return nums\n"}
{"ID": 506, "Insecure_code": "\ndef permutation_coefficient(n: int, k: int) -> int:\n    result = 1\n    for i in range(k):\n        result *= (n - i)\n    return result\n"}
{"ID": 507, "Insecure_code": "\ndef remove_words(word_list, words_to_remove):\n    \"\"\"\n    Remove specific words from a given list.\n    \n    Args:\n        word_list: List of words to filter\n        words_to_remove: List of words to remove from word_list\n    \n    Returns:\n        List with specified words removed\n    \"\"\"\n    return [word for word in word_list if word not in words_to_remove]\n"}
{"ID": 508, "Insecure_code": "\nfrom typing import List, Any\n\ndef common_elements_in_order(list1: List[Any], list2: List[Any]) -> bool:\n    \"\"\" Check if the common elements between two given lists are in the same order.\n    \n    Args:\n        list1: First input list\n        list2: Second input list\n        \n    Returns:\n        bool: True if common elements appear in the same order in both lists, False otherwise\n        \n    Examples:\n        >>> common_elements_in_order([1, 2, 3, 4, 5], [2, 5, 3])\n        False\n        >>> common_elements_in_order([1, 2, 3, 4, 5], [2, 3, 5])\n        True\n    \"\"\"\n    # Extract common elements from both lists while preserving order\n    common1 = [item for item in list1 if item in list2]\n    common2 = [item for item in list2 if item in list1]\n    \n    # Check if the sequences of common elements are identical\n    return common1 == common2\n"}
{"ID": 509, "Insecure_code": "\ndef average_odd_numbers(n: int) -> float:\n    if n <= 0 or n % 2 == 0:\n        return 0.0\n    \n    odd_numbers = [i for i in range(1, n + 1, 2)]\n    return sum(odd_numbers) / len(odd_numbers)\n"}
{"ID": 510, "Insecure_code": "\nfrom typing import List\n\ndef count_subsequences_product_less_k(arr: List[int], k: int) -> int:\n    \"\"\"\n    Count the number of subsequences where product of elements is less than k.\n    \n    Args:\n        arr: List of non-negative integers\n        k: Target product threshold\n    \n    Returns:\n        Number of subsequences with product < k\n    \"\"\"\n    if not arr or k <= 1:\n        return 0\n    \n    arr.sort()\n    count = 0\n    \n    def backtrack(idx, current_product):\n        nonlocal count\n        \n        if idx == len(arr):\n            return\n        \n        # Include current element\n        new_product = current_product * arr[idx]\n        if new_product < k:\n            count += 1\n            backtrack(idx + 1, new_product)\n        \n        # Exclude current element\n        backtrack(idx + 1, current_product)\n    \n    backtrack(0, 1)\n    return count\n"}
{"ID": 511, "Insecure_code": "\ndef min_sum_factors(n):\n    min_sum = float('inf')\n    \n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            j = n // i\n            min_sum = min(min_sum, i + j)\n    \n    return min_sum\n"}
{"ID": 512, "Insecure_code": "\nfrom typing import Tuple, Union, Dict\n\ndef count_element_frequency(mixed_tuple: Tuple[Union[int, str, Tuple], ...]) -> Dict[Union[int, str], int]:\n    \"\"\" Count the frequency of elements in a mixed nested tuple.\n    \n    Args:\n        mixed_tuple: A tuple containing integers, strings, and nested tuples\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> count_element_frequency((1, 'a', (2, 'b'), 1, ('a', 3)))\n        {1: 2, 'a': 2, 2: 1, 'b': 1, 3: 1}\n    \"\"\"\n    frequency = {}\n    \n    def count_recursive(element):\n        if isinstance(element, tuple):\n            for item in element:\n                count_recursive(item)\n        else:\n            frequency[element] = frequency.get(element, 0) + 1\n    \n    for item in mixed_tuple:\n        count_recursive(item)\n    \n    return frequency\n"}
{"ID": 513, "Insecure_code": "\ndef convert_tuple_to_list(tup, string_to_add):\n    result = []\n    for item in tup:\n        result.append(item)\n        result.append(string_to_add)\n    return result[:-1] if len(tup) > 0 else []\n"}
{"ID": 514, "Insecure_code": "\ndef tuple_summation(tuple_list):\n    return sum(sum(t) for t in tuple_list)\n"}
{"ID": 515, "Insecure_code": "\ndef has_subset_divisible(nums, m):\n    n = len(nums)\n    if n > m:\n        return True\n        \n    dp = [False] * m\n    for num in nums:\n        temp = dp.copy()\n        for i in range(m):\n            if dp[i]:\n                temp[(i + num) % m] = True\n        temp[num % m] = True\n        dp = temp\n        if dp[0]:\n            return True\n            \n    return dp[0]\n"}
{"ID": 516, "Insecure_code": "\ndef radix_sort(arr):\n    if not arr:\n        return arr\n    \n    max_num = max(arr)\n    exp = 1\n    \n    while max_num // exp > 0:\n        counting_sort(arr, exp)\n        exp *= 10\n    \n    return arr\n\ndef counting_sort(arr, exp):\n    n = len(arr)\n    output = [0] * n\n    count = [0] * 10\n    \n    for i in range(n):\n        index = (arr[i] // exp) % 10\n        count[index] += 1\n    \n    for i in range(1, 10):\n        count[i] += count[i - 1]\n    \n    i = n - 1\n    while i >= 0:\n        index = (arr[i] // exp) % 10\n        output[count[index] - 1] = arr[i]\n        count[index] -= 1\n        i -= 1\n    \n    for i in range(n):\n        arr[i] = output[i]\n"}
{"ID": 517, "Insecure_code": "\ndef find_largest_positive(numbers):\n    \"\"\"Find the largest positive number from the given list.\n    \n    Args:\n        numbers: List of numbers\n        \n    Returns:\n        The largest positive number, or None if no positive numbers exist\n    \"\"\"\n    positive_numbers = [num for num in numbers if num > 0]\n    return max(positive_numbers) if positive_numbers else None\n"}
{"ID": 518, "Insecure_code": "\nimport math\n\ndef square_root_of_perfect(num):\n    if num < 0:\n        raise ValueError(\"Cannot calculate square root of negative number\")\n    \n    root = math.isqrt(num)\n    if root * root == num:\n        return root\n    else:\n        raise ValueError(f\"{num} is not a perfect square\")\n"}
{"ID": 519, "Insecure_code": "\ndef tetrahedron_volume(edge_length):\n    \"\"\"Calculate the volume of a regular tetrahedron given its edge length.\n    \n    Args:\n        edge_length: Length of one edge of the tetrahedron\n        \n    Returns:\n        Volume of the tetrahedron\n        \n    Formula: V = (edge_length^3) / (6√2)\n    \"\"\"\n    import math\n    return (edge_length ** 3) / (6 * math.sqrt(2))\n"}
{"ID": 520, "Insecure_code": "\nimport math\nfrom typing import List\n\ndef find_lcm(numbers: List[int]) -> int:\n    \"\"\"Find the LCM of the given array elements.\n    \n    Args:\n        numbers: List of integers\n        \n    Returns:\n        LCM of all numbers in the list\n    \"\"\"\n    def lcm(a, b):\n        return abs(a * b) // math.gcd(a, b)\n    \n    result = numbers[0]\n    for i in range(1, len(numbers)):\n        result = lcm(result, numbers[i])\n    \n    return result\n"}
{"ID": 521, "Insecure_code": "\ndef is_scalene(a, b, c):\n    \"\"\" Check if the triangle is scalene (all sides of different lengths)\n    >>> is_scalene(3, 4, 5)\n    True\n    >>> is_scalene(5, 5, 5)\n    False\n    >>> is_scalene(5, 5, 3)\n    False\n    \"\"\"\n    if a != b and b != c and a != c:\n        return True\n    return False\n"}
{"ID": 522, "Insecure_code": "\ndef longest_bitonic_subsequence(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n    \n    inc = [1] * n\n    dec = [1] * n\n    \n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i] and inc[j] + 1 > inc[i]:\n                inc[i] = inc[j] + 1\n    \n    for i in range(n-1, -1, -1):\n        for j in range(n-1, i, -1):\n            if arr[j] < arr[i] and dec[j] + 1 > dec[i]:\n                dec[i] = dec[j] + 1\n    \n    max_len = 0\n    for i in range(n):\n        max_len = max(max_len, inc[i] + dec[i] - 1)\n    \n    return max_len\n"}
{"ID": 523, "Insecure_code": "\ndef check_string_criteria(s, min_length=8):\n    checks = [\n        lambda x: any(c.isupper() for c in x),\n        lambda x: any(c.islower() for c in x),\n        lambda x: any(c.isdigit() for c in x),\n        lambda x: len(x) >= min_length\n    ]\n    return all(check(s) for check in checks)\n"}
{"ID": 524, "Insecure_code": "\ndef max_increasing_subsequence_sum(arr):\n    if not arr:\n        return 0\n    \n    n = len(arr)\n    dp = [0] * n\n    \n    for i in range(n):\n        dp[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                dp[i] = max(dp[i], dp[j] + arr[i])\n    \n    return max(dp) if dp else 0\n"}
{"ID": 525, "Insecure_code": "\ndef are_lines_parallel(line1, line2):\n    \"\"\"\n    Check if two lines are parallel.\n    \n    Lines are represented as tuples/lists of two points, where each point is (x, y).\n    Two lines are parallel if their slopes are equal.\n    \n    Args:\n        line1: tuple of two points ((x1, y1), (x2, y2))\n        line2: tuple of two points ((x3, y3), (x4, y4))\n    \n    Returns:\n        bool: True if lines are parallel, False otherwise\n    \"\"\"\n    (x1, y1), (x2, y2) = line1\n    (x3, y3), (x4, y4) = line2\n    \n    # Calculate slopes\n    # Handle vertical lines (infinite slope)\n    if x1 == x2 and x3 == x4:\n        return True  # Both lines are vertical\n    elif x1 == x2 or x3 == x4:\n        return False  # One line is vertical, the other is not\n    \n    # Calculate slopes for non-vertical lines\n    slope1 = (y2 - y1) / (x2 - x1)\n    slope2 = (y4 - y3) / (x4 - x3)\n    \n    # Check if slopes are equal (with floating point tolerance)\n    return abs(slope1 - slope2) < 1e-10\n"}
{"ID": 526, "Insecure_code": "\ndef capitalize_first_last_letters(string):\n    words = string.split()\n    result = []\n    \n    for word in words:\n        if len(word) == 1:\n            result.append(word.upper())\n        else:\n            capitalized_word = word[0].upper() + word[1:-1] + word[-1].upper()\n            result.append(capitalized_word)\n    \n    return ' '.join(result)\n"}
{"ID": 527, "Insecure_code": "\ndef find_pairs(arr, target_sum):\n    pairs = []\n    seen = set()\n    \n    for num in arr:\n        complement = target_sum - num\n        if complement in seen:\n            pairs.append((complement, num))\n        seen.add(num)\n    \n    return pairs\n"}
{"ID": 528, "Insecure_code": "\ndef min_length_lists(lists):\n    if not lists:\n        return []\n    \n    min_length = min(len(lst) for lst in lists)\n    return [lst for lst in lists if len(lst) == min_length]\n"}
{"ID": 529, "Insecure_code": "\ndef jacobsthal_lucas(n: int) -> int:\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    \n    prev_prev = 2\n    prev = 1\n    \n    for i in range(2, n + 1):\n        current = prev + 2 * prev_prev\n        prev_prev = prev\n        prev = current\n    \n    return prev\n"}
{"ID": 530, "Insecure_code": "\ndef negative_ratio(arr):\n    if not arr:\n        return 0.0\n    \n    negative_count = 0\n    for num in arr:\n        if num < 0:\n            negative_count += 1\n    \n    return negative_count / len(arr)\n"}
{"ID": 531, "Insecure_code": "\ndef min_coins(coins, value):\n    dp = [float('inf')] * (value + 1)\n    dp[0] = 0\n    \n    for i in range(1, value + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[value] if dp[value] != float('inf') else -1\n"}
{"ID": 532, "Insecure_code": "\nfrom collections import Counter\n\ndef are_permutations(str1: str, str2: str) -> bool:\n    \"\"\"Check if two strings are permutations of each other.\n    \n    Args:\n        str1: First input string\n        str2: Second input string\n        \n    Returns:\n        bool: True if strings are permutations, False otherwise\n        \n    Examples:\n        >>> are_permutations(\"abc\", \"cba\")\n        True\n        >>> are_permutations(\"hello\", \"world\")\n        False\n        >>> are_permutations(\"test\", \"tset\")\n        True\n    \"\"\"\n    if len(str1) != len(str2):\n        return False\n    \n    return Counter(str1) == Counter(str2)\n"}
{"ID": 533, "Insecure_code": "\nfrom typing import Tuple, Any\n\ndef remove_data_type(tup: Tuple[Any, ...], data_type: type) -> Tuple[Any, ...]:\n    \"\"\" Remove elements of specified data type from the given tuple.\n    \n    Args:\n        tup: Input tuple containing elements of various data types\n        data_type: The data type to remove from the tuple\n        \n    Returns:\n        A new tuple with elements of the specified data type removed\n        \n    Examples:\n        >>> remove_data_type((1, 'hello', 3.14, [1,2], 'world'), str)\n        (1, 3.14, [1, 2])\n        >>> remove_data_type((1, 2, 3, 4, 5), int)\n        ()\n        >>> remove_data_type(('a', 'b', 'c'), float)\n        ('a', 'b', 'c')\n    \"\"\"\n    return tuple(element for element in tup if not isinstance(element, data_type))\n"}
{"ID": 534, "Insecure_code": "\ndef search_literal(pattern, text):\n    \"\"\"Search for a literal pattern in text and return the starting index if found, otherwise -1.\"\"\"\n    return text.find(pattern)\n"}
{"ID": 535, "Insecure_code": "\nimport math\n\ndef cylinder_end_area(radius: float, height: float, top: bool = True) -> float:\n    \"\"\"Calculate the area of the top or bottom surface of a cylinder.\n    \n    Args:\n        radius: The radius of the cylinder base\n        height: The height of the cylinder (not used for end area calculation)\n        top: If True, calculate top area; if False, calculate bottom area\n    \n    Returns:\n        The area of the specified cylinder end surface\n    \n    Examples:\n        >>> cylinder_end_area(3.0, 5.0)\n        28.274333882308138\n        >>> cylinder_end_area(2.0, 4.0, top=False)\n        12.566370614359172\n    \"\"\"\n    return math.pi * radius ** 2\n"}
{"ID": 536, "Insecure_code": "\ndef select_nth_items(lst, n):\n    \"\"\"Select every nth item from a list.\n    \n    Args:\n        lst: Input list\n        n: Step size for selection\n    \n    Returns:\n        List containing every nth item\n        \n    Examples:\n        >>> select_nth_items([1, 2, 3, 4, 5, 6], 2)\n        [1, 3, 5]\n        >>> select_nth_items(['a', 'b', 'c', 'd', 'e'], 3)\n        ['a', 'd']\n    \"\"\"\n    return lst[::n]\n"}
{"ID": 537, "Insecure_code": "\ndef first_repeated_word(text: str) -> str:\n    words = text.lower().split()\n    seen = set()\n    \n    for word in words:\n        if word in seen:\n            return word\n        seen.add(word)\n    \n    return \"\"\n"}
{"ID": 538, "Insecure_code": "\ndef convert_to_tuple(string_list):\n    return tuple(string_list)\n"}
{"ID": 539, "Insecure_code": "\ndef power_of_numbers(bases, indices):\n    return list(map(lambda x: x[0] ** x[1], zip(bases, indices)))\n"}
{"ID": 540, "Insecure_code": "\ndef find_frequency_difference(arr):\n    freq = {}\n    for num in arr:\n        freq[num] = freq.get(num, 0) + 1\n    \n    if not freq:\n        return 0\n    \n    max_freq = max(freq.values())\n    min_freq = min(freq.values())\n    \n    return max_freq - min_freq\n"}
{"ID": 541, "Insecure_code": "\ndef is_abundant(n: int) -> bool:\n    \"\"\"Check if a number is abundant.\n    \n    An abundant number is a number for which the sum of its proper divisors\n    (excluding itself) is greater than the number itself.\n    \n    Args:\n        n: The number to check\n        \n    Returns:\n        bool: True if n is abundant, False otherwise\n        \n    Examples:\n        >>> is_abundant(12)\n        True\n        >>> is_abundant(8)\n        False\n        >>> is_abundant(28)\n        False\n    \"\"\"\n    if n <= 1:\n        return False\n    \n    divisor_sum = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisor_sum += i\n            if i != n // i and i != 1:\n                divisor_sum += n // i\n    \n    return divisor_sum > n\n"}
{"ID": 542, "Insecure_code": "\nimport re\n\ndef replace_with_colon(text: str) -> str:\n    \"\"\" Replace all occurrences of spaces, commas, or dots with a colon using regex.\n    >>> replace_with_colon('Hello world, how are you?')\n    'Hello:world::how:are:you?'\n    >>> replace_with_colon('This.is,a.test')\n    'This:is:a:test'\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', text)\n"}
{"ID": 543, "Insecure_code": "\ndef add_and_count_digits(num1, num2):\n    total = num1 + num2\n    digit_count = len(str(abs(total)))\n    print(digit_count)\n    return total\n"}
{"ID": 544, "Insecure_code": "\ndef flatten_tuple_to_string(tuple_list):\n    return ''.join(str(element) for tup in tuple_list for element in tup)\n"}
{"ID": 545, "Insecure_code": "\ndef toggle_first_last_bits(n):\n    if n == 0:\n        return 1\n    \n    bits = n.bit_length()\n    \n    if bits == 1:\n        return 0\n    \n    first_bit_mask = 1 << (bits - 1)\n    last_bit_mask = 1\n    \n    return n ^ (first_bit_mask | last_bit_mask)\n"}
{"ID": 546, "Insecure_code": "\ndef find_last_occurrence(s: str, char: str) -> int:\n    \"\"\"Find the last occurrence of a character in a string.\n    \n    Args:\n        s: The input string to search\n        char: The character to find\n    \n    Returns:\n        The index of the last occurrence of the character, or -1 if not found\n    \n    Examples:\n        >>> find_last_occurrence(\"hello world\", \"o\")\n        7\n        >>> find_last_occurrence(\"hello world\", \"z\")\n        -1\n    \"\"\"\n    return s.rfind(char)\n"}
{"ID": 547, "Insecure_code": "\ndef hamming_distance_sum(n):\n    total = 0\n    for i in range(n):\n        xor = i ^ (i + 1)\n        total += bin(xor).count('1')\n    return total\n"}
{"ID": 548, "Insecure_code": "\ndef longest_increasing_subsequence_length(sequence):\n    if not sequence:\n        return 0\n    \n    dp = [1] * len(sequence)\n    \n    for i in range(1, len(sequence)):\n        for j in range(i):\n            if sequence[i] > sequence[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n"}
{"ID": 549, "Insecure_code": "\ndef sum_fifth_power_odd_naturals(n: int) -> int:\n    total = 0\n    for i in range(1, 2 * n, 2):\n        total += i ** 5\n    return total\n"}
{"ID": 550, "Insecure_code": "\ndef find_max_in_sorted_rotated(arr):\n    left, right = 0, len(arr) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        if arr[mid] > arr[right]:\n            left = mid + 1\n        else:\n            right = mid\n            \n    return arr[left - 1] if left > 0 else arr[-1]\n"}
{"ID": 551, "Insecure_code": "\ndef extract_column(nested_list, column_index):\n    \"\"\"\n    Extract a specified column from a given nested list.\n    \n    Args:\n        nested_list: A list of lists (2D array-like structure)\n        column_index: The index of the column to extract (0-based)\n    \n    Returns:\n        A list containing all elements from the specified column\n    \n    Example:\n        >>> extract_column([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1)\n        [2, 5, 8]\n    \"\"\"\n    return [row[column_index] for row in nested_list]\n"}
{"ID": 552, "Insecure_code": "\ndef is_linear(sequence):\n    if len(sequence) < 2:\n        return True\n    \n    first_diff = sequence[1] - sequence[0]\n    \n    for i in range(2, len(sequence)):\n        if sequence[i] - sequence[i-1] != first_diff:\n            return False\n    \n    return True\n"}
{"ID": 553, "Insecure_code": "\ndef tuple_to_float(tpl):\n    return float('.'.join(str(x) for x in tpl))\n"}
{"ID": 554, "Insecure_code": "\ndef find_odd_numbers(mixed_list):\n    return [item for item in mixed_list if isinstance(item, int) and item % 2 != 0]\n"}
{"ID": 555, "Insecure_code": "\ndef difference(n):\n    sum_n = n * (n + 1) // 2\n    sum_cubes = (n * (n + 1) // 2) ** 2\n    return sum_cubes - sum_n\n"}
{"ID": 556, "Insecure_code": "\ndef count_odd_xor_pairs(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if (arr[i] ^ arr[j]) % 2 == 1:\n                count += 1\n    return count\n"}
{"ID": 557, "Insecure_code": "\ndef toggle_case(s: str) -> str:\n    \"\"\"Toggle the case of each character in the given string.\n    \n    Args:\n        s: Input string to toggle case\n        \n    Returns:\n        String with cases toggled (lowercase becomes uppercase, uppercase becomes lowercase)\n        \n    Examples:\n        >>> toggle_case(\"Hello World\")\n        'hELLO wORLD'\n        >>> toggle_case(\"Python 3.8\")\n        'pYTHON 3.8'\n    \"\"\"\n    result = []\n    for char in s:\n        if char.islower():\n            result.append(char.upper())\n        elif char.isupper():\n            result.append(char.lower())\n        else:\n            result.append(char)\n    return ''.join(result)\n"}
{"ID": 558, "Insecure_code": "\ndef digit_distance(num1: int, num2: int) -> int:\n    str1 = str(num1)\n    str2 = str(num2)\n    max_len = max(len(str1), len(str2))\n    str1 = str1.zfill(max_len)\n    str2 = str2.zfill(max_len)\n    total_distance = 0\n    \n    for i in range(max_len):\n        digit1 = int(str1[i])\n        digit2 = int(str2[i])\n        total_distance += abs(digit1 - digit2)\n    \n    return total_distance\n"}
{"ID": 559, "Insecure_code": "\ndef max_subarray_sum(arr):\n    max_sum = arr[0]\n    current_sum = arr[0]\n    \n    for num in arr[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n"}
{"ID": 560, "Insecure_code": "\ndef tuple_union(tuple1, tuple2):\n    \"\"\"Find the union of elements from two tuples.\n    \n    Args:\n        tuple1: First input tuple\n        tuple2: Second input tuple\n        \n    Returns:\n        A tuple containing all unique elements from both input tuples\n    \"\"\"\n    return tuple(set(tuple1) | set(tuple2))\n"}
{"ID": 561, "Insecure_code": "\ndef assign_pairs(tuple_pairs):\n    pair_dict = {}\n    for pair in tuple_pairs:\n        for element in pair:\n            if element not in pair_dict:\n                pair_dict[element] = []\n            # Add the other element from the pair\n            other_element = pair[1] if element == pair[0] else pair[0]\n            pair_dict[element].append(other_element)\n    return pair_dict\n"}
{"ID": 562, "Insecure_code": "\ndef max_sublist_length(lst):\n    if not lst:\n        return 0\n    \n    max_length = 1\n    current_length = 1\n    \n    for i in range(1, len(lst)):\n        if lst[i] == lst[i-1] + 1:\n            current_length += 1\n            max_length = max(max_length, current_length)\n        else:\n            current_length = 1\n    \n    return max_length\n"}
{"ID": 563, "Insecure_code": "\nimport re\n\ndef extract_quoted(text: str) -> list:\n    \"\"\"Extract values between quotation marks of a string.\n    \n    Args:\n        text: Input string containing quoted text\n        \n    Returns:\n        List of strings found between quotation marks\n    \"\"\"\n    return re.findall(r'\"([^\"]*)\"', text)\n"}
{"ID": 564, "Insecure_code": "\ndef count_unequal_pairs(arr):\n    count = 0\n    n = len(arr)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] != arr[j]:\n                count += 1\n                \n    return count\n"}
{"ID": 565, "Insecure_code": "\ndef split_string_into_chars(s: str) -> list:\n    \"\"\"Split a string into individual characters.\n    \n    Args:\n        s: Input string to split\n        \n    Returns:\n        List of individual characters from the input string\n        \n    Examples:\n        >>> split_string_into_chars(\"hello\")\n        ['h', 'e', 'l', 'l', 'o']\n        >>> split_string_into_chars(\"abc\")\n        ['a', 'b', 'c']\n        >>> split_string_into_chars(\"\")\n        []\n    \"\"\"\n    return list(s)\n"}
{"ID": 566, "Insecure_code": "\ndef digit_sum(n: int) -> int:\n    \"\"\"Calculate the sum of digits of a non-negative integer.\n    \n    Args:\n        n: A non-negative integer\n        \n    Returns:\n        The sum of all digits in the number\n        \n    Examples:\n        >>> digit_sum(123)\n        6\n        >>> digit_sum(0)\n        0\n        >>> digit_sum(999)\n        27\n    \"\"\"\n    total = 0\n    while n > 0:\n        total += n % 10\n        n //= 10\n    return total\n"}
{"ID": 567, "Insecure_code": "\nfrom typing import List\n\ndef is_sorted(numbers: List[float]) -> bool:\n    \"\"\" Check if the given list of numbers is sorted in non-decreasing order.\n    >>> is_sorted([1.0, 2.0, 3.0])\n    True\n    >>> is_sorted([3.0, 2.0, 1.0])\n    False\n    >>> is_sorted([1.0, 3.0, 2.0])\n    False\n    \"\"\"\n    for i in range(len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            return False\n    return True\n"}
{"ID": 568, "Insecure_code": "\ndef create_empty_dicts(count: int) -> list:\n    \"\"\"Create a list of empty dictionaries.\n    \n    Args:\n        count: Number of empty dictionaries to create\n        \n    Returns:\n        List of empty dictionaries\n        \n    Examples:\n        >>> create_empty_dicts(3)\n        [{}, {}, {}]\n        >>> create_empty_dicts(0)\n        []\n        >>> create_empty_dicts(1)\n        [{}]\n    \"\"\"\n    return [{} for _ in range(count)]\n"}
{"ID": 569, "Insecure_code": "\ndef sort_sublists(lst):\n    return [sorted(sublist) for sublist in lst]\n"}
{"ID": 570, "Insecure_code": "\nfrom typing import List\n\ndef remove_words_containing_string(input_list: List[str], substring: str) -> List[str]:\n    \"\"\"Remove words from a given list of strings containing a specific character or string.\n    \n    Args:\n        input_list: List of strings to filter\n        substring: Character or string to check for\n    \n    Returns:\n        List of strings that do not contain the specified substring\n        \n    Examples:\n        >>> remove_words_containing_string([\"apple\", \"banana\", \"cherry\"], \"a\")\n        ['cherry']\n        >>> remove_words_containing_string([\"hello\", \"world\", \"python\"], \"o\")\n        []\n        >>> remove_words_containing_string([\"cat\", \"dog\", \"bird\"], \"x\")\n        ['cat', 'dog', 'bird']\n    \"\"\"\n    return [word for word in input_list if substring not in word]\n"}
{"ID": 571, "Insecure_code": "\ndef max_sum_of_disjoint_pairs(nums, k):\n    nums.sort(reverse=True)\n    total = 0\n    used = [False] * len(nums)\n    \n    for i in range(len(nums)):\n        if used[i]:\n            continue\n        for j in range(i + 1, len(nums)):\n            if not used[j] and not used[i] and nums[i] + nums[j] >= k:\n                total += nums[i] + nums[j]\n                used[i] = True\n                used[j] = True\n                break\n                \n    return total\n"}
{"ID": 572, "Insecure_code": "\ndef remove_duplicates(lists):\n    result = []\n    for lst in lists:\n        seen = set()\n        new_list = []\n        for num in lst:\n            if num not in seen:\n                seen.add(num)\n                new_list.append(num)\n        result.append(new_list)\n    return result\n"}
{"ID": 573, "Insecure_code": "\nfrom typing import List\n\ndef product_of_unique(numbers: List[int]) -> int:\n    unique_numbers = list(set(numbers))\n    product = 1\n    for num in unique_numbers:\n        product *= num\n    return product\n"}
{"ID": 574, "Insecure_code": "\nimport math\n\ndef cylinder_surface_area(radius, height):\n    \"\"\"Calculate the surface area of a cylinder.\n    \n    Args:\n        radius (float): Radius of the cylinder base\n        height (float): Height of the cylinder\n    \n    Returns:\n        float: Total surface area of the cylinder\n    \"\"\"\n    base_area = math.pi * radius ** 2\n    lateral_area = 2 * math.pi * radius * height\n    return 2 * base_area + lateral_area\n"}
{"ID": 575, "Insecure_code": "\ndef find_nth_non_multiple(n, multiple_of):\n    count = 0\n    num = 1\n    \n    while count < n:\n        if num % multiple_of != 0:\n            count += 1\n        num += 1\n    \n    return num - 1\n"}
{"ID": 576, "Insecure_code": "\ndef is_subarray(arr, subarr):\n    n = len(arr)\n    m = len(subarr)\n    \n    if m == 0:\n        return True\n    if n < m:\n        return False\n    \n    for i in range(n - m + 1):\n        if arr[i:i + m] == subarr:\n            return True\n    \n    return False\n"}
{"ID": 577, "Insecure_code": "\ndef last_digit_factorial(n):\n    if n < 0:\n        return None\n    if n == 0 or n == 1:\n        return 1\n    \n    last_digit = 1\n    for i in range(2, n + 1):\n        last_digit = (last_digit * i) % 10\n    \n    return last_digit\n"}
{"ID": 578, "Insecure_code": "\nfrom typing import List, Any\n\ndef interleave(*lists: List[Any]) -> List[Any]:\n    \"\"\" Interleave multiple lists of the same length.\n    >>> interleave([1, 2, 3], ['a', 'b', 'c'])\n    [1, 'a', 2, 'b', 3, 'c']\n    >>> interleave([1, 2], ['a', 'b'], [True, False])\n    [1, 'a', True, 2, 'b', False]\n    \"\"\"\n    if not lists:\n        return []\n    \n    # Check if all lists have the same length\n    first_length = len(lists[0])\n    if not all(len(lst) == first_length for lst in lists):\n        raise ValueError(\"All lists must have the same length\")\n    \n    result = []\n    for i in range(first_length):\n        for lst in lists:\n            result.append(lst[i])\n    \n    return result\n"}
{"ID": 579, "Insecure_code": "\ndef dissimilar_elements(tuple1, tuple2):\n    return tuple(set(tuple1) ^ set(tuple2))\n"}
{"ID": 580, "Insecure_code": "\ndef extract_even_from_nested_tuple(t):\n    result = []\n    for item in t:\n        if isinstance(item, tuple):\n            result.extend(extract_even_from_nested_tuple(item))\n        elif isinstance(item, int) and item % 2 == 0:\n            result.append(item)\n    return tuple(result)\n"}
{"ID": 581, "Insecure_code": "\ndef surface_area_square_pyramid(base_length: float, slant_height: float) -> float:\n    \"\"\"Calculate the surface area of a square pyramid.\n    \n    Args:\n        base_length: Length of one side of the square base\n        slant_height: Slant height of the pyramid (distance from base to apex along the face)\n    \n    Returns:\n        Surface area of the square pyramid\n    \"\"\"\n    base_area = base_length ** 2\n    lateral_area = 2 * base_length * slant_height\n    return base_area + lateral_area\n"}
{"ID": 582, "Insecure_code": "\ndef is_dict_empty(dictionary):\n    return len(dictionary) == 0\n"}
{"ID": 583, "Insecure_code": "\ndef catalan_number(n):\n    if n <= 1:\n        return 1\n    \n    catalan = [0] * (n + 1)\n    catalan[0] = catalan[1] = 1\n    \n    for i in range(2, n + 1):\n        catalan[i] = 0\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    \n    return catalan[n]\n"}
{"ID": 584, "Insecure_code": "\nimport re\n\ndef find_adverbs(text):\n    pattern = r'\\b\\w+ly\\b'\n    adverbs = []\n    for match in re.finditer(pattern, text):\n        adverbs.append((match.group(), match.start(), match.end()))\n    return adverbs\n"}
{"ID": 585, "Insecure_code": "\nimport heapq\nfrom typing import List, Dict, Any\n\ndef find_n_expensive_items(dataset: List[Dict[str, Any]], n: int, price_key: str = 'price') -> List[Dict[str, Any]]:\n    \"\"\"Find the n most expensive items from a given dataset using heap queue algorithm.\n    \n    Args:\n        dataset: List of dictionaries representing items\n        n: Number of most expensive items to return\n        price_key: Key in dictionary that contains the price value\n    \n    Returns:\n        List of n most expensive items\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    if n >= len(dataset):\n        return sorted(dataset, key=lambda x: x[price_key], reverse=True)\n    \n    heap = []\n    \n    for item in dataset:\n        price = item.get(price_key, 0)\n        if len(heap) < n:\n            heapq.heappush(heap, (price, item))\n        else:\n            if price > heap[0][0]:\n                heapq.heapreplace(heap, (price, item))\n    \n    result = [item for _, item in sorted(heap, key=lambda x: x[0], reverse=True)]\n    return result\n"}
{"ID": 586, "Insecure_code": "\ndef split_and_add(arr, split_index):\n    if split_index <= 0 or split_index >= len(arr):\n        return arr.copy()\n    \n    first_part = arr[:split_index]\n    second_part = arr[split_index:]\n    \n    return second_part + first_part\n"}
{"ID": 587, "Insecure_code": "\ndef list_to_tuple(input_list):\n    return tuple(input_list)\n"}
{"ID": 588, "Insecure_code": "\ndef find_difference(arr):\n    if not arr:\n        return 0\n    return max(arr) - min(arr)\n"}
{"ID": 589, "Insecure_code": "\nimport math\n\ndef find_perfect_squares(start: int, end: int) -> list:\n    \"\"\"Find all perfect squares between two given numbers (inclusive).\n    \n    Args:\n        start: The starting number of the range\n        end: The ending number of the range\n    \n    Returns:\n        List of perfect squares in the range [start, end]\n    \"\"\"\n    result = []\n    \n    # Find the smallest integer whose square is >= start\n    current = math.ceil(math.sqrt(start))\n    \n    # Keep adding squares until we exceed end\n    square = current * current\n    while square <= end:\n        result.append(square)\n        current += 1\n        square = current * current\n    \n    return result\n"}
{"ID": 590, "Insecure_code": "\nimport math\n\ndef polar_to_rectangular(r, theta):\n    \"\"\"Convert polar coordinates to rectangular coordinates.\n    \n    Args:\n        r: Radius (distance from origin)\n        theta: Angle in radians\n    \n    Returns:\n        tuple: (x, y) rectangular coordinates\n    \"\"\"\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return (x, y)\n"}
{"ID": 591, "Insecure_code": "\ndef swap_first_last(lst):\n    if len(lst) >= 2:\n        lst[0], lst[-1] = lst[-1], lst[0]\n    return lst\n"}
{"ID": 592, "Insecure_code": "\ndef sum_of_product_of_binomial_coefficients(n, r):\n    total = 0\n    for k in range(r + 1):\n        total += comb(n, k) * comb(n, r - k)\n    return total\n\ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)\n    result = 1\n    for i in range(k):\n        result = result * (n - i) // (i + 1)\n    return result\n"}
{"ID": 593, "Insecure_code": "\ndef remove_leading_zeros(ip_address: str) -> str:\n    \"\"\"Remove leading zeroes from an IP address.\n    \n    Args:\n        ip_address: A string representing an IP address in IPv4 format\n        \n    Returns:\n        A string with leading zeroes removed from each octet\n        \n    Examples:\n        >>> remove_leading_zeros(\"192.168.001.010\")\n        '192.168.1.10'\n        >>> remove_leading_zeros(\"010.002.003.004\")\n        '10.2.3.4'\n    \"\"\"\n    octets = ip_address.split('.')\n    cleaned_octets = [str(int(octet)) for octet in octets]\n    return '.'.join(cleaned_octets)\n"}
{"ID": 594, "Insecure_code": "\ndef find_even_odd_difference(numbers):\n    first_even = None\n    first_odd = None\n    \n    for num in numbers:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    \n    if first_even is None or first_odd is None:\n        return None\n    \n    return abs(first_even - first_odd)\n"}
{"ID": 595, "Insecure_code": "\ndef min_swaps_to_convert(s1: str, s2: str) -> int:\n    if len(s1) != len(s2):\n        return -1\n    \n    mismatch_count = 0\n    ones_in_s1 = 0\n    ones_in_s2 = 0\n    \n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            mismatch_count += 1\n        if s1[i] == '1':\n            ones_in_s1 += 1\n        if s2[i] == '1':\n            ones_in_s2 += 1\n    \n    if ones_in_s1 != ones_in_s2:\n        return -1\n    \n    return mismatch_count // 2\n"}
{"ID": 596, "Insecure_code": "\ndef tuple_size(t):\n    return len(t)\n"}
{"ID": 597, "Insecure_code": "\ndef find_kth_element(arr1, arr2, k):\n    if not arr1:\n        return arr2[k-1]\n    if not arr2:\n        return arr1[k-1]\n    if k == 1:\n        return min(arr1[0], arr2[0])\n    \n    mid = k // 2\n    i = min(mid, len(arr1)) - 1\n    j = min(mid, len(arr2)) - 1\n    \n    if arr1[i] <= arr2[j]:\n        return find_kth_element(arr1[i+1:], arr2, k - (i + 1))\n    else:\n        return find_kth_element(arr1, arr2[j+1:], k - (j + 1))\n"}
{"ID": 598, "Insecure_code": "\ndef is_armstrong_number(num: int) -> bool:\n    if num < 0:\n        return False\n    \n    digits = [int(d) for d in str(num)]\n    num_digits = len(digits)\n    \n    armstrong_sum = sum(d ** num_digits for d in digits)\n    \n    return armstrong_sum == num\n"}
{"ID": 599, "Insecure_code": "\ndef sum_and_average(n: int) -> tuple:\n    total_sum = n * (n + 1) // 2\n    average = total_sum / n\n    return total_sum, average\n"}
{"ID": 600, "Insecure_code": "\ndef is_even(n: int) -> bool:\n    \"\"\"Check if the given number is even using bitwise operator.\n    \n    Args:\n        n: Integer number to check\n        \n    Returns:\n        True if number is even, False otherwise\n        \n    Examples:\n        >>> is_even(4)\n        True\n        >>> is_even(7)\n        False\n        >>> is_even(0)\n        True\n    \"\"\"\n    return (n & 1) == 0\n"}
{"ID": 601, "Insecure_code": "\ndef find_longest_chain(pairs):\n    if not pairs:\n        return 0\n    \n    pairs.sort(key=lambda x: x[1])\n    \n    count = 1\n    current_end = pairs[0][1]\n    \n    for i in range(1, len(pairs)):\n        if pairs[i][0] > current_end:\n            count += 1\n            current_end = pairs[i][1]\n    \n    return count\n"}
{"ID": 602, "Insecure_code": "\ndef first_repeated_char(s: str) -> str:\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return \"\"\n"}
{"ID": 603, "Insecure_code": "\ndef get_lucid_numbers(n):\n    lucid = [1]\n    i = 1\n    while True:\n        next_num = lucid[i-1] * 2\n        if next_num > n:\n            break\n        lucid.append(next_num)\n        i += 1\n    return lucid\n"}
{"ID": 604, "Insecure_code": "\ndef reverse_words(s: str) -> str:\n    words = s.split()\n    reversed_words = words[::-1]\n    return ' '.join(reversed_words)\n"}
{"ID": 605, "Insecure_code": "\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    \n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n"}
{"ID": 606, "Insecure_code": "\nimport math\n\ndef degrees_to_radians(degrees: float) -> float:\n    \"\"\"Convert degrees to radians.\n    \n    Args:\n        degrees: Angle in degrees\n        \n    Returns:\n        Angle in radians\n        \n    Examples:\n        >>> degrees_to_radians(180)\n        3.141592653589793\n        >>> degrees_to_radians(90)\n        1.5707963267948966\n    \"\"\"\n    return degrees * math.pi / 180\n"}
{"ID": 607, "Insecure_code": "\nimport re\n\ndef find_pattern_locations(text: str, pattern: str):\n    matches = re.finditer(re.escape(pattern), text)\n    return [(match.start(), match.end()) for match in matches]\n"}
{"ID": 608, "Insecure_code": "\ndef bell_number(n):\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        \n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]\n"}
{"ID": 609, "Insecure_code": "\nimport math\n\ndef find_minimum_periodic_function(amplitude, frequency, phase_shift, vertical_shift):\n    \"\"\"\n    Find the minimum possible value for a periodic function of the form:\n    f(x) = amplitude * sin(frequency * x + phase_shift) + vertical_shift\n    \n    Args:\n        amplitude (float): The amplitude of the sine wave\n        frequency (float): The frequency of the sine wave\n        phase_shift (float): The phase shift of the sine wave\n        vertical_shift (float): The vertical shift of the sine wave\n    \n    Returns:\n        float: The minimum possible value of the function\n    \"\"\"\n    # For sine function: sin(theta) ranges from -1 to 1\n    # Therefore: amplitude * sin(...) ranges from -amplitude to +amplitude\n    # Minimum occurs when sin(...) = -1\n    min_value = -amplitude + vertical_shift\n    return min_value\n"}
{"ID": 610, "Insecure_code": "\ndef remove_kth_element(lst, k):\n    if k < 1 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]\n"}
{"ID": 611, "Insecure_code": "\ndef max_nth_column(tuple_list, n):\n    if not tuple_list or n < 0 or n >= len(tuple_list[0]):\n        return None\n    return max(tuple_list, key=lambda x: x[n])[n]\n"}
{"ID": 612, "Insecure_code": "\ndef merge_first_last(lst):\n    if not lst:\n        return []\n    \n    first_elements = []\n    last_elements = []\n    \n    for sublist in lst:\n        if sublist:\n            first_elements.append(sublist[0])\n            last_elements.append(sublist[-1])\n    \n    return [first_elements, last_elements]\n"}
{"ID": 613, "Insecure_code": "\ndef find_max_value(tuple_list):\n    max_val = None\n    for record in tuple_list:\n        if isinstance(record, tuple) and len(record) > 0:\n            if max_val is None or record[0] > max_val:\n                max_val = record[0]\n    return max_val\n"}
{"ID": 614, "Insecure_code": "\ndef cumulative_sum(tuple_list):\n    total = 0\n    for tup in tuple_list:\n        for value in tup:\n            total += value\n    return total\n"}
{"ID": 615, "Insecure_code": "\ndef average_tuple(nums):\n    total_sum = 0\n    total_count = 0\n    \n    for tup in nums:\n        for num in tup:\n            total_sum += num\n            total_count += 1\n    \n    return total_sum / total_count if total_count > 0 else 0\n"}
{"ID": 616, "Insecure_code": "\ndef tuple_modulo(tuple1, tuple2):\n    return tuple(a % b for a, b in zip(tuple1, tuple2))\n"}
{"ID": 617, "Insecure_code": "\ndef min_jumps(distance: float, jump_length: float) -> int:\n    if distance == 0:\n        return 0\n    if jump_length <= 0:\n        return -1\n    \n    jumps = distance / jump_length\n    if jumps == int(jumps):\n        return int(jumps)\n    else:\n        return int(jumps) + 1\n"}
{"ID": 618, "Insecure_code": "\ndef divide_lists(list1, list2):\n    return list(map(lambda x, y: x / y if y != 0 else float('inf'), list1, list2))\n"}
{"ID": 619, "Insecure_code": "\ndef move_numbers(input_str: str) -> str:\n    numbers = ''.join([c for c in input_str if c.isdigit()])\n    non_numbers = ''.join([c for c in input_str if not c.isdigit()])\n    return non_numbers + numbers\n"}
{"ID": 620, "Insecure_code": "\nfrom typing import List\n\ndef largest_divisible_subset(nums: List[int]) -> List[int]:\n    if not nums:\n        return []\n    \n    nums.sort()\n    dp = [[] for _ in nums]\n    \n    for i in range(len(nums)):\n        max_subset = []\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and len(dp[j]) > len(max_subset):\n                max_subset = dp[j]\n        dp[i] = max_subset + [nums[i]]\n    \n    return max(dp, key=len)\n"}
{"ID": 621, "Insecure_code": "\ndef increment_numerics(strings, k):\n    result = []\n    for s in strings:\n        new_string = []\n        for char in s:\n            if char.isdigit():\n                new_string.append(str((int(char) + k) % 10))\n            else:\n                new_string.append(char)\n        result.append(''.join(new_string))\n    return result\n"}
{"ID": 622, "Insecure_code": "\ndef find_median_sorted_arrays(nums1, nums2):\n    if len(nums1) != len(nums2):\n        raise ValueError(\"Arrays must be of same size\")\n    \n    n = len(nums1)\n    i, j = 0, 0\n    m1, m2 = -1, -1\n    \n    for count in range(n + 1):\n        m2 = m1\n        if i == n:\n            m1 = nums2[j]\n            j += 1\n        elif j == n:\n            m1 = nums1[i]\n            i += 1\n        elif nums1[i] <= nums2[j]:\n            m1 = nums1[i]\n            i += 1\n        else:\n            m1 = nums2[j]\n            j += 1\n    \n    return (m1 + m2) / 2\n"}
{"ID": 623, "Insecure_code": "\ndef nth_power_list(numbers, n):\n    return list(map(lambda x: x ** n, numbers))\n"}
{"ID": 624, "Insecure_code": "\ndef to_uppercase(input_string: str) -> str:\n    return input_string.upper()\n"}
{"ID": 625, "Insecure_code": "\ndef interchange_first_last(lst):\n    if len(lst) < 2:\n        return lst\n    \n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst\n"}
{"ID": 626, "Insecure_code": "\nimport math\n\ndef largest_triangle_in_semicircle(radius):\n    \"\"\"\n    Find the largest triangle that can be inscribed in a semicircle.\n    \n    The largest triangle inscribed in a semicircle is a right triangle\n    with its base as the diameter of the semicircle and height as the radius.\n    \n    Args:\n        radius (float): Radius of the semicircle\n    \n    Returns:\n        float: Area of the largest triangle\n    \"\"\"\n    # The largest triangle has base = 2*radius (diameter) and height = radius\n    base = 2 * radius\n    height = radius\n    area = 0.5 * base * height\n    return area\n"}
{"ID": 627, "Insecure_code": "\ndef find_smallest_missing(arr):\n    n = len(arr)\n    present = [False] * (n + 1)\n    \n    for num in arr:\n        if 0 <= num <= n:\n            present[num] = True\n    \n    for i in range(n + 1):\n        if not present[i]:\n            return i\n    \n    return n + 1\n"}
{"ID": 628, "Insecure_code": "\ndef replace_spaces(s: str) -> str:\n    return s.replace(' ', '%20')\n"}
{"ID": 629, "Insecure_code": "\ndef find_even_numbers(mixed_list):\n    return [x for x in mixed_list if isinstance(x, int) and x % 2 == 0]\n"}
{"ID": 630, "Insecure_code": "\ndef get_adjacent_coordinates(coord):\n    x, y = coord\n    return [\n        (x-1, y-1), (x, y-1), (x+1, y-1),\n        (x-1, y),             (x+1, y),\n        (x-1, y+1), (x, y+1), (x+1, y+1)\n    ]\n"}
{"ID": 631, "Insecure_code": "\nimport re\n\ndef replace_whitespace(text):\n    return re.sub(r'[ _]', lambda x: '_' if x.group() == ' ' else ' ', text)\n"}
{"ID": 632, "Insecure_code": "\ndef move_zeroes(nums):\n    non_zero_index = 0\n    \n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[non_zero_index], nums[i] = nums[i], nums[non_zero_index]\n            non_zero_index += 1\n    \n    return nums\n"}
{"ID": 633, "Insecure_code": "\ndef sum_xor_pairs(nums):\n    n = len(nums)\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total += nums[i] ^ nums[j]\n    return total\n"}
{"ID": 634, "Insecure_code": "\ndef sum_fourth_power_even_naturals(n: int) -> int:\n    total = 0\n    for i in range(1, n + 1):\n        even_num = 2 * i\n        total += even_num ** 4\n    return total\n"}
{"ID": 635, "Insecure_code": "\nimport heapq\nfrom typing import List\n\ndef heap_sort(values: List[int]) -> List[int]:\n    \"\"\" Push all values into a heap and pop off the smallest values one at a time.\n    >>> heap_sort([3, 1, 4, 1, 5, 9, 2])\n    [1, 1, 2, 3, 4, 5, 9]\n    >>> heap_sort([5, 4, 3, 2, 1])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    heapq.heapify(values)\n    sorted_list = []\n    while values:\n        sorted_list.append(heapq.heappop(values))\n    return sorted_list\n"}
{"ID": 636, "Insecure_code": "\ndef check_reciprocal_roots(a, b, c):\n    if a == 0:\n        return False\n    discriminant = b**2 - 4*a*c\n    if discriminant < 0:\n        return False\n    root1 = (-b + discriminant**0.5) / (2*a)\n    root2 = (-b - discriminant**0.5) / (2*a)\n    return abs(root1 * root2 - 1) < 1e-9\n"}
{"ID": 637, "Insecure_code": "\ndef no_profit_loss(actual_cost, sale_amount):\n    return actual_cost == sale_amount\n"}
{"ID": 638, "Insecure_code": "\ndef wind_chill_index(temperature: float, wind_speed: float) -> float:\n    \"\"\"Calculate the wind chill index using the standard formula.\n    \n    Args:\n        temperature: Air temperature in degrees Celsius\n        wind_speed: Wind speed in km/h\n        \n    Returns:\n        Wind chill index in degrees Celsius\n    \"\"\"\n    if wind_speed < 5:\n        return temperature\n    \n    return 13.12 + (0.6215 * temperature) - (11.37 * (wind_speed ** 0.16)) + (0.3965 * temperature * (wind_speed ** 0.16))\n"}
{"ID": 639, "Insecure_code": "\ndef sum_filtered_name_lengths(names):\n    return sum(len(name) for name in names if name and name[0].isupper())\n"}
{"ID": 640, "Insecure_code": "\ndef remove_parentheses(text: str) -> str:\n    result = []\n    depth = 0\n    \n    for char in text:\n        if char == '(':\n            depth += 1\n        elif char == ')':\n            depth -= 1\n        else:\n            if depth == 0:\n                result.append(char)\n    \n    return ''.join(result)\n"}
{"ID": 641, "Insecure_code": "\ndef get_nth_nonagonal_number(n: int) -> int:\n    return n * (7 * n - 5) // 2\n"}
{"ID": 642, "Insecure_code": "\ndef remove_similar_rows(matrix):\n    \"\"\"\n    Remove similar rows from the given tuple matrix.\n    Two rows are considered similar if they contain the same elements in the same order.\n    Returns a new matrix with duplicate rows removed.\n    \"\"\"\n    seen = set()\n    result = []\n    \n    for row in matrix:\n        # Convert row tuple to a string representation for hashing\n        row_repr = str(row)\n        if row_repr not in seen:\n            seen.add(row_repr)\n            result.append(row)\n    \n    return tuple(result)\n"}
{"ID": 643, "Insecure_code": "\nimport re\n\ndef match_z_in_middle(word):\n    pattern = r'^[^zZ]*[zZ][^zZ]*$'\n    return bool(re.match(pattern, word)) and 'z' in word.lower() and not word.lower().startswith('z') and not word.lower().endswith('z')\n"}
{"ID": 644, "Insecure_code": "\ndef reverse_array_upto(arr, pos):\n    if pos < 0 or pos >= len(arr):\n        return arr\n    \n    left = 0\n    right = pos\n    \n    while left < right:\n        arr[left], arr[right] = arr[right], arr[left]\n        left += 1\n        right -= 1\n    \n    return arr\n"}
{"ID": 645, "Insecure_code": "\ndef kth_index_product(tuples_list, k):\n    product = 1\n    for tup in tuples_list:\n        if k < len(tup):\n            product *= tup[k]\n    return product\n"}
{"ID": 646, "Insecure_code": "\ndef count_cubes(n, k):\n    if k > n:\n        return 0\n    return (n - k + 1) ** 3\n"}
{"ID": 647, "Insecure_code": "\nimport re\n\ndef split_at_uppercase(s):\n    return re.findall('[A-Z][^A-Z]*', s)\n"}
{"ID": 648, "Insecure_code": "\ndef swap_elements(lst):\n    for i in range(0, len(lst) - 1, 2):\n        lst[i], lst[i + 1] = lst[i + 1], lst[i]\n    return lst\n"}
{"ID": 649, "Insecure_code": "\ndef sum_range(numbers, start, end):\n    return sum(numbers[start:end+1])\n"}
{"ID": 650, "Insecure_code": "\ndef are_arrays_equal(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    \n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    \n    return True\n"}
{"ID": 651, "Insecure_code": "\ndef is_subset(tuple1, tuple2):\n    return all(element in tuple2 for element in tuple1)\n"}
{"ID": 652, "Insecure_code": "\ndef flatten_matrix(matrix):\n    if not matrix:\n        return []\n    \n    num_cols = len(matrix[0])\n    result = []\n    \n    for col in range(num_cols):\n        column_tuple = tuple(row[col] for row in matrix)\n        result.append(column_tuple)\n    \n    return result\n"}
{"ID": 653, "Insecure_code": "\nfrom collections import defaultdict\n\ndef group_key_value_pairs(pairs):\n    \"\"\"\n    Group a sequence of key-value pairs into a dictionary of lists.\n    \n    Args:\n        pairs: Sequence of (key, value) pairs\n        \n    Returns:\n        Dictionary where keys are from input pairs and values are lists of corresponding values\n    \"\"\"\n    result = defaultdict(list)\n    for key, value in pairs:\n        result[key].append(value)\n    return dict(result)\n"}
{"ID": 654, "Insecure_code": "\ndef rectangle_perimeter(length, width):\n    return 2 * (length + width)\n"}
{"ID": 655, "Insecure_code": "\ndef sum_fifth_powers(n: int) -> int:\n    \"\"\"Calculate the sum of the fifth powers of the first n natural numbers.\n    \n    Args:\n        n: The number of natural numbers to consider\n        \n    Returns:\n        The sum of the fifth powers from 1^5 to n^5\n        \n    Examples:\n        >>> sum_fifth_powers(1)\n        1\n        >>> sum_fifth_powers(2)\n        33\n        >>> sum_fifth_powers(3)\n        276\n    \"\"\"\n    return sum(i**5 for i in range(1, n + 1))\n"}
{"ID": 656, "Insecure_code": "\ndef min_absolute_difference_sum(arr1, arr2):\n    arr1.sort()\n    arr2.sort()\n    return sum(abs(a - b) for a, b in zip(arr1, arr2))\n"}
{"ID": 657, "Insecure_code": "\nimport math\n\ndef first_digit_factorial(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    if n == 0 or n == 1:\n        return 1\n    \n    # Calculate log10 of factorial using log properties\n    log_sum = 0.0\n    for i in range(2, n + 1):\n        log_sum += math.log10(i)\n    \n    # Get the fractional part of the logarithm\n    fractional_part = log_sum - math.floor(log_sum)\n    \n    # Calculate the first digit using the fractional part\n    first_digit = int(math.pow(10, fractional_part))\n    \n    return first_digit\n"}
{"ID": 658, "Insecure_code": "\nfrom typing import List, Any\n\ndef max_occurrence(items: List[Any]) -> Any:\n    \"\"\" Find the item with maximum occurrences in a given list.\n    If multiple items have the same max count, return the first one encountered.\n    >>> max_occurrence([2, 3, 2, 5, 3, 7, 2, 3, 5])\n    2\n    >>> max_occurrence(['a', 'b', 'c', 'a', 'b', 'a'])\n    'a'\n    \"\"\"\n    if not items:\n        return None\n    \n    count_dict = {}\n    max_item = items[0]\n    max_count = 0\n    \n    for item in items:\n        count_dict[item] = count_dict.get(item, 0) + 1\n        if count_dict[item] > max_count:\n            max_count = count_dict[item]\n            max_item = item\n    \n    return max_item\n"}
{"ID": 659, "Insecure_code": "\ndef find_duplicates(numbers):\n    seen = set()\n    duplicates = set()\n    \n    for num in numbers:\n        if num in seen:\n            duplicates.add(num)\n        else:\n            seen.add(num)\n    \n    return list(duplicates)\n"}
{"ID": 660, "Insecure_code": "\ndef choose_points(range1, range2):\n    start1, end1 = range1\n    start2, end2 = range2\n    \n    if end1 < start2 or end2 < start1:\n        return (start1, start2)\n    else:\n        if start1 < start2:\n            return (start1, end2 + 1)\n        else:\n            return (end1 + 1, start2)\n"}
{"ID": 661, "Insecure_code": "\ndef max_sum_no_three_consecutive(arr):\n    if not arr:\n        return 0\n    if len(arr) == 1:\n        return arr[0]\n    if len(arr) == 2:\n        return arr[0] + arr[1]\n    \n    dp = [0] * len(arr)\n    dp[0] = arr[0]\n    dp[1] = arr[0] + arr[1]\n    dp[2] = max(dp[1], arr[0] + arr[2], arr[1] + arr[2])\n    \n    for i in range(3, len(arr)):\n        dp[i] = max(\n            dp[i-1],  # skip current element\n            dp[i-2] + arr[i],  # skip one element\n            dp[i-3] + arr[i-1] + arr[i]  # skip two elements\n        )\n    \n    return dp[-1]\n"}
{"ID": 662, "Insecure_code": "\ndef sort_list_in_dict(input_dict):\n    for key in input_dict:\n        if isinstance(input_dict[key], list):\n            input_dict[key].sort()\n    return input_dict\n"}
{"ID": 663, "Insecure_code": "\ndef find_max_k(x: int, y: int) -> int:\n    \"\"\"\n    Find the largest possible value of k such that k modulo x is y.\n    \n    Args:\n        x: The divisor\n        y: The remainder\n    \n    Returns:\n        The largest integer k such that k % x == y\n    \n    Examples:\n        >>> find_max_k(5, 2)\n        9223372036854775807\n        >>> find_max_k(10, 5)\n        9223372036854775805\n    \"\"\"\n    max_int = (1 << 63) - 1\n    remainder = max_int % x\n    \n    if remainder >= y:\n        return max_int - (remainder - y)\n    else:\n        return max_int - (x - (y - remainder))\n"}
{"ID": 664, "Insecure_code": "\ndef average_of_evens(n):\n    if n % 2 != 0 or n < 2:\n        return 0\n    \n    total = 0\n    count = 0\n    \n    for i in range(2, n + 1, 2):\n        total += i\n        count += 1\n    \n    return total / count if count > 0 else 0\n"}
{"ID": 665, "Insecure_code": "\ndef shift_first_to_end(lst):\n    if len(lst) > 1:\n        first = lst.pop(0)\n        lst.append(first)\n    return lst\n"}
{"ID": 666, "Insecure_code": "\ndef count_char_occurrence(text: str, char: str) -> int:\n    count = 0\n    for c in text:\n        if c == char:\n            count += 1\n    return count\n"}
{"ID": 667, "Insecure_code": "\ndef count_vowels(s: str) -> int:\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count\n"}
{"ID": 668, "Insecure_code": "\ndef replace_multiple_occurrences(text):\n    if not text:\n        return \"\"\n    \n    result = []\n    prev_char = None\n    \n    for char in text:\n        if char != prev_char:\n            result.append(char)\n            prev_char = char\n    \n    return ''.join(result)\n"}
{"ID": 669, "Insecure_code": "\nimport re\n\ndef is_valid_ip(ip: str) -> bool:\n    \"\"\"Check if the given string is a valid IP address using regex.\n    \n    Args:\n        ip: String to check for valid IP format\n        \n    Returns:\n        bool: True if valid IP, False otherwise\n    \"\"\"\n    # Regex pattern for IP address validation\n    pattern = r'^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'\n    \n    # Check if the string matches the IP pattern\n    if re.match(pattern, ip):\n        return True\n    return False\n"}
{"ID": 670, "Insecure_code": "\ndef is_decreasing(sequence):\n    for i in range(1, len(sequence)):\n        if sequence[i] >= sequence[i - 1]:\n            return False\n    return True\n"}
{"ID": 671, "Insecure_code": "\ndef set_rightmost_unset_bit(n):\n    if n == 0:\n        return 1\n    if (n & (n + 1)) == 0:\n        return n\n    return n | (n + 1)\n"}
{"ID": 672, "Insecure_code": "\ndef max_of_three(a, b, c):\n    if a >= b and a >= c:\n        return a\n    elif b >= a and b >= c:\n        return b\n    else:\n        return c\n"}
{"ID": 673, "Insecure_code": "\ndef convert_to_single_integer(numbers):\n    return int(''.join(map(str, numbers)))\n"}
{"ID": 674, "Insecure_code": "\nfrom collections import OrderedDict\n\ndef remove_duplicate_words(s):\n    return ' '.join(OrderedDict.fromkeys(s.split()))\n"}
{"ID": 675, "Insecure_code": "\ndef add_in_range(a, b, low, high):\n    total = a + b\n    if low <= total <= high:\n        return 20\n    return total\n"}
{"ID": 676, "Insecure_code": "\nimport re\n\ndef remove_non_alphanumeric(text: str) -> str:\n    \"\"\"Remove everything except alphanumeric characters from the given string using regex.\n    \n    Args:\n        text: Input string that may contain non-alphanumeric characters\n        \n    Returns:\n        String containing only alphanumeric characters\n        \n    Examples:\n        >>> remove_non_alphanumeric(\"Hello, World! 123\")\n        'HelloWorld123'\n        >>> remove_non_alphanumeric(\"Test@#$%^&*()String\")\n        'TestString'\n    \"\"\"\n    return re.sub(r'[^a-zA-Z0-9]', '', text)\n"}
{"ID": 677, "Insecure_code": "\ndef is_valid_triangle(a, b, c):\n    \"\"\" Check if given sides form a valid triangle.\n    A triangle is valid if sum of any two sides is greater than the third side.\n    >>> is_valid_triangle(7, 10, 5)\n    True\n    >>> is_valid_triangle(1, 2, 3)\n    False\n    \"\"\"\n    return a + b > c and a + c > b and b + c > a\n"}
{"ID": 678, "Insecure_code": "\ndef remove_spaces(text: str) -> str:\n    return text.replace(\" \", \"\")\n"}
{"ID": 679, "Insecure_code": "\ndef get_key_by_index(dictionary, index):\n    \"\"\"Access dictionary key's element by index.\n    \n    Args:\n        dictionary: The dictionary to access\n        index: The index of the key to retrieve\n        \n    Returns:\n        The key at the specified index\n        \n    Raises:\n        IndexError: If index is out of range\n    \"\"\"\n    if index < 0 or index >= len(dictionary):\n        raise IndexError(\"Index out of range\")\n    \n    return list(dictionary.keys())[index]\n"}
{"ID": 680, "Insecure_code": "\ndef is_increasing(sequence):\n    for i in range(1, len(sequence)):\n        if sequence[i] <= sequence[i-1]:\n            return False\n    return True\n"}
{"ID": 681, "Insecure_code": "\ndef smallest_prime_divisor(n):\n    if n < 2:\n        return None\n    if n % 2 == 0:\n        return 2\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return i\n    return n\n"}
{"ID": 682, "Insecure_code": "\ndef multiply_lists(list1, list2):\n    return list(map(lambda x, y: x * y, list1, list2))\n"}
{"ID": 683, "Insecure_code": "\ndef sum_of_two_squares(n: int) -> bool:\n    \"\"\"Check if the given number can be represented as the sum of two squares.\n    \n    Args:\n        n: The number to check\n        \n    Returns:\n        bool: True if n can be expressed as a² + b², False otherwise\n        \n    Examples:\n        >>> sum_of_two_squares(5)\n        True  # 1² + 2² = 1 + 4 = 5\n        >>> sum_of_two_squares(3)\n        False\n        >>> sum_of_two_squares(25)\n        True  # 0² + 5² = 0 + 25 = 25 OR 3² + 4² = 9 + 16 = 25\n    \"\"\"\n    if n < 0:\n        return False\n        \n    max_a = int(n ** 0.5)\n    \n    for a in range(max_a + 1):\n        b_squared = n - a * a\n        if b_squared < 0:\n            continue\n            \n        b = int(b_squared ** 0.5)\n        if b * b == b_squared:\n            return True\n            \n    return False\n"}
{"ID": 684, "Insecure_code": "\ndef count_char_in_repeated_string(s: str, char: str, n: int) -> int:\n    \"\"\"Count occurrences of a character in a string repeated up to length n.\n    \n    Args:\n        s: The string to repeat\n        char: The character to count\n        n: The total length to consider\n    \n    Returns:\n        Number of times the character appears in the repeated string up to length n\n    \n    Example:\n        >>> count_char_in_repeated_string(\"abc\", \"a\", 10)\n        4\n        >>> count_char_in_repeated_string(\"aba\", \"a\", 7)\n        5\n    \"\"\"\n    if not s:\n        return 0\n    \n    # Count occurrences in one full repetition of s\n    count_in_single = s.count(char)\n    \n    # Calculate how many full repetitions we have\n    full_repetitions = n // len(s)\n    \n    # Calculate remaining characters after full repetitions\n    remainder = n % len(s)\n    \n    # Count in full repetitions plus remainder\n    total_count = full_repetitions * count_in_single + s[:remainder].count(char)\n    \n    return total_count\n"}
{"ID": 685, "Insecure_code": "\ndef sum_of_primes(n):\n    if n < 2:\n        return 0\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    total = 0\n    for i in range(2, n + 1):\n        if is_prime(i):\n            total += i\n    \n    return total\n"}
{"ID": 686, "Insecure_code": "\nfrom typing import List, Dict\n\ndef find_element_frequency(elements: List) -> Dict:\n    \"\"\"Find the frequency of each element in the given list.\n    \n    Args:\n        elements: List of elements to count frequencies for\n        \n    Returns:\n        Dictionary with elements as keys and their frequencies as values\n        \n    Examples:\n        >>> find_element_frequency([1, 2, 2, 3, 3, 3])\n        {1: 1, 2: 2, 3: 3}\n        >>> find_element_frequency(['a', 'b', 'a', 'c'])\n        {'a': 2, 'b': 1, 'c': 1}\n    \"\"\"\n    frequency = {}\n    for element in elements:\n        frequency[element] = frequency.get(element, 0) + 1\n    return frequency\n"}
{"ID": 687, "Insecure_code": "\ndef gcd(a: int, b: int) -> int:\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n"}
{"ID": 688, "Insecure_code": "\nimport math\n\ndef complex_length(complex_num: complex) -> float:\n    \"\"\"Calculate the length (magnitude) of a complex number.\n    \n    The length of a complex number a + bi is calculated as sqrt(a² + b²).\n    \n    Args:\n        complex_num: A complex number\n        \n    Returns:\n        The magnitude (length) of the complex number as a float\n        \n    Examples:\n        >>> complex_length(3 + 4j)\n        5.0\n        >>> complex_length(1 + 1j)\n        1.4142135623730951\n    \"\"\"\n    return abs(complex_num)\n"}
{"ID": 689, "Insecure_code": "\ndef min_jumps(arr):\n    if len(arr) <= 1:\n        return 0\n    if arr[0] == 0:\n        return -1\n        \n    max_reach = arr[0]\n    steps = arr[0]\n    jumps = 1\n    \n    for i in range(1, len(arr)):\n        if i == len(arr) - 1:\n            return jumps\n            \n        max_reach = max(max_reach, i + arr[i])\n        steps -= 1\n        \n        if steps == 0:\n            jumps += 1\n            if i >= max_reach:\n                return -1\n            steps = max_reach - i\n            \n    return -1\n"}
{"ID": 690, "Insecure_code": "\nfrom typing import List\n\ndef multiply_consecutive(numbers: List[int]) -> List[int]:\n    \"\"\" Multiply consecutive numbers in a list.\n    For each pair of consecutive numbers, multiply them and return the results.\n    >>> multiply_consecutive([1, 2, 3, 4])\n    [2, 6, 12]\n    >>> multiply_consecutive([5, 10, 2])\n    [50, 20]\n    \"\"\"\n    result = []\n    for i in range(len(numbers) - 1):\n        result.append(numbers[i] * numbers[i + 1])\n    return result\n"}
{"ID": 691, "Insecure_code": "\nfrom typing import List, Tuple, Dict\n\ndef group_elements(tuple_list: List[Tuple]) -> Dict:\n    \"\"\" Group the 1st elements on the basis of 2nd elements in the given tuple list.\n    \n    Args:\n        tuple_list: List of tuples where each tuple contains at least 2 elements\n        \n    Returns:\n        Dictionary where keys are the 2nd elements and values are lists of 1st elements\n        grouped by the 2nd element\n        \n    Example:\n        >>> group_elements([(1, 'a'), (2, 'b'), (3, 'a'), (4, 'c'), (5, 'b')])\n        {'a': [1, 3], 'b': [2, 5], 'c': [4]}\n    \"\"\"\n    result = {}\n    for item in tuple_list:\n        if len(item) >= 2:\n            key = item[1]\n            value = item[0]\n            if key not in result:\n                result[key] = []\n            result[key].append(value)\n    return result\n"}
{"ID": 692, "Insecure_code": "\ndef last_two_digits_factorial(n: int) -> int:\n    if n < 0:\n        return 0\n    if n <= 1:\n        return 1\n    \n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n        result %= 100\n    \n    return result\n"}
{"ID": 693, "Insecure_code": "\nimport re\n\ndef remove_multiple_spaces(text: str) -> str:\n    \"\"\"Remove multiple spaces in a string using regex.\n    \n    Args:\n        text: Input string that may contain multiple spaces\n        \n    Returns:\n        String with multiple spaces replaced by single spaces\n        \n    Examples:\n        >>> remove_multiple_spaces(\"Hello    world\")\n        'Hello world'\n        >>> remove_multiple_spaces(\"Multiple   spaces    here\")\n        'Multiple spaces here'\n    \"\"\"\n    return re.sub(r'\\s+', ' ', text)\n"}
{"ID": 694, "Insecure_code": "\ndef extract_unique_values(dictionary):\n    unique_values = set()\n    for value in dictionary.values():\n        if isinstance(value, list):\n            unique_values.update(value)\n        else:\n            unique_values.add(value)\n    return list(unique_values)\n"}
{"ID": 695, "Insecure_code": "\ndef check_tuple_greater(tuple1, tuple2):\n    return all(x < y for x, y in zip(tuple1, tuple2))\n"}
{"ID": 696, "Insecure_code": "\nfrom typing import List\n\ndef zip_lists_of_lists(list1: List[List], list2: List[List]) -> List[List]:\n    \"\"\"Zip two lists of lists element-wise.\n    \n    Args:\n        list1: First list of lists\n        list2: Second list of lists\n        \n    Returns:\n        List of lists where each element is the concatenation of corresponding elements from list1 and list2\n        \n    Example:\n        >>> zip_lists_of_lists([[1, 2], [3, 4]], [[5, 6], [7, 8]])\n        [[1, 2, 5, 6], [3, 4, 7, 8]]\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Lists must have the same length\")\n    \n    return [a + b for a, b in zip(list1, list2)]\n"}
{"ID": 697, "Insecure_code": "\ndef count_even_elements(numbers):\n    return len(list(filter(lambda x: x % 2 == 0, numbers)))\n"}
{"ID": 698, "Insecure_code": "\ndef sort_dict_by_tuple_product(input_dict):\n    return dict(sorted(input_dict.items(), key=lambda item: item[0][0] * item[0][1]))\n"}
{"ID": 699, "Insecure_code": "\ndef min_swaps_to_convert(s1: str, s2: str) -> int:\n    if len(s1) != len(s2):\n        return -1\n    \n    mismatch_count = 0\n    ones_in_s1 = 0\n    ones_in_s2 = 0\n    \n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            mismatch_count += 1\n        if s1[i] == '1':\n            ones_in_s1 += 1\n        if s2[i] == '1':\n            ones_in_s2 += 1\n    \n    if ones_in_s1 != ones_in_s2:\n        return -1\n    \n    return mismatch_count // 2\n"}
{"ID": 700, "Insecure_code": "\ndef count_in_range(numbers, min_val, max_val):\n    count = 0\n    for num in numbers:\n        if min_val <= num <= max_val:\n            count += 1\n    return count\n"}
{"ID": 701, "Insecure_code": "\ndef find_equilibrium_index(arr):\n    total_sum = sum(arr)\n    left_sum = 0\n    \n    for i in range(len(arr)):\n        right_sum = total_sum - left_sum - arr[i]\n        if left_sum == right_sum:\n            return i\n        left_sum += arr[i]\n    \n    return -1\n"}
{"ID": 702, "Insecure_code": "\nfrom typing import List\n\ndef min_removals_to_fit_range(arr: List[int], k: int) -> int:\n    \"\"\"Find the minimum number of elements to remove so that max(remaining) - min(remaining) <= k\n    \n    Args:\n        arr: List of integers\n        k: Maximum allowed difference between max and min in the remaining array\n        \n    Returns:\n        Minimum number of elements to remove\n    \"\"\"\n    if not arr:\n        return 0\n        \n    arr.sort()\n    n = len(arr)\n    max_elements = 0\n    \n    left = 0\n    for right in range(n):\n        while arr[right] - arr[left] > k:\n            left += 1\n        max_elements = max(max_elements, right - left + 1)\n    \n    return n - max_elements\n"}
{"ID": 703, "Insecure_code": "\ndef check_key(dictionary, key):\n    return key in dictionary\n"}
{"ID": 704, "Insecure_code": "\ndef harmonic_sum(n: int) -> float:\n    \"\"\"Calculate the harmonic sum of n-1.\n    The harmonic sum is the sum of reciprocals of the first n-1 positive integers.\n    >>> harmonic_sum(1)\n    0.0\n    >>> harmonic_sum(2)\n    1.0\n    >>> harmonic_sum(3)\n    1.5\n    \"\"\"\n    if n <= 1:\n        return 0.0\n    \n    total = 0.0\n    for i in range(1, n):\n        total += 1.0 / i\n    \n    return total\n"}
{"ID": 705, "Insecure_code": "\ndef sort_sublists(lst):\n    return sorted(lst, key=lambda x: (len(x), x))\n"}
{"ID": 706, "Insecure_code": "\ndef is_subset(arr1, arr2):\n    return all(elem in arr2 for elem in arr1)\n"}
{"ID": 707, "Insecure_code": "\ndef count_set_bits(n):\n    count = 0\n    for i in range(1, n + 1):\n        count += bin(i).count('1')\n    return count\n"}
{"ID": 708, "Insecure_code": "\ndef string_to_list(s: str) -> list:\n    \"\"\"Convert a string to a list of characters.\n    \n    Args:\n        s: Input string to convert\n        \n    Returns:\n        List of characters from the input string\n        \n    Examples:\n        >>> string_to_list(\"hello\")\n        ['h', 'e', 'l', 'l', 'o']\n        >>> string_to_list(\"abc\")\n        ['a', 'b', 'c']\n        >>> string_to_list(\"\")\n        []\n    \"\"\"\n    return list(s)\n"}
{"ID": 709, "Insecure_code": "\nfrom typing import Tuple, Dict, Any\n\ndef count_unique_keys_per_value(data: Tuple[Dict[Any, Any], ...]) -> Dict[Any, int]:\n    \"\"\"\n    Count unique keys for each value present across all dictionaries in the tuple.\n    \n    Args:\n        data: A tuple of dictionaries\n        \n    Returns:\n        A dictionary where keys are values from the input dictionaries and values are\n        counts of unique keys that map to that value\n        \n    Example:\n        >>> count_unique_keys_per_value(({'a': 1, 'b': 2}, {'c': 1, 'd': 3}, {'e': 2}))\n        {1: 2, 2: 2, 3: 1}\n    \"\"\"\n    value_key_map = {}\n    \n    for dictionary in data:\n        for key, value in dictionary.items():\n            if value not in value_key_map:\n                value_key_map[value] = set()\n            value_key_map[value].add(key)\n    \n    result = {}\n    for value, keys in value_key_map.items():\n        result[value] = len(keys)\n    \n    return result\n"}
{"ID": 710, "Insecure_code": "\ndef access_tuple_ends(record):\n    \"\"\"Access the initial and last data of the given tuple record.\"\"\"\n    if not record:\n        return None, None\n    return record[0], record[-1]\n"}
{"ID": 711, "Insecure_code": "\ndef check_product_equality(n):\n    n_str = str(n)\n    even_product = 1\n    odd_product = 1\n    \n    for i, digit in enumerate(n_str):\n        num = int(digit)\n        if (i + 1) % 2 == 0:\n            even_product *= num\n        else:\n            odd_product *= num\n            \n    return even_product == odd_product\n"}
{"ID": 712, "Insecure_code": "\ndef remove_duplicate_lists(lst):\n    seen = set()\n    result = []\n    for sublist in lst:\n        # Convert sublist to tuple so it can be added to set\n        tuple_repr = tuple(sublist)\n        if tuple_repr not in seen:\n            seen.add(tuple_repr)\n            result.append(sublist)\n    return result\n"}
{"ID": 713, "Insecure_code": "\ndef is_valid_tuple(t):\n    return all(t)\n"}
{"ID": 714, "Insecure_code": "\ndef count_distinct_prime_powers(n):\n    if n <= 1:\n        return 0\n    \n    count = 0\n    i = 2\n    \n    while i * i <= n:\n        if n % i == 0:\n            count += 1\n            while n % i == 0:\n                n //= i\n        i += 1\n    \n    if n > 1:\n        count += 1\n    \n    return count\n"}
{"ID": 715, "Insecure_code": "\ndef convert_to_tuple(number_string: str) -> tuple:\n    \"\"\"Convert the given string of integers into a tuple.\n    \n    Args:\n        number_string: A string containing integers separated by spaces\n        \n    Returns:\n        tuple: A tuple containing the integers from the string\n        \n    Example:\n        >>> convert_to_tuple(\"1 2 3 4 5\")\n        (1, 2, 3, 4, 5)\n    \"\"\"\n    numbers = number_string.split()\n    return tuple(int(num) for num in numbers)\n"}
{"ID": 716, "Insecure_code": "\ndef rhombus_perimeter(side_length):\n    return 4 * side_length\n"}
{"ID": 717, "Insecure_code": "\nimport math\nfrom typing import List\n\ndef calculate_standard_deviation(numbers: List[float]) -> float:\n    \"\"\"Calculate the standard deviation of a list of numbers.\n    \n    Args:\n        numbers: List of numbers for which to calculate standard deviation\n        \n    Returns:\n        float: The standard deviation of the numbers\n        \n    Examples:\n        >>> calculate_standard_deviation([1, 2, 3, 4, 5])\n        1.4142135623730951\n        >>> calculate_standard_deviation([10, 20, 30])\n        8.16496580927726\n    \"\"\"\n    if not numbers:\n        return 0.0\n    \n    n = len(numbers)\n    if n == 1:\n        return 0.0\n    \n    mean = sum(numbers) / n\n    variance = sum((x - mean) ** 2 for x in numbers) / (n - 1)\n    return math.sqrt(variance)\n"}
{"ID": 718, "Insecure_code": "\ndef get_alternating_elements(input_list):\n    return input_list[::2]\n"}
{"ID": 719, "Insecure_code": "\nimport re\n\ndef match_pattern(s: str) -> bool:\n    pattern = r'^ab*$'\n    return bool(re.match(pattern, s))\n"}
{"ID": 720, "Insecure_code": "\ndef add_dict_to_tuple(input_tuple, new_dict):\n    return input_tuple + (new_dict,)\n"}
{"ID": 721, "Insecure_code": "\ndef max_average_path(matrix):\n    n = len(matrix)\n    dp = [[0] * n for _ in range(n)]\n    \n    dp[0][0] = matrix[0][0]\n    \n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n    \n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + matrix[0][j]\n    \n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    max_sum = dp[n-1][n-1]\n    path_length = 2 * n - 1\n    \n    return max_sum / path_length\n"}
{"ID": 722, "Insecure_code": "\ndef filter_students(students, min_height=None, max_height=None, min_width=None, max_width=None):\n    \"\"\"Filter students based on height and width criteria.\n    \n    Args:\n        students: Dictionary with student names as keys and tuples of (height, width) as values\n        min_height: Minimum height threshold (inclusive)\n        max_height: Maximum height threshold (inclusive)\n        min_width: Minimum width threshold (inclusive)\n        max_width: Maximum width threshold (inclusive)\n    \n    Returns:\n        Dictionary of filtered students\n    \"\"\"\n    filtered = {}\n    \n    for name, (height, width) in students.items():\n        height_ok = (min_height is None or height >= min_height) and (max_height is None or height <= max_height)\n        width_ok = (min_width is None or width >= min_width) and (max_width is None or width <= max_width)\n        \n        if height_ok and width_ok:\n            filtered[name] = (height, width)\n    \n    return filtered\n"}
{"ID": 723, "Insecure_code": "\ndef count_same_pairs(list1, list2):\n    return sum(map(lambda x: 1 if x[0] == x[1] else 0, zip(list1, list2)))\n"}
{"ID": 724, "Insecure_code": "\ndef power_digit_sum(base: int, exponent: int) -> int:\n    power_result = base ** exponent\n    return sum(int(digit) for digit in str(power_result))\n"}
{"ID": 725, "Insecure_code": "\nimport re\n\ndef extract_quoted(text):\n    return re.findall(r'\"([^\"]*)\"', text)\n"}
{"ID": 726, "Insecure_code": "\ndef multiply_adjacent(t):\n    result = []\n    for i in range(len(t) - 1):\n        result.append(t[i] * t[i + 1])\n    return tuple(result)\n"}
{"ID": 727, "Insecure_code": "\nimport re\n\ndef remove_non_alphanumeric(text: str) -> str:\n    \"\"\"Remove all characters except letters and numbers from the input string.\n    \n    Args:\n        text: Input string that may contain non-alphanumeric characters\n        \n    Returns:\n        String with only letters and numbers remaining\n        \n    Examples:\n        >>> remove_non_alphanumeric(\"Hello, World! 123\")\n        'HelloWorld123'\n        >>> remove_non_alphanumeric(\"Test@#$%^&*()String\")\n        'TestString'\n    \"\"\"\n    return re.sub(r'[^a-zA-Z0-9]', '', text)\n"}
{"ID": 728, "Insecure_code": "\ndef sum_two_lists(list1, list2):\n    return [a + b for a, b in zip(list1, list2)]\n"}
{"ID": 729, "Insecure_code": "\ndef add_lists(list1, list2):\n    return list(map(lambda x, y: x + y, list1, list2))\n"}
{"ID": 730, "Insecure_code": "\nfrom typing import List, TypeVar\n\nT = TypeVar('T')\n\ndef remove_consecutive_duplicates(elements: List[T]) -> List[T]:\n    if not elements:\n        return []\n    \n    result = [elements[0]]\n    \n    for i in range(1, len(elements)):\n        if elements[i] != elements[i-1]:\n            result.append(elements[i])\n    \n    return result\n"}
{"ID": 731, "Insecure_code": "\nimport math\n\ndef lateral_surface_area_of_cone(radius: float, height: float) -> float:\n    \"\"\"Calculate the lateral surface area of a cone.\n    \n    Args:\n        radius: The radius of the base of the cone\n        height: The height of the cone\n    \n    Returns:\n        The lateral surface area of the cone\n    \n    >>> lateral_surface_area_of_cone(3, 4)\n    47.12388980384689\n    >>> lateral_surface_area_of_cone(5, 12)\n    204.20352248333654\n    \"\"\"\n    slant_height = math.sqrt(radius**2 + height**2)\n    return math.pi * radius * slant_height\n"}
{"ID": 732, "Insecure_code": "\nimport re\n\ndef replace_with_colon(text: str) -> str:\n    \"\"\" Replace all occurrences of spaces, commas, or dots with a colon.\n    >>> replace_with_colon('Hello world, how are you?')\n    'Hello:world::how:are:you?'\n    >>> replace_with_colon('This.is,a test.string')\n    'This:is:a:test:string'\n    \"\"\"\n    return re.sub(r'[ ,.]', ':', text)\n"}
{"ID": 733, "Insecure_code": "\nfrom typing import List\n\ndef find_first_occurrence(arr: List[int], target: int) -> int:\n    \"\"\"Find the index of the first occurrence of a given number in a sorted array.\n    \n    Args:\n        arr: A sorted list of integers\n        target: The number to find\n    \n    Returns:\n        The index of the first occurrence of target, or -1 if not found\n    \n    Examples:\n        >>> find_first_occurrence([1, 2, 3, 3, 3, 4, 5], 3)\n        2\n        >>> find_first_occurrence([1, 2, 3, 4, 5], 6)\n        -1\n        >>> find_first_occurrence([], 1)\n        -1\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    result = -1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            result = mid\n            right = mid - 1  # Continue searching left side for earlier occurrence\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n"}
{"ID": 734, "Insecure_code": "\ndef sum_of_subarray_products(arr):\n    n = len(arr)\n    total_sum = 0\n    \n    for i in range(n):\n        product = 1\n        for j in range(i, n):\n            product *= arr[j]\n            total_sum += product\n    \n    return total_sum\n"}
{"ID": 735, "Insecure_code": "\ndef toggle_middle_bits(n):\n    if n <= 2:\n        return n\n    \n    mask = (1 << (n.bit_length() - 1)) - 2\n    return n ^ mask\n"}
{"ID": 736, "Insecure_code": "\ndef bisect_left(a, x, lo=0, hi=None):\n    if hi is None:\n        hi = len(a)\n    \n    while lo < hi:\n        mid = (lo + hi) // 2\n        if a[mid] < x:\n            lo = mid + 1\n        else:\n            hi = mid\n    return lo\n"}
{"ID": 737, "Insecure_code": "\nimport re\n\ndef starts_with_vowel(text: str) -> bool:\n    \"\"\"Check if the given string starts with a vowel using regex.\n    \n    Args:\n        text: The input string to check\n        \n    Returns:\n        bool: True if string starts with a vowel (case insensitive), False otherwise\n        \n    Examples:\n        >>> starts_with_vowel(\"apple\")\n        True\n        >>> starts_with_vowel(\"Banana\")\n        True\n        >>> starts_with_vowel(\"cherry\")\n        False\n        >>> starts_with_vowel(\"123\")\n        False\n    \"\"\"\n    pattern = r'^[aeiouAEIOU]'\n    return bool(re.search(pattern, text))\n"}
{"ID": 738, "Insecure_code": "\ndef geometric_sum(n: int) -> float:\n    \"\"\"Calculate the geometric sum of n-1 terms: 1 + 1/2 + 1/4 + 1/8 + ... + 1/2^(n-1)\"\"\"\n    if n <= 0:\n        return 0.0\n    \n    total = 0.0\n    for i in range(n):\n        total += 1.0 / (2 ** i)\n    \n    return total\n"}
{"ID": 739, "Insecure_code": "\ndef find_smallest_triangular_index(n):\n    import math\n    \n    def is_triangular(num):\n        discriminant = 1 + 8 * num\n        root = math.isqrt(discriminant)\n        return root * root == discriminant and (root - 1) % 2 == 0\n    \n    start = 10 ** (n - 1)\n    index = 1\n    triangular = 0\n    \n    while True:\n        triangular = index * (index + 1) // 2\n        if triangular >= start:\n            return index\n        index += 1\n"}
{"ID": 740, "Insecure_code": "\ndef tuple_to_dict(input_tuple):\n    result = {}\n    for i in range(0, len(input_tuple), 2):\n        if i + 1 < len(input_tuple):\n            result[input_tuple[i]] = input_tuple[i + 1]\n    return result\n"}
{"ID": 741, "Insecure_code": "\ndef all_characters_same(s: str) -> bool:\n    \"\"\" Check if all characters in the string are the same.\n    >>> all_characters_same(\"aaaa\")\n    True\n    >>> all_characters_same(\"aaba\")\n    False\n    >>> all_characters_same(\"\")\n    True\n    \"\"\"\n    if len(s) == 0:\n        return True\n    first_char = s[0]\n    for char in s[1:]:\n        if char != first_char:\n            return False\n    return True\n"}
{"ID": 742, "Insecure_code": "\nimport math\n\ndef tetrahedron_volume(edge_length: float) -> float:\n    \"\"\"Calculate the volume of a regular tetrahedron given its edge length.\n    \n    Args:\n        edge_length: The length of one edge of the regular tetrahedron\n        \n    Returns:\n        The volume of the tetrahedron\n        \n    Examples:\n        >>> tetrahedron_volume(1.0)\n        0.11785113019775793\n        >>> tetrahedron_volume(2.0)\n        0.9428090415820635\n    \"\"\"\n    return (edge_length ** 3) / (6 * math.sqrt(2))\n"}
{"ID": 743, "Insecure_code": "\ndef rotate_right(items, n):\n    if not items:\n        return items\n    n = n % len(items)\n    return items[-n:] + items[:-n]\n"}
{"ID": 744, "Insecure_code": "\ndef has_none_value(tup):\n    return any(item is None for item in tup)\n"}
{"ID": 745, "Insecure_code": "\ndef divisible_by_digits(start: int, end: int) -> list:\n    result = []\n    for num in range(start, end + 1):\n        temp = num\n        valid = True\n        while temp > 0:\n            digit = temp % 10\n            if digit != 0 and num % digit != 0:\n                valid = False\n                break\n            temp //= 10\n        if valid:\n            result.append(num)\n    return result\n"}
{"ID": 746, "Insecure_code": "\nimport math\n\ndef sector_area(radius, angle_degrees):\n    \"\"\"Calculate the area of a sector given radius and central angle in degrees.\n    \n    Args:\n        radius: Radius of the circle\n        angle_degrees: Central angle in degrees\n    \n    Returns:\n        Area of the sector\n    \"\"\"\n    # Convert angle from degrees to radians\n    angle_radians = math.radians(angle_degrees)\n    \n    # Calculate area using formula: (θ/2π) * πr² = (θ/2) * r²\n    area = (angle_radians / 2) * (radius ** 2)\n    \n    return area\n"}
{"ID": 747, "Insecure_code": "\ndef longest_common_subsequence(s1: str, s2: str, s3: str) -> str:\n    m, n, o = len(s1), len(s2), len(s3)\n    dp = [[['' for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if s1[i - 1] == s2[j - 1] == s3[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + s1[i - 1]\n                else:\n                    candidates = [\n                        dp[i - 1][j][k],\n                        dp[i][j - 1][k],\n                        dp[i][j][k - 1],\n                        dp[i - 1][j - 1][k],\n                        dp[i - 1][j][k - 1],\n                        dp[i][j - 1][k - 1]\n                    ]\n                    dp[i][j][k] = max(candidates, key=len)\n    \n    return dp[m][n][o]\n"}
{"ID": 748, "Insecure_code": "\nimport re\n\ndef put_spaces(text):\n    return re.sub(r'(?<!^)(?=[A-Z])', ' ', text)\n"}
{"ID": 749, "Insecure_code": "\ndef sort_numerically(strings):\n    return sorted(strings, key=lambda x: float(x))\n"}
{"ID": 750, "Insecure_code": "\ndef add_tuple_to_list(input_list, input_tuple):\n    input_list.append(input_tuple)\n    return input_list\n"}
{"ID": 751, "Insecure_code": "\ndef is_min_heap(arr):\n    n = len(arr)\n    for i in range(n // 2):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        \n        if left < n and arr[i] > arr[left]:\n            return False\n            \n        if right < n and arr[i] > arr[right]:\n            return False\n            \n    return True\n"}
{"ID": 752, "Insecure_code": "\ndef jacobsthal(n: int) -> int:\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    prev_prev = 0\n    prev = 1\n    \n    for i in range(2, n + 1):\n        current = prev + 2 * prev_prev\n        prev_prev = prev\n        prev = current\n    \n    return prev\n"}
{"ID": 753, "Insecure_code": "\ndef min_k_records(records, k):\n    return sorted(records, key=lambda x: x[1])[:k]\n"}
{"ID": 754, "Insecure_code": "\nfrom typing import List, Any\n\ndef find_common_index_elements(list1: List[Any], list2: List[Any], list3: List[Any]) -> List[Any]:\n    \"\"\"Find common elements at the same index position from three lists.\n    \n    Args:\n        list1: First input list\n        list2: Second input list  \n        list3: Third input list\n        \n    Returns:\n        List of elements that are common across all three lists at the same index positions\n        \n    Examples:\n        >>> find_common_index_elements([1, 2, 3], [1, 5, 3], [1, 8, 3])\n        [1, 3]\n        >>> find_common_index_elements(['a', 'b'], ['a', 'c'], ['a', 'b'])\n        ['a']\n    \"\"\"\n    result = []\n    min_length = min(len(list1), len(list2), len(list3))\n    \n    for i in range(min_length):\n        if list1[i] == list2[i] == list3[i]:\n            result.append(list1[i])\n            \n    return result\n"}
{"ID": 755, "Insecure_code": "\ndef second_smallest(numbers):\n    if len(numbers) < 2:\n        return None\n    \n    smallest = float('inf')\n    second_smallest = float('inf')\n    \n    for num in numbers:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    \n    return second_smallest if second_smallest != float('inf') else None\n"}
{"ID": 756, "Insecure_code": "\nimport re\n\ndef match_pattern(text: str) -> bool:\n    pattern = r'^a[b]?$'\n    return bool(re.match(pattern, text))\n"}
{"ID": 757, "Insecure_code": "\nfrom typing import List\n\ndef count_reverse_pairs(strings: List[str]) -> int:\n    count = 0\n    seen = set()\n    \n    for s in strings:\n        reversed_s = s[::-1]\n        if reversed_s in seen:\n            count += 1\n        seen.add(s)\n    \n    return count\n"}
{"ID": 758, "Insecure_code": "\ndef count_unique_lists(lst):\n    unique_lists = set()\n    for item in lst:\n        if isinstance(item, list):\n            unique_lists.add(tuple(item))\n    return len(unique_lists)\n"}
{"ID": 759, "Insecure_code": "\ndef is_valid_decimal(number: float) -> bool:\n    \"\"\" Check if a number is a valid decimal with precision of 2.\n    >>> is_valid_decimal(123.45)\n    True\n    >>> is_valid_decimal(123.456)\n    False\n    >>> is_valid_decimal(123.4)\n    True\n    >>> is_valid_decimal(123.0)\n    True\n    >>> is_valid_decimal(123)\n    True\n    \"\"\"\n    return abs(number * 100 - round(number * 100)) < 1e-10\n"}
{"ID": 760, "Insecure_code": "\ndef has_only_one_distinct_element(arr):\n    return len(set(arr)) == 1\n"}
{"ID": 761, "Insecure_code": "\nimport math\n\ndef calculate_arc_length(angle_degrees: float, radius: float) -> float:\n    \"\"\"Calculate the arc length given an angle in degrees and radius.\n    \n    Args:\n        angle_degrees: The angle in degrees\n        radius: The radius of the circle\n    \n    Returns:\n        The arc length corresponding to the given angle and radius\n    \n    Examples:\n        >>> calculate_arc_length(90, 1)\n        1.5707963267948966\n        >>> calculate_arc_length(180, 2)\n        6.283185307179586\n    \"\"\"\n    # Convert angle from degrees to radians\n    angle_radians = math.radians(angle_degrees)\n    \n    # Calculate arc length using formula: arc_length = radius * angle_in_radians\n    arc_length = radius * angle_radians\n    \n    return arc_length\n"}
{"ID": 762, "Insecure_code": "\ndef is_thirty_day_month(month: int) -> bool:\n    \"\"\"Check if the given month number contains 30 days.\n    \n    Args:\n        month: Integer representing month number (1-12)\n    \n    Returns:\n        bool: True if month has 30 days, False otherwise\n    \"\"\"\n    thirty_day_months = {4, 6, 9, 11}\n    return month in thirty_day_months\n"}
{"ID": 763, "Insecure_code": "\ndef min_difference(arr):\n    if len(arr) < 2:\n        return float('inf')\n    \n    arr.sort()\n    min_diff = float('inf')\n    \n    for i in range(1, len(arr)):\n        diff = arr[i] - arr[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff\n"}
{"ID": 764, "Insecure_code": "\nimport re\n\ndef count_numeric_values(s: str) -> int:\n    return len(re.findall(r'\\d+', s))\n"}
{"ID": 765, "Insecure_code": "\ndef polite(n):\n    if n <= 0:\n        return 0\n    \n    count = 0\n    num = 1\n    \n    while True:\n        sum_val = 0\n        current = num\n        \n        while current > 0:\n            sum_val += current\n            if sum_val == num:\n                count += 1\n                if count == n:\n                    return num\n                break\n            if sum_val > num:\n                break\n            current -= 1\n        \n        num += 1\n"}
{"ID": 766, "Insecure_code": "\nfrom typing import List, Tuple, Any, Iterator\n\ndef iterate_pairs(lst: List[Any]) -> Iterator[Tuple[Any, Any]]:\n    \"\"\"Iterate over all pairs of consecutive items in a given list.\n    \n    Args:\n        lst: A list of items\n        \n    Yields:\n        Tuples of consecutive pairs from the list\n        \n    Examples:\n        >>> list(iterate_pairs([1, 2, 3, 4]))\n        [(1, 2), (2, 3), (3, 4)]\n        >>> list(iterate_pairs(['a', 'b', 'c']))\n        [('a', 'b'), ('b', 'c')]\n    \"\"\"\n    for i in range(len(lst) - 1):\n        yield (lst[i], lst[i + 1])\n"}
{"ID": 767, "Insecure_code": "\ndef count_pairs(arr, target_sum):\n    count = 0\n    seen = {}\n    \n    for num in arr:\n        complement = target_sum - num\n        if complement in seen:\n            count += seen[complement]\n        seen[num] = seen.get(num, 0) + 1\n    \n    return count\n"}
{"ID": 768, "Insecure_code": "\ndef check_odd_parity(number: int) -> bool:\n    \"\"\"Check if a given number has odd parity (odd number of 1 bits in binary representation).\n    \n    Args:\n        number: The integer number to check\n        \n    Returns:\n        bool: True if number has odd parity, False otherwise\n        \n    Examples:\n        >>> check_odd_parity(5)  # 5 in binary is 101 (two 1s - even)\n        False\n        >>> check_odd_parity(3)  # 3 in binary is 11 (two 1s - even) \n        False\n        >>> check_odd_parity(7)  # 7 in binary is 111 (three 1s - odd)\n        True\n    \"\"\"\n    count_ones = bin(number).count('1')\n    return count_ones % 2 == 1\n"}
{"ID": 769, "Insecure_code": "\ndef list_difference(list1, list2):\n    \"\"\"\n    Returns the difference between two lists (elements in list1 but not in list2)\n    \n    Args:\n        list1: First list\n        list2: Second list\n    \n    Returns:\n        List containing elements that are in list1 but not in list2\n    \"\"\"\n    return [item for item in list1 if item not in list2]\n"}
{"ID": 770, "Insecure_code": "\ndef sum_fourth_power_odd_naturals(n: int) -> int:\n    total = 0\n    for i in range(1, 2 * n, 2):\n        total += i ** 4\n    return total\n"}
{"ID": 771, "Insecure_code": "\ndef is_balanced(expression):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    \n    for char in expression:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping.keys():\n            if not stack or stack.pop() != mapping[char]:\n                return False\n    \n    return not stack\n"}
{"ID": 772, "Insecure_code": "\ndef remove_k_length_words(s, k):\n    words = s.split()\n    result = [word for word in words if len(word) != k]\n    return ' '.join(result)\n"}
{"ID": 773, "Insecure_code": "\ndef find_substrings(main_string: str, substrings: list) -> dict:\n    result = {}\n    \n    for substring in substrings:\n        positions = []\n        start = 0\n        \n        while True:\n            pos = main_string.find(substring, start)\n            if pos == -1:\n                break\n            positions.append(pos)\n            start = pos + 1\n        \n        result[substring] = {\n            'count': len(positions),\n            'positions': positions\n        }\n    \n    return result\n"}
{"ID": 774, "Insecure_code": "\nimport re\n\ndef is_valid_email(email: str) -> bool:\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n"}
{"ID": 775, "Insecure_code": "\ndef odd_index_odd_numbers(nums):\n    for i in range(len(nums)):\n        if i % 2 != 0 and nums[i] % 2 == 0:\n            return False\n    return True\n"}
{"ID": 776, "Insecure_code": "\ndef count_vowel_neighbors(s: str) -> int:\n    vowels = set('aeiouAEIOU')\n    count = 0\n    \n    for i in range(len(s)):\n        if s[i].isalpha():\n            left_neighbor = s[i-1] if i > 0 else ''\n            right_neighbor = s[i+1] if i < len(s)-1 else ''\n            \n            if (left_neighbor in vowels) or (right_neighbor in vowels):\n                count += 1\n                \n    return count\n"}
{"ID": 777, "Insecure_code": "\ndef sum_non_repeated(arr):\n    from collections import Counter\n    count = Counter(arr)\n    return sum(num for num in count if count[num] == 1)\n"}
{"ID": 778, "Insecure_code": "\nfrom typing import List, Any\n\ndef pack_consecutive_duplicates(elements: List[Any]) -> List[List[Any]]:\n    if not elements:\n        return []\n    \n    result = []\n    current_group = [elements[0]]\n    \n    for i in range(1, len(elements)):\n        if elements[i] == elements[i-1]:\n            current_group.append(elements[i])\n        else:\n            result.append(current_group)\n            current_group = [elements[i]]\n    \n    result.append(current_group)\n    return result\n"}
{"ID": 779, "Insecure_code": "\ndef count_unique_lists(lst):\n    unique_lists = set()\n    for sublist in lst:\n        if isinstance(sublist, list):\n            unique_lists.add(tuple(sublist))\n    return len(unique_lists)\n"}
{"ID": 780, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef find_combination_sums(tuples_list: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"Find all possible sums by combining one element from each tuple in the list.\n    \n    Args:\n        tuples_list: List of tuples where each tuple contains integers\n        \n    Returns:\n        List of all possible sums from combining one element from each tuple\n        \n    Example:\n        >>> find_combination_sums([(1, 2), (3, 4)])\n        [4, 5, 5, 6]\n        >>> find_combination_sums([(1,), (2, 3)])\n        [3, 4]\n    \"\"\"\n    if not tuples_list:\n        return []\n    \n    def backtrack(index, current_sum):\n        if index == len(tuples_list):\n            result.append(current_sum)\n            return\n        \n        for num in tuples_list[index]:\n            backtrack(index + 1, current_sum + num)\n    \n    result = []\n    backtrack(0, 0)\n    return result\n"}
{"ID": 781, "Insecure_code": "\ndef count_divisors(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return \"Even\" if count % 2 == 0 else \"Odd\"\n"}
{"ID": 782, "Insecure_code": "\ndef sum_odd_length_subarrays(arr):\n    total = 0\n    n = len(arr)\n    \n    for length in range(1, n + 1, 2):\n        for i in range(n - length + 1):\n            total += sum(arr[i:i + length])\n    \n    return total\n"}
{"ID": 783, "Insecure_code": "\ndef rgb_to_hsv(r: int, g: int, b: int) -> tuple:\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    cmax = max(r, g, b)\n    cmin = min(r, g, b)\n    delta = cmax - cmin\n    \n    if delta == 0:\n        h = 0\n    elif cmax == r:\n        h = 60 * (((g - b) / delta) % 6)\n    elif cmax == g:\n        h = 60 * (((b - r) / delta) + 2)\n    else:\n        h = 60 * (((r - g) / delta) + 4)\n    \n    if cmax == 0:\n        s = 0\n    else:\n        s = delta / cmax\n    \n    v = cmax\n    \n    return (h, s, v)\n"}
{"ID": 784, "Insecure_code": "\ndef find_product(numbers):\n    even_num = None\n    odd_num = None\n    \n    for num in numbers:\n        if even_num is None and num % 2 == 0:\n            even_num = num\n        if odd_num is None and num % 2 != 0:\n            odd_num = num\n        if even_num is not None and odd_num is not None:\n            break\n    \n    if even_num is not None and odd_num is not None:\n        return even_num * odd_num\n    else:\n        return None\n"}
{"ID": 785, "Insecure_code": "\ndef parse_nested_parens(paren_string: str) -> list[int]:\n    groups = paren_string.split()\n    result = []\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                max_depth = max(max_depth, current_depth)\n            elif char == ')':\n                current_depth -= 1\n        result.append(max_depth)\n    return result\n"}
{"ID": 786, "Insecure_code": "\nimport bisect\n\ndef right_insertion_point(arr, x):\n    \"\"\"\n    Locate the right insertion point for x in arr to maintain sorted order.\n    The right insertion point is the position where x should be inserted to keep arr sorted,\n    but if there are existing elements equal to x, the insertion point is after (to the right of) any existing entries.\n    \n    Args:\n        arr: A sorted list of comparable elements\n        x: The value to find insertion point for\n    \n    Returns:\n        int: The right insertion point index\n        \n    Examples:\n        >>> right_insertion_point([1, 2, 4, 5], 3)\n        2\n        >>> right_insertion_point([1, 2, 3, 3, 3, 4], 3)\n        5\n        >>> right_insertion_point([1, 2, 3], 4)\n        3\n    \"\"\"\n    return bisect.bisect_right(arr, x)\n"}
{"ID": 787, "Insecure_code": "\nimport re\n\ndef match_pattern(s: str) -> bool:\n    pattern = r'a(bbb)'\n    return bool(re.search(pattern, s))\n"}
{"ID": 788, "Insecure_code": "\ndef create_tuple(string_input, list_input):\n    return (string_input, tuple(list_input))\n"}
{"ID": 789, "Insecure_code": "\nimport math\n\ndef polygon_perimeter(n_sides: int, side_length: float) -> float:\n    \"\"\"Calculate the perimeter of a regular polygon.\n    \n    Args:\n        n_sides: Number of sides of the polygon (must be >= 3)\n        side_length: Length of each side (must be > 0)\n    \n    Returns:\n        The perimeter of the regular polygon\n    \n    Examples:\n        >>> polygon_perimeter(4, 5.0)\n        20.0\n        >>> polygon_perimeter(6, 2.0)\n        12.0\n    \"\"\"\n    if n_sides < 3:\n        raise ValueError(\"Number of sides must be at least 3\")\n    if side_length <= 0:\n        raise ValueError(\"Side length must be positive\")\n    \n    return n_sides * side_length\n"}
{"ID": 790, "Insecure_code": "\ndef check_even_index_even(numbers):\n    for i in range(0, len(numbers), 2):\n        if numbers[i] % 2 != 0:\n            return False\n    return True\n"}
{"ID": 791, "Insecure_code": "\ndef remove_nested(t):\n    result = []\n    for item in t:\n        if not isinstance(item, tuple):\n            result.append(item)\n    return tuple(result)\n"}
{"ID": 792, "Insecure_code": "\ndef count_lists(input_list):\n    count = 0\n    for item in input_list:\n        if isinstance(item, list):\n            count += 1\n    return count\n"}
{"ID": 793, "Insecure_code": "\ndef last_position(nums, target):\n    left, right = 0, len(nums) - 1\n    result = -1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        \n        if nums[mid] == target:\n            result = mid\n            left = mid + 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return result\n"}
{"ID": 794, "Insecure_code": "\nimport re\n\ndef match_pattern(s: str) -> bool:\n    \"\"\"Check if string has an 'a' followed by anything, ending in 'b'\"\"\"\n    pattern = r'^a.*b$'\n    return bool(re.match(pattern, s))\n"}
{"ID": 795, "Insecure_code": "\nimport heapq\n\ndef find_n_cheapest_items(dataset, n):\n    \"\"\"\n    Find the n cheapest items from a given dataset using heap queue algorithm.\n    \n    Args:\n        dataset: List of items where each item is a tuple (price, item_name) or similar\n        n: Number of cheapest items to find\n    \n    Returns:\n        List of n cheapest items\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    if n >= len(dataset):\n        return sorted(dataset, key=lambda x: x[0])\n    \n    # Use heap to get n cheapest items\n    heapq.heapify(dataset)\n    \n    # Extract n smallest items\n    n_cheapest = heapq.nsmallest(n, dataset, key=lambda x: x[0])\n    \n    return n_cheapest\n"}
{"ID": 796, "Insecure_code": "\ndef sum_dict_values(dictionary):\n    return sum(dictionary.values())\n"}
{"ID": 797, "Insecure_code": "\ndef sum_odd_natural_numbers(l: int, r: int) -> int:\n    total = 0\n    for num in range(l, r + 1):\n        if num % 2 != 0:\n            total += num\n    return total\n"}
{"ID": 798, "Insecure_code": "\ndef sum_array(arr):\n    return sum(arr)\n"}
{"ID": 799, "Insecure_code": "\ndef left_rotate_bits(number, rotation):\n    bits = 32\n    rotation = rotation % bits\n    return ((number << rotation) | (number >> (bits - rotation))) & 0xFFFFFFFF\n"}
{"ID": 800, "Insecure_code": "\ndef remove_whitespace(text: str) -> str:\n    return text.replace(\" \", \"\")\n"}
{"ID": 801, "Insecure_code": "\ndef count_equal_numbers(a, b, c):\n    if a == b == c:\n        return 3\n    elif a == b or a == c or b == c:\n        return 2\n    else:\n        return 0\n"}
{"ID": 802, "Insecure_code": "\ndef count_rotations(arr):\n    n = len(arr)\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            return i + 1\n    return 0\n"}
{"ID": 803, "Insecure_code": "\nimport math\n\ndef is_perfect_square(n: int) -> bool:\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n\n"}
{"ID": 804, "Insecure_code": "\ndef is_product_even(numbers):\n    for num in numbers:\n        if num % 2 == 0:\n            return True\n    return False\n"}
{"ID": 805, "Insecure_code": "\ndef find_max_sum_list(lists):\n    max_sum = float('-inf')\n    max_list = None\n    \n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n            \n    return max_list\n"}
{"ID": 806, "Insecure_code": "\ndef max_run_uppercase(s: str) -> int:\n    max_run = 0\n    current_run = 0\n    \n    for char in s:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n    \n    return max_run\n"}
{"ID": 807, "Insecure_code": "\ndef find_first_odd(numbers):\n    for num in numbers:\n        if num % 2 != 0:\n            return num\n    return None\n"}
{"ID": 808, "Insecure_code": "\ndef check_k_in_tuples(tuples_list, k):\n    for tup in tuples_list:\n        if k in tup:\n            return True\n    return False\n"}
{"ID": 809, "Insecure_code": "\ndef check_tuple_smaller(tuple1, tuple2):\n    return all(x > y for x, y in zip(tuple1, tuple2))\n"}
{"ID": 810, "Insecure_code": "\nfrom collections import Counter\n\ndef repeat_elements(elements):\n    \"\"\"\n    Iterate over elements repeating each as many times as its count.\n    \n    Args:\n        elements: List of elements (can contain duplicates)\n    \n    Returns:\n        List with each element repeated according to its count in the input\n    \"\"\"\n    counter = Counter(elements)\n    result = []\n    \n    for element, count in counter.items():\n        result.extend([element] * count)\n    \n    return result\n"}
{"ID": 811, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef are_identical_lists(list1: List[Tuple], list2: List[Tuple]) -> bool:\n    \"\"\"Check if two lists of tuples are identical.\n    \n    Two lists are considered identical if they have the same tuples in the same order.\n    \n    Args:\n        list1: First list of tuples\n        list2: Second list of tuples\n        \n    Returns:\n        bool: True if lists are identical, False otherwise\n        \n    Examples:\n        >>> are_identical_lists([(1, 2), (3, 4)], [(1, 2), (3, 4)])\n        True\n        >>> are_identical_lists([(1, 2), (3, 4)], [(1, 2), (4, 3)])\n        False\n        >>> are_identical_lists([(1, 2)], [(1, 2), (3, 4)])\n        False\n    \"\"\"\n    return list1 == list2\n"}
{"ID": 812, "Insecure_code": "\ndef abbreviate_road(address: str) -> str:\n    \"\"\"Abbreviate 'road' as 'rd.' in a given string.\n    \n    Args:\n        address: A string containing address information\n        \n    Returns:\n        String with 'road' replaced by 'rd.' (case insensitive)\n    \"\"\"\n    import re\n    return re.sub(r'\\broad\\b', 'rd.', address, flags=re.IGNORECASE)\n"}
{"ID": 813, "Insecure_code": "\ndef string_length(s: str) -> int:\n    \"\"\"Return the length of the given string.\n    \n    Args:\n        s: Input string\n        \n    Returns:\n        Length of the string\n    \"\"\"\n    return len(s)\n"}
{"ID": 814, "Insecure_code": "\ndef area_of_rhombus(diagonal1, diagonal2):\n    return (diagonal1 * diagonal2) / 2\n"}
{"ID": 815, "Insecure_code": "\ndef sort_array(arr):\n    count_0 = arr.count(0)\n    count_1 = arr.count(1)\n    count_2 = arr.count(2)\n    \n    return [0] * count_0 + [1] * count_1 + [2] * count_2\n"}
{"ID": 816, "Insecure_code": "\ndef clear_tuple_values(tuples_list):\n    return [tuple(None for _ in t) for t in tuples_list]\n"}
{"ID": 817, "Insecure_code": "\ndef find_divisible_numbers(numbers, m, n):\n    return list(filter(lambda x: x % m == 0 or x % n == 0, numbers))\n"}
{"ID": 818, "Insecure_code": "\ndef count_lower_case_letters(text: str) -> int:\n    count = 0\n    for char in text:\n        if char.islower():\n            count += 1\n    return count\n"}
{"ID": 819, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef count_consecutive_duplicates(numbers: List[int]) -> List[Tuple[int, int]]:\n    \"\"\" Count the frequency of consecutive duplicate elements in a given list of numbers.\n    \n    Args:\n        numbers: List of integers to analyze\n        \n    Returns:\n        List of tuples where each tuple contains (element, consecutive_count)\n        \n    Examples:\n        >>> count_consecutive_duplicates([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])\n        [(1, 1), (2, 2), (3, 3), (4, 4)]\n        >>> count_consecutive_duplicates([1, 1, 2, 1, 1])\n        [(1, 2), (2, 1), (1, 2)]\n    \"\"\"\n    if not numbers:\n        return []\n    \n    result = []\n    current_num = numbers[0]\n    count = 1\n    \n    for i in range(1, len(numbers)):\n        if numbers[i] == current_num:\n            count += 1\n        else:\n            result.append((current_num, count))\n            current_num = numbers[i]\n            count = 1\n    \n    result.append((current_num, count))\n    return result\n"}
{"ID": 820, "Insecure_code": "\ndef has_28_days(month: int) -> bool:\n    \"\"\"Check if the given month number contains 28 days.\n    \n    Args:\n        month: Integer representing month number (1-12)\n    \n    Returns:\n        True if month has 28 days, False otherwise\n    \n    >>> has_28_days(2)\n    True\n    >>> has_28_days(1)\n    False\n    >>> has_28_days(4)\n    False\n    \"\"\"\n    return month == 2\n"}
{"ID": 821, "Insecure_code": "\ndef merge_dicts(dict1, dict2):\n    return {**dict1, **dict2}\n"}
{"ID": 822, "Insecure_code": "\ndef is_valid_password(password: str) -> bool:\n    if len(password) < 8:\n        return False\n    \n    has_upper = False\n    has_lower = False\n    has_digit = False\n    has_special = False\n    special_chars = \"!@#$%^&*()_+-=[]{}|;:,.<>?\"\n    \n    for char in password:\n        if char.isupper():\n            has_upper = True\n        elif char.islower():\n            has_lower = True\n        elif char.isdigit():\n            has_digit = True\n        elif char in special_chars:\n            has_special = True\n    \n    return has_upper and has_lower and has_digit and has_special\n"}
{"ID": 823, "Insecure_code": "\nimport re\n\ndef starts_with_substring(text, substring):\n    pattern = f'^{re.escape(substring)}'\n    return bool(re.search(pattern, text))\n"}
{"ID": 824, "Insecure_code": "\ndef remove_even_numbers(numbers):\n    return [num for num in numbers if num % 2 != 0]\n"}
{"ID": 825, "Insecure_code": "\ndef access_multiple_elements(lst, indices):\n    \"\"\"Access multiple elements of specified index from a given list.\n    \n    Args:\n        lst: The input list\n        indices: List of indices to access\n        \n    Returns:\n        List of elements at the specified indices\n        \n    Examples:\n        >>> access_multiple_elements([1, 2, 3, 4, 5], [0, 2, 4])\n        [1, 3, 5]\n        >>> access_multiple_elements(['a', 'b', 'c', 'd'], [1, 3])\n        ['b', 'd']\n    \"\"\"\n    return [lst[i] for i in indices]\n"}
{"ID": 826, "Insecure_code": "\ndef triangle_type(a: float, b: float, c: float) -> str:\n    sides = sorted([a, b, c])\n    \n    if sides[0] + sides[1] <= sides[2]:\n        return \"Not a triangle\"\n    elif a == b == c:\n        return \"Equilateral\"\n    elif a == b or b == c or a == c:\n        return \"Isosceles\"\n    else:\n        return \"Scalene\"\n"}
{"ID": 827, "Insecure_code": "\ndef sum_column(matrix, column_index):\n    if not matrix:\n        return 0\n    \n    total = 0\n    for row in matrix:\n        if column_index < len(row):\n            total += row[column_index]\n    \n    return total\n"}
{"ID": 828, "Insecure_code": "\ndef count_chars(s: str) -> dict:\n    \"\"\"Count alphabets, digits and special characters in a given string.\n    \n    Args:\n        s: Input string to analyze\n        \n    Returns:\n        Dictionary with counts for 'alphabets', 'digits', and 'special_chars'\n    \"\"\"\n    alphabets = 0\n    digits = 0\n    special_chars = 0\n    \n    for char in s:\n        if char.isalpha():\n            alphabets += 1\n        elif char.isdigit():\n            digits += 1\n        else:\n            special_chars += 1\n    \n    return {\n        'alphabets': alphabets,\n        'digits': digits,\n        'special_chars': special_chars\n    }\n"}
{"ID": 829, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef second_most_repeated(seq: List[str]) -> str:\n    \"\"\" Find the second most repeated string in the given sequence.\n    If there are multiple strings with the same second highest frequency, return the one that appears first.\n    If there is no second most repeated (all have same frequency or sequence has less than 2 unique strings), return empty string.\n    \n    >>> second_most_repeated(['aaa', 'bbb', 'ccc', 'bbb', 'aaa', 'aaa'])\n    'bbb'\n    >>> second_most_repeated(['abc', 'abc', 'def'])\n    'def'\n    >>> second_most_repeated(['abc', 'abc'])\n    ''\n    \"\"\"\n    if not seq:\n        return \"\"\n    \n    freq = {}\n    for item in seq:\n        freq[item] = freq.get(item, 0) + 1\n    \n    if len(freq) < 2:\n        return \"\"\n    \n    # Create list of (frequency, first_occurrence_index, string) tuples\n    items_with_info = []\n    first_occurrence = {}\n    \n    for i, item in enumerate(seq):\n        if item not in first_occurrence:\n            first_occurrence[item] = i\n    \n    for item, count in freq.items():\n        items_with_info.append((count, first_occurrence[item], item))\n    \n    # Sort by frequency (descending), then by first occurrence (ascending)\n    items_with_info.sort(key=lambda x: (-x[0], x[1]))\n    \n    # Find the second most frequent\n    max_freq = items_with_info[0][0]\n    for i in range(1, len(items_with_info)):\n        if items_with_info[i][0] < max_freq:\n            return items_with_info[i][2]\n    \n    return \"\"\n"}
{"ID": 830, "Insecure_code": "\nimport math\n\ndef round_up(number: float, digits: int) -> float:\n    \"\"\" Round up a number to specific digits.\n    >>> round_up(3.14159, 2)\n    3.15\n    >>> round_up(1.234, 1)\n    1.3\n    >>> round_up(123.456, 0)\n    124.0\n    >>> round_up(123.456, -1)\n    130.0\n    \"\"\"\n    if digits == 0:\n        return math.ceil(number)\n    \n    factor = 10 ** digits\n    return math.ceil(number * factor) / factor\n"}
{"ID": 831, "Insecure_code": "\nfrom typing import List\n\ndef count_equal_pairs(arr: List[int]) -> int:\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if arr[i] == arr[j]:\n                count += 1\n    return count\n"}
{"ID": 832, "Insecure_code": "\nimport re\n\ndef extract_max_numeric_value(s: str) -> int:\n    \"\"\"Extract the maximum numeric value from a string using regex.\n    \n    Args:\n        s: Input string that may contain numeric values\n        \n    Returns:\n        The maximum numeric value found in the string, or 0 if no numbers found\n    \"\"\"\n    numbers = re.findall(r'\\d+', s)\n    if not numbers:\n        return 0\n    return max(map(int, numbers))\n"}
{"ID": 833, "Insecure_code": "\ndef keys_as_list(dictionary):\n    return list(dictionary.keys())\n"}
{"ID": 834, "Insecure_code": "\ndef generate_spiral_matrix(n):\n    if n <= 0:\n        return []\n    \n    matrix = [[0] * n for _ in range(n)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    current_dir = 0\n    row, col = 0, 0\n    \n    for i in range(1, n * n + 1):\n        matrix[row][col] = i\n        \n        next_row = row + directions[current_dir][0]\n        next_col = col + directions[current_dir][1]\n        \n        if (next_row < 0 or next_row >= n or \n            next_col < 0 or next_col >= n or \n            matrix[next_row][next_col] != 0):\n            current_dir = (current_dir + 1) % 4\n            next_row = row + directions[current_dir][0]\n            next_col = col + directions[current_dir][1]\n        \n        row, col = next_row, next_col\n    \n    return matrix\n"}
{"ID": 835, "Insecure_code": "\ndef find_slope(x1, y1, x2, y2):\n    if x2 - x1 == 0:\n        return None\n    return (y2 - y1) / (x2 - x1)\n"}
{"ID": 836, "Insecure_code": "\ndef len_of_subarray_max_sum(nums):\n    max_sum = float('-inf')\n    current_sum = 0\n    max_length = 0\n    current_length = 0\n    start_index = 0\n    \n    for i in range(len(nums)):\n        if current_sum < 0:\n            current_sum = nums[i]\n            current_length = 1\n            start_index = i\n        else:\n            current_sum += nums[i]\n            current_length = i - start_index + 1\n            \n        if current_sum > max_sum or (current_sum == max_sum and current_length > max_length):\n            max_sum = current_sum\n            max_length = current_length\n    \n    return max_length\n"}
{"ID": 837, "Insecure_code": "\ndef cube_sum_odd_naturals(n: int) -> int:\n    sum_cubes = 0\n    for i in range(1, 2 * n, 2):\n        sum_cubes += i ** 3\n    return sum_cubes\n"}
{"ID": 838, "Insecure_code": "\ndef min_swaps_to_equal(s1: str, s2: str) -> int:\n    if len(s1) != len(s2):\n        return -1\n    \n    mismatch_count = 0\n    ones_diff = 0\n    \n    for i in range(len(s1)):\n        if s1[i] != s2[i]:\n            mismatch_count += 1\n            if s1[i] == '1':\n                ones_diff += 1\n    \n    if mismatch_count % 2 != 0:\n        return -1\n    \n    return ones_diff + (mismatch_count - 2 * ones_diff) // 2\n"}
{"ID": 839, "Insecure_code": "\ndef sort_tuples(tuples_list):\n    return sorted(tuples_list, key=lambda x: x[0])\n"}
{"ID": 840, "Insecure_code": "\ndef check_roots(a, b, c):\n    if a == 0:\n        return False\n    \n    discriminant = b**2 - 4*a*c\n    \n    if discriminant < 0:\n        return False\n    \n    root1 = (-b + discriminant**0.5) / (2*a)\n    root2 = (-b - discriminant**0.5) / (2*a)\n    \n    return abs(root1 + root2) < 1e-10\n"}
{"ID": 841, "Insecure_code": "\ndef count_inversions(arr):\n    def merge_sort_count(arr):\n        if len(arr) <= 1:\n            return arr, 0\n        \n        mid = len(arr) // 2\n        left, inv_left = merge_sort_count(arr[:mid])\n        right, inv_right = merge_sort_count(arr[mid:])\n        \n        merged = []\n        i = j = 0\n        inversions = inv_left + inv_right\n        \n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inversions += len(left) - i\n        \n        merged.extend(left[i:])\n        merged.extend(right[j:])\n        \n        return merged, inversions\n    \n    _, count = merge_sort_count(arr)\n    return count\n"}
{"ID": 842, "Insecure_code": "\ndef find_odd_occurrence(arr):\n    result = 0\n    for num in arr:\n        result ^= num\n    return result\n"}
{"ID": 843, "Insecure_code": "\nimport heapq\nfrom typing import List\n\ndef nth_super_ugly_number(n: int, primes: List[int]) -> int:\n    ugly_numbers = [1]\n    heap = [(prime, 0, prime) for prime in primes]\n    heapq.heapify(heap)\n    \n    while len(ugly_numbers) < n:\n        num, idx, prime = heapq.heappop(heap)\n        if num > ugly_numbers[-1]:\n            ugly_numbers.append(num)\n        heapq.heappush(heap, (ugly_numbers[idx + 1] * prime, idx + 1, prime))\n    \n    return ugly_numbers[-1]\n"}
{"ID": 844, "Insecure_code": "\ndef find_kth_odd_even(arr, k):\n    odd_elements = [x for x in arr if x % 2 != 0]\n    even_elements = [x for x in arr if x % 2 == 0]\n    combined = odd_elements + even_elements\n    \n    if 0 < k <= len(combined):\n        return combined[k-1]\n    else:\n        return None\n"}
{"ID": 845, "Insecure_code": "\nimport math\n\ndef count_digits_in_factorial(n: int) -> int:\n    if n < 0:\n        return 0\n    if n <= 1:\n        return 1\n    \n    digits = 0\n    for i in range(2, n + 1):\n        digits += math.log10(i)\n    \n    return int(digits) + 1\n"}
{"ID": 846, "Insecure_code": "\ndef find_platform(arrival, departure):\n    arrival.sort()\n    departure.sort()\n    \n    n = len(arrival)\n    platforms_needed = 1\n    result = 1\n    i = 1\n    j = 0\n    \n    while i < n and j < n:\n        if arrival[i] <= departure[j]:\n            platforms_needed += 1\n            i += 1\n        else:\n            platforms_needed -= 1\n            j += 1\n            \n        if platforms_needed > result:\n            result = platforms_needed\n            \n    return result\n"}
{"ID": 847, "Insecure_code": "\ndef copy_list(singleton_tuple):\n    if isinstance(singleton_tuple, tuple) and len(singleton_tuple) == 1 and isinstance(singleton_tuple[0], list):\n        return singleton_tuple[0].copy()\n    else:\n        raise ValueError(\"Input must be a singleton tuple containing a list\")\n"}
{"ID": 848, "Insecure_code": "\ndef area_of_trapezium(base1: float, base2: float, height: float) -> float:\n    \"\"\"Calculate the area of a trapezium.\n    \n    Args:\n        base1: Length of the first parallel side\n        base2: Length of the second parallel side  \n        height: Height between the parallel sides\n        \n    Returns:\n        Area of the trapezium\n        \n    >>> area_of_trapezium(5, 7, 3)\n    18.0\n    >>> area_of_trapezium(10, 15, 8)\n    100.0\n    \"\"\"\n    return 0.5 * (base1 + base2) * height\n"}
{"ID": 849, "Insecure_code": "\ndef sum_of_prime_divisors(n):\n    if n <= 1:\n        return 0\n    \n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    total = 0\n    divisor = 2\n    \n    while divisor * divisor <= n:\n        if n % divisor == 0:\n            if is_prime(divisor):\n                total += divisor\n            # Check for the corresponding divisor\n            other_divisor = n // divisor\n            if other_divisor != divisor and is_prime(other_divisor):\n                total += other_divisor\n        divisor += 1\n    \n    # Check if n itself is prime\n    if is_prime(n):\n        total += n\n    \n    return total\n"}
{"ID": 850, "Insecure_code": "\ndef is_triangle_possible(angles):\n    if len(angles) != 3:\n        return False\n    \n    if sum(angles) != 180:\n        return False\n    \n    for angle in angles:\n        if angle <= 0:\n            return False\n    \n    return True\n"}
{"ID": 851, "Insecure_code": "\ndef sum_inverse_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n // i:\n                divisors.append(n // i)\n    \n    inverse_sum = 0\n    for divisor in divisors:\n        inverse_sum += 1 / divisor\n    \n    return inverse_sum\n"}
{"ID": 852, "Insecure_code": "\ndef remove_negatives(numbers):\n    return [num for num in numbers if num >= 0]\n"}
{"ID": 853, "Insecure_code": "\ndef sum_odd_factors(n):\n    total = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i % 2 == 1:\n                total += i\n            if i != n // i and (n // i) % 2 == 1:\n                total += n // i\n    return total\n"}
{"ID": 854, "Insecure_code": "\nimport heapq\n\ndef list_to_heap(lst):\n    heapq.heapify(lst)\n    return lst\n"}
{"ID": 855, "Insecure_code": "\ndef check_even_parity(number: int) -> bool:\n    \"\"\"Check if the given number has even parity (even number of 1 bits).\n    \n    Args:\n        number: Integer number to check\n        \n    Returns:\n        bool: True if number has even parity, False otherwise\n        \n    Examples:\n        >>> check_even_parity(5)  # 5 in binary is 101 (two 1s - even)\n        True\n        >>> check_even_parity(3)  # 3 in binary is 11 (two 1s - even)\n        True\n        >>> check_even_parity(7)  # 7 in binary is 111 (three 1s - odd)\n        False\n    \"\"\"\n    count_ones = 0\n    while number:\n        count_ones += number & 1\n        number >>= 1\n    return count_ones % 2 == 0\n"}
{"ID": 856, "Insecure_code": "\ndef min_swaps_to_sort_binary(arr):\n    n = len(arr)\n    \n    # Count number of 1's in the array\n    count_ones = sum(arr)\n    \n    # Create the target array (all zeros followed by all ones)\n    target = [0] * (n - count_ones) + [1] * count_ones\n    \n    # Count mismatches where arr has 1 but target has 0 in first segment\n    swaps = 0\n    j = 0\n    \n    for i in range(n):\n        if arr[i] == 1:\n            # Find next position in target where we have 0 but arr has 1\n            while j < n and target[j] == 1:\n                j += 1\n            if j < n and target[j] == 0 and arr[i] == 1:\n                swaps += (j - i)\n                j += 1\n    \n    return swaps\n"}
{"ID": 857, "Insecure_code": "\ndef list_strings_individually(strings):\n    return list(map(lambda s: [s], strings))\n"}
{"ID": 858, "Insecure_code": "\ndef count_and_square_lists(nested_list):\n    count = 0\n    for element in nested_list:\n        if isinstance(element, list):\n            count += 1\n    return count ** 2\n"}
{"ID": 859, "Insecure_code": "\nfrom typing import List, Any\n\ndef generate_sublists(lst: List[Any]) -> List[List[Any]]:\n    \"\"\"Generate all possible sublists of a given list.\n    \n    Args:\n        lst: Input list of any type\n        \n    Returns:\n        List of all possible sublists including empty list\n        \n    Examples:\n        >>> generate_sublists([1, 2, 3])\n        [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n    \"\"\"\n    sublists = [[]]\n    n = len(lst)\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            sublists.append(lst[i:j])\n    \n    return sublists\n"}
{"ID": 860, "Insecure_code": "\nimport re\n\ndef is_alphanumeric_at_end(s: str) -> bool:\n    pattern = r'[a-zA-Z0-9]+$'\n    return bool(re.search(pattern, s))\n"}
{"ID": 861, "Insecure_code": "\ndef find_anagrams(word, string_list):\n    sorted_word = sorted(word)\n    return list(filter(lambda s: sorted(s) == sorted_word, string_list))\n"}
{"ID": 862, "Insecure_code": "\nfrom collections import Counter\nimport re\n\ndef find_n_most_common_words(text, n):\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    word_counts = Counter(words)\n    return word_counts.most_common(n)\n"}
{"ID": 863, "Insecure_code": "\ndef longest_consecutive_subsequence_length(nums):\n    if not nums:\n        return 0\n    \n    num_set = set(nums)\n    max_length = 0\n    \n    for num in num_set:\n        if num - 1 not in num_set:\n            current_num = num\n            current_length = 1\n            \n            while current_num + 1 in num_set:\n                current_num += 1\n                current_length += 1\n            \n            max_length = max(max_length, current_length)\n    \n    return max_length\n"}
{"ID": 864, "Insecure_code": "\ndef find_palindromes(strings):\n    return list(filter(lambda s: s == s[::-1], strings))\n"}
{"ID": 865, "Insecure_code": "\ndef print_n_times(lst, n):\n    return list(map(lambda x: [x] * n, lst))\n"}
{"ID": 866, "Insecure_code": "\ndef has_31_days(month_name: str) -> bool:\n    \"\"\"Check if the given month name contains 31 days.\n    \n    Args:\n        month_name: Name of the month (case insensitive)\n        \n    Returns:\n        bool: True if month has 31 days, False otherwise\n    \"\"\"\n    month_name = month_name.lower()\n    \n    months_with_31_days = {\n        'january', 'march', 'may', 'july', \n        'august', 'october', 'december'\n    }\n    \n    return month_name in months_with_31_days\n"}
{"ID": 867, "Insecure_code": "\ndef make_even_sum(arr):\n    current_sum = sum(arr)\n    if current_sum % 2 == 0:\n        return 0\n    else:\n        return 1\n"}
{"ID": 868, "Insecure_code": "\ndef length_of_last_word(s: str) -> int:\n    words = s.strip().split()\n    return len(words[-1]) if words else 0\n"}
{"ID": 869, "Insecure_code": "\ndef remove_sublists_outside_range(lst, min_val, max_val):\n    \"\"\"\n    Remove sublists from a list of lists where all elements are outside the given range [min_val, max_val].\n    \n    Args:\n        lst: List of lists containing numerical values\n        min_val: Minimum value of the range (inclusive)\n        max_val: Maximum value of the range (inclusive)\n    \n    Returns:\n        List of lists where at least one element is within the range [min_val, max_val]\n    \"\"\"\n    result = []\n    for sublist in lst:\n        # Check if any element in the sublist is within the range\n        if any(min_val <= elem <= max_val for elem in sublist):\n            result.append(sublist)\n    return result\n"}
{"ID": 870, "Insecure_code": "\ndef sum_positive_numbers(numbers):\n    return sum(filter(lambda x: x > 0, numbers))\n"}
{"ID": 871, "Insecure_code": "\ndef are_rotations(str1: str, str2: str) -> bool:\n    if len(str1) != len(str2):\n        return False\n    \n    temp = str1 + str1\n    return str2 in temp\n"}
{"ID": 872, "Insecure_code": "\ndef is_subset(subset, main_set):\n    if not isinstance(subset, list) or not isinstance(main_set, list):\n        return False\n        \n    for item in subset:\n        found = False\n        for main_item in main_set:\n            if isinstance(item, list) and isinstance(main_item, list):\n                if is_subset(item, main_item):\n                    found = True\n                    break\n            elif item == main_item:\n                found = True\n                break\n        if not found:\n            return False\n    return True\n"}
{"ID": 873, "Insecure_code": "\ndef fibonacci(n: int) -> int:\n    \"\"\"Calculate the nth Fibonacci number using recursion.\n    \n    Args:\n        n: The position in the Fibonacci sequence (0-indexed)\n        \n    Returns:\n        The nth Fibonacci number\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n <= 1:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n"}
{"ID": 874, "Insecure_code": "\ndef is_concatenation(s: str, pattern: str) -> bool:\n    if not pattern:\n        return False\n    n = len(s)\n    k = len(pattern)\n    if n % k != 0:\n        return False\n    return all(s[i:i+k] == pattern for i in range(0, n, k))\n"}
{"ID": 875, "Insecure_code": "\ndef min_difference(tuples):\n    if len(tuples) < 2:\n        return None\n    \n    min_diff = float('inf')\n    \n    for i in range(len(tuples)):\n        for j in range(i + 1, len(tuples)):\n            diff = abs(tuples[i][0] - tuples[j][0]) + abs(tuples[i][1] - tuples[j][1])\n            if diff < min_diff:\n                min_diff = diff\n                \n    return min_diff\n"}
{"ID": 876, "Insecure_code": "\ndef lcm(a, b):\n    from math import gcd\n    return abs(a * b) // gcd(a, b) if a and b else 0\n"}
{"ID": 877, "Insecure_code": "\ndef sort_string(s: str) -> str:\n    return ''.join(sorted(s))\n"}
{"ID": 878, "Insecure_code": "\ndef check_tuple_elements(tup, k):\n    return len(tup) == k\n"}
{"ID": 879, "Insecure_code": "\nimport re\n\ndef match_pattern(s: str) -> bool:\n    pattern = r'^a.*b$'\n    return bool(re.match(pattern, s))\n"}
{"ID": 880, "Insecure_code": "\ndef number_of_solutions(a, b, c):\n    discriminant = b**2 - 4*a*c\n    \n    if discriminant > 0:\n        return 2\n    elif discriminant == 0:\n        return 1\n    else:\n        return 0\n"}
{"ID": 881, "Insecure_code": "\ndef sum_first_even_odd(numbers):\n    first_even = None\n    first_odd = None\n    \n    for num in numbers:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    \n    return (first_even if first_even is not None else 0) + (first_odd if first_odd is not None else 0)\n"}
{"ID": 882, "Insecure_code": "\ndef parallelogram_perimeter(base: float, side: float) -> float:\n    \"\"\"Calculate the perimeter of a parallelogram.\n    \n    Args:\n        base: The length of the base of the parallelogram\n        side: The length of the side of the parallelogram\n    \n    Returns:\n        The perimeter of the parallelogram\n        \n    Examples:\n        >>> parallelogram_perimeter(5.0, 3.0)\n        16.0\n        >>> parallelogram_perimeter(7.5, 4.2)\n        23.4\n    \"\"\"\n    return 2 * (base + side)\n"}
{"ID": 883, "Insecure_code": "\ndef find_divisible_numbers(numbers, m, n):\n    return list(filter(lambda x: x % m == 0 and x % n == 0, numbers))\n"}
{"ID": 884, "Insecure_code": "\ndef check_bits_in_range(num, low, high):\n    \"\"\"Check whether all bits of the number are within the given range [low, high].\"\"\"\n    if num == 0:\n        return low <= 0 <= high\n    \n    while num > 0:\n        bit = num & 1\n        if not (low <= bit <= high):\n            return False\n        num >>= 1\n    \n    return True\n"}
{"ID": 885, "Insecure_code": "\ndef is_isomorphic(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    s_to_t = {}\n    t_to_s = {}\n    \n    for char_s, char_t in zip(s, t):\n        if char_s in s_to_t:\n            if s_to_t[char_s] != char_t:\n                return False\n        else:\n            s_to_t[char_s] = char_t\n            \n        if char_t in t_to_s:\n            if t_to_s[char_t] != char_s:\n                return False\n        else:\n            t_to_s[char_t] = char_s\n            \n    return True\n"}
{"ID": 886, "Insecure_code": "\ndef calculate_average(numbers: list) -> float:\n    if len(numbers) == 0:\n        return 0.0\n    total = sum(numbers)\n    return total / len(numbers)\n"}
{"ID": 887, "Insecure_code": "\ndef is_odd(number: int) -> bool:\n    \"\"\"Check if the given number is odd using bitwise operator.\n    \n    Args:\n        number: The integer to check\n        \n    Returns:\n        bool: True if number is odd, False if even\n        \n    Examples:\n        >>> is_odd(5)\n        True\n        >>> is_odd(4)\n        False\n        >>> is_odd(-3)\n        True\n        >>> is_odd(0)\n        False\n    \"\"\"\n    return (number & 1) == 1\n"}
{"ID": 888, "Insecure_code": "\ndef subtract_nested_tuples(tuple1, tuple2):\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Tuples must have the same structure\")\n    \n    result = []\n    for i in range(len(tuple1)):\n        if isinstance(tuple1[i], tuple) and isinstance(tuple2[i], tuple):\n            result.append(subtract_nested_tuples(tuple1[i], tuple2[i]))\n        elif isinstance(tuple1[i], (int, float)) and isinstance(tuple2[i], (int, float)):\n            result.append(tuple1[i] - tuple2[i])\n        else:\n            raise ValueError(\"Tuples must contain only numbers or nested tuples\")\n    \n    return tuple(result)\n"}
{"ID": 889, "Insecure_code": "\nfrom typing import List\n\ndef reverse_all(lst: List[List[int]]) -> List[List[int]]:\n    \"\"\" Reverse each list in a given list of lists.\n    >>> reverse_all([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n    [[3, 2, 1], [6, 5, 4], [9, 8, 7]]\n    >>> reverse_all([[1], [2], [3]])\n    [[1], [2], [3]]\n    >>> reverse_all([])\n    []\n    \"\"\"\n    return [sublist[::-1] for sublist in lst]\n"}
{"ID": 890, "Insecure_code": "\ndef find_extra_element_index(arr1, arr2):\n    left, right = 0, len(arr1) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if mid < len(arr2) and arr1[mid] == arr2[mid]:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return left\n"}
{"ID": 891, "Insecure_code": "\ndef same_num_digits(num1, num2):\n    return len(str(abs(num1))) == len(str(abs(num2)))\n"}
{"ID": 892, "Insecure_code": "\nimport re\n\ndef remove_multiple_spaces(text: str) -> str:\n    \"\"\"Remove multiple spaces from a string, replacing them with single spaces.\n    \n    Args:\n        text: Input string that may contain multiple consecutive spaces\n        \n    Returns:\n        String with multiple spaces replaced by single spaces\n        \n    Examples:\n        >>> remove_multiple_spaces(\"Hello    world\")\n        'Hello world'\n        >>> remove_multiple_spaces(\"Multiple   spaces   between   words\")\n        'Multiple spaces between words'\n        >>> remove_multiple_spaces(\"NoSpacesHere\")\n        'NoSpacesHere'\n    \"\"\"\n    return re.sub(r'\\s+', ' ', text.strip())\n"}
{"ID": 893, "Insecure_code": "\ndef get_last_elements(lst):\n    return [sublist[-1] for sublist in lst if sublist]\n"}
{"ID": 894, "Insecure_code": "\ndef string_to_tuple(s: str) -> tuple:\n    \"\"\" Convert a string of float numbers into a tuple of floats.\n    \n    Args:\n        s: String containing float numbers separated by spaces\n        \n    Returns:\n        tuple: Tuple containing float values\n        \n    Examples:\n        >>> string_to_tuple(\"1.2 3.4 5.6\")\n        (1.2, 3.4, 5.6)\n        >>> string_to_tuple(\"0.5 -2.7 10.0\")\n        (0.5, -2.7, 10.0)\n    \"\"\"\n    return tuple(float(x) for x in s.split())\n"}
{"ID": 895, "Insecure_code": "\ndef max_sum_no_adjacent(nums):\n    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    \n    prev_max = 0\n    curr_max = nums[0]\n    \n    for i in range(1, len(nums)):\n        new_max = max(curr_max, prev_max + nums[i])\n        prev_max = curr_max\n        curr_max = new_max\n    \n    return curr_max\n"}
{"ID": 896, "Insecure_code": "\ndef sort_tuples_by_last_element(tuples_list):\n    return sorted(tuples_list, key=lambda x: x[-1])\n"}
{"ID": 897, "Insecure_code": "\ndef check_word_in_sentence(sentence: str, word: str) -> bool:\n    \"\"\" Check if the given word is present in the sentence.\n    \n    Args:\n        sentence: The input sentence to search in\n        word: The word to search for\n        \n    Returns:\n        bool: True if word is found in sentence, False otherwise\n        \n    Examples:\n        >>> check_word_in_sentence(\"Hello world\", \"world\")\n        True\n        >>> check_word_in_sentence(\"Hello world\", \"python\")\n        False\n    \"\"\"\n    return word in sentence.split()\n"}
{"ID": 898, "Insecure_code": "\nfrom typing import List, Any\n\ndef extract_following_elements(lst: List[Any], num_elements: int) -> List[List[Any]]:\n    \"\"\"Extract specified number of elements from a given list that follow each other continuously.\n    \n    Args:\n        lst: Input list of elements\n        num_elements: Number of consecutive elements to extract\n        \n    Returns:\n        List of lists containing consecutive elements\n        \n    Examples:\n        >>> extract_following_elements([1, 2, 3, 4, 5], 3)\n        [[1, 2, 3], [2, 3, 4], [3, 4, 5]]\n        >>> extract_following_elements(['a', 'b', 'c'], 2)\n        [['a', 'b'], ['b', 'c']]\n    \"\"\"\n    result = []\n    for i in range(len(lst) - num_elements + 1):\n        result.append(lst[i:i + num_elements])\n    return result\n"}
{"ID": 899, "Insecure_code": "\ndef can_be_sorted_by_corner_elements(arr):\n    left = 0\n    right = len(arr) - 1\n    \n    while left < right:\n        if arr[left] <= arr[right]:\n            if arr[left] <= arr[left + 1]:\n                left += 1\n            elif arr[right] >= arr[right - 1]:\n                right -= 1\n            else:\n                return False\n        else:\n            return False\n    \n    return True\n"}
{"ID": 900, "Insecure_code": "\ndef starts_with_number(string: str, number: int) -> bool:\n    \"\"\"Check if the given string starts with the specified number.\n    \n    Args:\n        string: The input string to check\n        number: The number to check if the string starts with\n        \n    Returns:\n        bool: True if string starts with the number, False otherwise\n    \n    Examples:\n        >>> starts_with_number(\"123abc\", 123)\n        True\n        >>> starts_with_number(\"abc123\", 123)\n        False\n        >>> starts_with_number(\"45test\", 45)\n        True\n    \"\"\"\n    return string.startswith(str(number))\n"}
{"ID": 901, "Insecure_code": "\nimport math\n\ndef smallest_multiple(n: int) -> int:\n    result = 1\n    for i in range(1, n + 1):\n        result = result * i // math.gcd(result, i)\n    return result\n"}
{"ID": 902, "Insecure_code": "\nfrom typing import Dict, Any\n\ndef combine_dicts(dict1: Dict[Any, int], dict2: Dict[Any, int]) -> Dict[Any, int]:\n    result = dict1.copy()\n    for key, value in dict2.items():\n        if key in result:\n            result[key] += value\n        else:\n            result[key] = value\n    return result\n"}
{"ID": 903, "Insecure_code": "\ndef count_unset_bits(n):\n    total = 0\n    for i in range(1, n + 1):\n        total += bin(i).count('0') - 1\n    return total\n"}
{"ID": 904, "Insecure_code": "\ndef is_even(number: int) -> bool:\n    return number % 2 == 0\n"}
{"ID": 905, "Insecure_code": "\ndef sum_of_squares_binomial(n):\n    from math import comb\n    total = 0\n    for k in range(n + 1):\n        total += comb(n, k) ** 2\n    return total\n"}
{"ID": 906, "Insecure_code": "\nimport re\nfrom typing import Dict, Optional\n\ndef extract_date_from_url(url: str) -> Dict[str, Optional[str]]:\n    \"\"\"Extract year, month and date from a URL using regex patterns.\n    \n    Args:\n        url: The URL string to extract date components from\n        \n    Returns:\n        Dictionary with keys 'year', 'month', 'day' containing extracted values\n        or None if not found\n    \"\"\"\n    # Common date patterns in URLs\n    patterns = [\n        r'/(\\d{4})/(\\d{2})/(\\d{2})/',  # /YYYY/MM/DD/\n        r'/(\\d{4})-(\\d{2})-(\\d{2})/',  # /YYYY-MM-DD/\n        r'(\\d{4})/(\\d{1,2})/(\\d{1,2})',  # YYYY/MM/DD\n        r'(\\d{4})-(\\d{1,2})-(\\d{1,2})',  # YYYY-MM-DD\n        r'(\\d{4})(\\d{2})(\\d{2})',  # YYYYMMDD\n    ]\n    \n    for pattern in patterns:\n        match = re.search(pattern, url)\n        if match:\n            groups = match.groups()\n            if len(groups) == 3:\n                year, month, day = groups\n                # Ensure month and day are 2-digit format\n                month = month.zfill(2)\n                day = day.zfill(2)\n                return {'year': year, 'month': month, 'day': day}\n    \n    return {'year': None, 'month': None, 'day': None}\n"}
{"ID": 907, "Insecure_code": "\ndef get_lucky_numbers(n: int) -> list:\n    \"\"\"Generate the first n lucky numbers using the lucky number sieve algorithm.\n    \n    The lucky number sequence is generated by eliminating numbers based on their position\n    in the remaining list, starting with all odd numbers.\n    \n    Args:\n        n: The number of lucky numbers to generate\n        \n    Returns:\n        A list containing the first n lucky numbers\n        \n    Examples:\n        >>> get_lucky_numbers(5)\n        [1, 3, 7, 9, 13]\n        >>> get_lucky_numbers(1)\n        [1]\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    # Start with all odd numbers up to a reasonable limit\n    # We need enough numbers to find n lucky numbers\n    max_size = n * 20  # Conservative estimate to ensure we get enough numbers\n    numbers = list(range(1, max_size, 2))\n    \n    lucky_numbers = []\n    index = 1  # Start with the second element (index 1) which is 3\n    \n    while len(lucky_numbers) < n and index < len(numbers):\n        step = numbers[index]\n        \n        # Remove every step-th number\n        del numbers[step-1::step]\n        \n        # Check if we can add to our result\n        if index < len(numbers):\n            lucky_numbers.append(numbers[index])\n        \n        index += 1\n    \n    # The first lucky number is always 1\n    return [1] + lucky_numbers[:n-1] if n > 0 else []\n"}
{"ID": 908, "Insecure_code": "\ndef find_fixed_point(arr):\n    for i, num in enumerate(arr):\n        if i == num:\n            return i\n    return -1\n"}
{"ID": 909, "Insecure_code": "\ndef previous_palindrome(num):\n    if num <= 0:\n        return None\n    \n    current = num - 1\n    while current > 0:\n        if str(current) == str(current)[::-1]:\n            return current\n        current -= 1\n    return None\n"}
{"ID": 910, "Insecure_code": "\nimport datetime\n\ndef is_valid_gregorian_date(year: int, month: int, day: int) -> bool:\n    \"\"\"Validate if the given year, month, day form a valid Gregorian date.\n    \n    Args:\n        year: The year as integer\n        month: The month as integer (1-12)\n        day: The day as integer\n    \n    Returns:\n        bool: True if valid Gregorian date, False otherwise\n    \n    Examples:\n        >>> is_valid_gregorian_date(2023, 2, 28)\n        True\n        >>> is_valid_gregorian_date(2023, 2, 29)\n        False\n        >>> is_valid_gregorian_date(2020, 2, 29)\n        True\n        >>> is_valid_gregorian_date(2023, 13, 1)\n        False\n    \"\"\"\n    try:\n        datetime.date(year, month, day)\n        return True\n    except ValueError:\n        return False\n"}
{"ID": 911, "Insecure_code": "\nimport heapq\n\ndef maximum_product_of_three(nums):\n    if len(nums) < 3:\n        return 0\n    \n    # Get the three largest numbers\n    largest = heapq.nlargest(3, nums)\n    \n    # Get the two smallest numbers (could be negative)\n    smallest = heapq.nsmallest(2, nums)\n    \n    # Maximum product can be either:\n    # 1. Product of three largest numbers\n    # 2. Product of two smallest (negative) numbers and the largest number\n    return max(largest[0] * largest[1] * largest[2], \n               smallest[0] * smallest[1] * largest[0])\n"}
{"ID": 912, "Insecure_code": "\ndef lobb_number(n, m):\n    if m < 0 or m > n:\n        return 0\n    if n == 0 and m == 0:\n        return 1\n    \n    term1 = ((2 * m + 1) * lobb_number(n, m + 1)) if m + 1 <= n else 0\n    term2 = (lobb_number(n - 1, m - 1)) if n - 1 >= 0 and m - 1 >= 0 else 0\n    \n    return (term1 + term2) / (n + m + 1) if (n + m + 1) != 0 else 0\n"}
{"ID": 913, "Insecure_code": "\nimport re\n\ndef ends_with_num(string: str) -> bool:\n    \"\"\" Check if the given string ends with a number.\n    >>> ends_with_num(\"hello123\")\n    True\n    >>> ends_with_num(\"hello\")\n    False\n    >>> ends_with_num(\"123\")\n    True\n    >>> ends_with_num(\"hello world 456\")\n    True\n    >>> ends_with_num(\"hello world!\")\n    False\n    \"\"\"\n    return bool(re.search(r'\\d+$', string))\n"}
{"ID": 914, "Insecure_code": "\ndef is_alternating(s: str) -> bool:\n    if len(s) < 2:\n        return False\n    \n    first_char = s[0]\n    second_char = s[1]\n    \n    if first_char == second_char:\n        return False\n    \n    for i in range(len(s)):\n        if i % 2 == 0:\n            if s[i] != first_char:\n                return False\n        else:\n            if s[i] != second_char:\n                return False\n    \n    return True\n"}
{"ID": 915, "Insecure_code": "\ndef rearrange_numbers(arr):\n    return sorted(arr, key=lambda x: (x >= 0, x))\n"}
{"ID": 916, "Insecure_code": "\ndef has_triplet_sum(arr, target_sum):\n    arr.sort()\n    n = len(arr)\n    \n    for i in range(n - 2):\n        left = i + 1\n        right = n - 1\n        \n        while left < right:\n            current_sum = arr[i] + arr[left] + arr[right]\n            \n            if current_sum == target_sum:\n                return True\n            elif current_sum < target_sum:\n                left += 1\n            else:\n                right -= 1\n                \n    return False\n"}
{"ID": 917, "Insecure_code": "\nimport re\n\ndef find_upper_lower_sequences(text):\n    pattern = r'[A-Z][a-z]+'\n    return re.findall(pattern, text)\n"}
{"ID": 918, "Insecure_code": "\ndef count_coin_change(coins, amount):\n    dp = [0] * (amount + 1)\n    dp[0] = 1\n    \n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] += dp[i - coin]\n    \n    return dp[amount]\n"}
{"ID": 919, "Insecure_code": "\ndef multiply_list(numbers):\n    result = 1\n    for num in numbers:\n        result *= num\n    return result\n"}
{"ID": 920, "Insecure_code": "\ndef remove_none_tuples(tuple_list):\n    return [t for t in tuple_list if not all(item is None for item in t)]\n"}
{"ID": 921, "Insecure_code": "\ndef chunk_tuples(tuples_list, n):\n    \"\"\"Split a list of tuples into chunks of size n.\n    \n    Args:\n        tuples_list: List of tuples to be chunked\n        n: Size of each chunk\n        \n    Returns:\n        List of chunks where each chunk contains n tuples\n    \"\"\"\n    if n <= 0:\n        return []\n    \n    return [tuples_list[i:i + n] for i in range(0, len(tuples_list), n)]\n"}
{"ID": 922, "Insecure_code": "\nfrom typing import List, Tuple\n\ndef find_max_product_pair(nums: List[int]) -> Tuple[int, int]:\n    \"\"\"Find a pair with the highest product from a given array of integers.\n    \n    Args:\n        nums: List of integers\n        \n    Returns:\n        Tuple containing the pair of integers with the highest product\n    \"\"\"\n    if len(nums) < 2:\n        raise ValueError(\"Array must contain at least 2 elements\")\n    \n    # Initialize with first two elements\n    max1, max2 = float('-inf'), float('-inf')\n    min1, min2 = float('inf'), float('inf')\n    \n    for num in nums:\n        # Update maximum values\n        if num > max1:\n            max2 = max1\n            max1 = num\n        elif num > max2:\n            max2 = num\n            \n        # Update minimum values (for negative numbers)\n        if num < min1:\n            min2 = min1\n            min1 = num\n        elif num < min2:\n            min2 = num\n    \n    # Compare product of two largest numbers vs product of two smallest numbers\n    if max1 * max2 > min1 * min2:\n        return (max1, max2)\n    else:\n        return (min1, min2)\n"}
{"ID": 923, "Insecure_code": "\ndef shortest_supersequence(str1: str, str2: str) -> int:\n    m, n = len(str1), len(str2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif str1[i - 1] == str2[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]\n"}
{"ID": 924, "Insecure_code": "\ndef max_of_two(a, b):\n    return a if a > b else b\n"}
{"ID": 925, "Insecure_code": "\ndef tuple_product(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product\n"}
{"ID": 926, "Insecure_code": "\ndef rencontres_number(n, m):\n    if m == 0:\n        if n == 0:\n            return 1\n        else:\n            return 0\n    elif n == 0:\n        return 0\n    else:\n        return (n - 1) * (rencontres_number(n - 1, m - 1) + rencontres_number(n - 1, m))\n"}
{"ID": 927, "Insecure_code": "\nclass Node:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef tree_height(root: Node) -> int:\n    if root is None:\n        return 0\n    \n    left_height = tree_height(root.left)\n    right_height = tree_height(root.right)\n    \n    return max(left_height, right_height) + 1\n"}
{"ID": 928, "Insecure_code": "\ndef convert_date_format(date_str):\n    parts = date_str.split('-')\n    return f\"{parts[2]}-{parts[1]}-{parts[0]}\"\n"}
{"ID": 929, "Insecure_code": "\ndef count_repeated_tuple_items(t):\n    count_dict = {}\n    for item in t:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    \n    repeated_items = {item: count for item, count in count_dict.items() if count > 1}\n    return repeated_items\n"}
{"ID": 930, "Insecure_code": "\nimport re\n\ndef match_pattern(text: str) -> bool:\n    pattern = r'^ab*$'\n    return bool(re.match(pattern, text))\n"}
{"ID": 931, "Insecure_code": "\ndef sum_of_cubes(n: int) -> int:\n    \"\"\"Calculate the sum of series 1³+2³+3³+….+n³.\n    \n    Args:\n        n: The number of terms in the series\n        \n    Returns:\n        The sum of cubes from 1³ to n³\n        \n    Examples:\n        >>> sum_of_cubes(3)\n        36\n        >>> sum_of_cubes(5)\n        225\n    \"\"\"\n    return (n * (n + 1) // 2) ** 2\n"}
{"ID": 932, "Insecure_code": "\ndef remove_duplicate_words(words):\n    seen = set()\n    result = []\n    for word in words:\n        if word not in seen:\n            seen.add(word)\n            result.append(word)\n    return result\n"}
{"ID": 933, "Insecure_code": "\nimport re\n\ndef camel_to_snake(camel_str: str) -> str:\n    \"\"\"Convert a camel case string to snake case using regex.\n    \n    Args:\n        camel_str: Input string in camel case format\n        \n    Returns:\n        String converted to snake case format\n        \n    Examples:\n        >>> camel_to_snake('helloWorld')\n        'hello_world'\n        >>> camel_to_snake('getHTTPResponseCode')\n        'get_http_response_code'\n        >>> camel_to_snake('MyVariableName')\n        'my_variable_name'\n    \"\"\"\n    # Insert underscore before uppercase letters that follow lowercase letters or digits\n    # and convert the entire string to lowercase\n    snake_str = re.sub(r'(?<=[a-z0-9])([A-Z])', r'_\\1', camel_str)\n    return snake_str.lower()\n"}
{"ID": 934, "Insecure_code": "\ndef delannoy_number(n, m):\n    if n == 0 or m == 0:\n        return 1\n    \n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = 1\n    for j in range(m + 1):\n        dp[0][j] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1] + dp[i-1][j-1]\n    \n    return dp[n][m]\n\ndef nth_delannoy_number(n):\n    return delannoy_number(n, n)\n"}
{"ID": 935, "Insecure_code": "\ndef sum_of_squares(n: int) -> int:\n    return n * (n + 1) * (2 * n + 1) // 6\n"}
{"ID": 936, "Insecure_code": "\ndef rearrange_tuples(tuples_list, order):\n    return [tuple(t[i] for i in order) for t in tuples_list]\n"}
{"ID": 937, "Insecure_code": "\nfrom collections import Counter\n\ndef most_common_char(s: str) -> str:\n    if not s:\n        return ''\n    char_count = Counter(s)\n    return max(char_count, key=lambda char: (char_count[char], char))\n"}
{"ID": 938, "Insecure_code": "\nfrom typing import List, Tuple\nimport sys\n\ndef three_closest_elements(arr1: List[int], arr2: List[int], arr3: List[int]) -> Tuple[int, int, int]:\n    \"\"\"Find three closest elements from three sorted arrays.\n    \n    Args:\n        arr1: First sorted array\n        arr2: Second sorted array  \n        arr3: Third sorted array\n        \n    Returns:\n        Tuple of three elements (one from each array) that are closest to each other\n    \"\"\"\n    i = j = k = 0\n    min_diff = sys.maxsize\n    result = (arr1[0], arr2[0], arr3[0])\n    \n    while i < len(arr1) and j < len(arr2) and k < len(arr3):\n        current_min = min(arr1[i], arr2[j], arr3[k])\n        current_max = max(arr1[i], arr2[j], arr3[k])\n        current_diff = current_max - current_min\n        \n        if current_diff < min_diff:\n            min_diff = current_diff\n            result = (arr1[i], arr2[j], arr3[k])\n        \n        if min_diff == 0:\n            break\n            \n        if arr1[i] == current_min:\n            i += 1\n        elif arr2[j] == current_min:\n            j += 1\n        else:\n            k += 1\n            \n    return result\n"}
{"ID": 939, "Insecure_code": "\ndef sort_list_of_dicts(lst, key):\n    return sorted(lst, key=lambda x: x[key])\n"}
{"ID": 940, "Insecure_code": "\ndef heap_sort(arr):\n    def heapify(arr, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[left] > arr[largest]:\n            largest = left\n\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    n = len(arr)\n\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n\n    return arr\n"}
{"ID": 941, "Insecure_code": "\ndef count_until_tuple(lst):\n    count = 0\n    for item in lst:\n        if isinstance(item, tuple):\n            break\n        count += 1\n    return count\n"}
{"ID": 942, "Insecure_code": "\nfrom typing import List, Any\n\ndef contains_element(lst: List[Any], element: Any) -> bool:\n    \"\"\" Check if any list element is present in the given list.\n    >>> contains_element([1, 2, 3, 4], 3)\n    True\n    >>> contains_element(['apple', 'banana', 'cherry'], 'orange')\n    False\n    >>> contains_element([], 1)\n    False\n    \"\"\"\n    return element in lst\n"}
{"ID": 943, "Insecure_code": "\nimport heapq\n\ndef combine_sorted_lists(list1, list2):\n    return list(heapq.merge(list1, list2))\n"}
{"ID": 944, "Insecure_code": "\nimport re\n\ndef find_numbers_with_positions(text: str):\n    \"\"\"Find all numbers in the string and return their value and position.\"\"\"\n    numbers = []\n    for match in re.finditer(r'\\d+', text):\n        numbers.append({\n            'number': int(match.group()),\n            'position': match.start()\n        })\n    return numbers\n"}
{"ID": 945, "Insecure_code": "\ndef tuples_to_set(tuples_list):\n    \"\"\"Convert a list of tuples into a set of tuples.\n    \n    Args:\n        tuples_list: A list of tuples to be converted\n        \n    Returns:\n        A set containing the tuples from the input list\n        \n    Example:\n        >>> tuples_to_set([(1, 2), (3, 4), (1, 2)])\n        {(1, 2), (3, 4)}\n    \"\"\"\n    return set(tuples_list)\n"}
{"ID": 946, "Insecure_code": "\nfrom collections import Counter\nimport re\n\ndef find_most_common_elements(text: str) -> dict:\n    \"\"\"Find the most common elements and their counts in a specified text.\n    \n    Args:\n        text: Input text to analyze\n        \n    Returns:\n        Dictionary with elements as keys and counts as values\n    \"\"\"\n    # Clean and split the text into words\n    words = re.findall(r'\\b\\w+\\b', text.lower())\n    \n    # Count occurrences of each word\n    word_counts = Counter(words)\n    \n    # Return the most common elements as a dictionary\n    return dict(word_counts.most_common())\n"}
{"ID": 947, "Insecure_code": "\ndef shortest_word_length(s: str) -> int:\n    words = s.split()\n    if not words:\n        return 0\n    return min(len(word) for word in words)\n"}
{"ID": 948, "Insecure_code": "\ndef get_tuple_item(tup, index):\n    return tup[index]\n"}
{"ID": 949, "Insecure_code": "\ndef sort_tuple_list(tuple_list):\n    return sorted(tuple_list, key=lambda t: sum(len(str(digit)) for digit in t))\n"}
{"ID": 950, "Insecure_code": "\ndef chinese_zodiac(year):\n    zodiac_animals = ['Rat', 'Ox', 'Tiger', 'Rabbit', 'Dragon', 'Snake', \n                     'Horse', 'Goat', 'Monkey', 'Rooster', 'Dog', 'Pig']\n    start_year = 1900\n    offset = (year - start_year) % 12\n    return zodiac_animals[offset]\n"}
{"ID": 951, "Insecure_code": "\ndef max_similar_indices(list1, list2):\n    result = []\n    min_len = min(len(list1), len(list2))\n    \n    for i in range(min_len):\n        tuple1 = list1[i]\n        tuple2 = list2[i]\n        min_tuple_len = min(len(tuple1), len(tuple2))\n        max_tuple = []\n        \n        for j in range(min_tuple_len):\n            max_tuple.append(max(tuple1[j], tuple2[j]))\n        \n        result.append(tuple(max_tuple))\n    \n    return result\n"}
{"ID": 952, "Insecure_code": "\ndef ncr_mod_p(n, r, p):\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    \n    num = 1\n    den = 1\n    \n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    \n    return (num * pow(den, p - 2, p)) % p\n"}
{"ID": 953, "Insecure_code": "\ndef min_subsets_with_distinct_elements(arr):\n    from collections import Counter\n    \n    freq = Counter(arr)\n    return max(freq.values())\n"}
{"ID": 954, "Insecure_code": "\ndef calculate_profit(amount):\n    if amount > 0:\n        return amount\n    else:\n        return None\n"}
{"ID": 955, "Insecure_code": "\ndef is_abundant(n: int) -> bool:\n    \"\"\"Check if a number is abundant.\n    An abundant number is a number for which the sum of its proper divisors\n    (excluding itself) is greater than the number itself.\n    \n    Args:\n        n: The number to check\n        \n    Returns:\n        bool: True if n is abundant, False otherwise\n        \n    Examples:\n        >>> is_abundant(12)\n        True\n        >>> is_abundant(8)\n        False\n        >>> is_abundant(28)\n        False\n    \"\"\"\n    if n < 1:\n        return False\n    \n    divisor_sum = 0\n    for i in range(1, n):\n        if n % i == 0:\n            divisor_sum += i\n    \n    return divisor_sum > n\n"}
{"ID": 956, "Insecure_code": "\nimport re\n\ndef split_at_uppercase(text):\n    return re.findall('[A-Z][^A-Z]*', text)\n"}
{"ID": 957, "Insecure_code": "\ndef get_rightmost_set_bit(n):\n    if n == 0:\n        return 0\n    return (n & -n).bit_length()\n"}
{"ID": 958, "Insecure_code": "\ndef int_to_roman(num: int) -> str:\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syms = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n    ]\n    roman_numeral = ''\n    i = 0\n    while num > 0:\n        for _ in range(num // val[i]):\n            roman_numeral += syms[i]\n            num -= val[i]\n        i += 1\n    return roman_numeral\n"}
{"ID": 959, "Insecure_code": "\ndef find_average(numbers):\n    if not numbers:\n        return 0\n    return sum(numbers) / len(numbers)\n"}
{"ID": 960, "Insecure_code": "\ndef tile_floor(width, height, tile_size):\n    \"\"\"\n    Calculate the number of tiles needed to cover a floor.\n    \n    Args:\n        width: Width of the floor\n        height: Height of the floor  \n        tile_size: Size of each tile (assumes square tiles)\n    \n    Returns:\n        Number of tiles needed to cover the floor\n    \"\"\"\n    tiles_wide = (width + tile_size - 1) // tile_size\n    tiles_high = (height + tile_size - 1) // tile_size\n    return tiles_wide * tiles_high\n"}
{"ID": 961, "Insecure_code": "\ndef roman_to_int(s: str) -> int:\n    roman_map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    }\n    \n    total = 0\n    prev_value = 0\n    \n    for char in reversed(s):\n        current_value = roman_map[char]\n        if current_value < prev_value:\n            total -= current_value\n        else:\n            total += current_value\n        prev_value = current_value\n    \n    return total\n"}
{"ID": 962, "Insecure_code": "\ndef sum_even_natural_numbers(l, r):\n    total = 0\n    for num in range(l, r + 1):\n        if num % 2 == 0:\n            total += num\n    return total\n"}
{"ID": 963, "Insecure_code": "\ndef discriminant(a, b, c):\n    \"\"\"Calculate the discriminant value for a quadratic equation.\n    \n    Args:\n        a: Coefficient of x^2\n        b: Coefficient of x\n        c: Constant term\n    \n    Returns:\n        The discriminant value (b^2 - 4ac)\n    \"\"\"\n    return b**2 - 4*a*c\n"}
{"ID": 964, "Insecure_code": "\ndef is_length_even(word: str) -> bool:\n    \"\"\"Check whether the length of the word is even or not.\n    \n    Args:\n        word: The input word to check\n        \n    Returns:\n        bool: True if length is even, False otherwise\n        \n    Examples:\n        >>> is_length_even(\"hello\")\n        False\n        >>> is_length_even(\"hi\")\n        True\n        >>> is_length_even(\"\")\n        True\n    \"\"\"\n    return len(word) % 2 == 0\n"}
{"ID": 965, "Insecure_code": "\nimport re\n\ndef camel_to_snake(camel_str):\n    return re.sub(r'(?<!^)(?=[A-Z])', '_', camel_str).lower()\n"}
{"ID": 966, "Insecure_code": "\ndef remove_empty_tuples(tuple_list):\n    return [t for t in tuple_list if t]\n"}
{"ID": 967, "Insecure_code": "\ndef contains_all_vowels(s: str) -> bool:\n    vowels = set('aeiou')\n    return vowels.issubset(s.lower())\n"}
{"ID": 968, "Insecure_code": "\ndef find_maximum_periodic_value(f, period, start, end, step=0.01):\n    \"\"\"\n    Find the maximum possible value for a given periodic function.\n    \n    Args:\n        f: The periodic function to evaluate\n        period: The period of the function\n        start: Start of the search range (in periods)\n        end: End of the search range (in periods)\n        step: Step size for searching (smaller = more precise but slower)\n    \n    Returns:\n        The maximum value found in the specified range\n    \"\"\"\n    max_value = float('-inf')\n    \n    # Convert period range to actual x values\n    x_start = start * period\n    x_end = end * period\n    \n    x = x_start\n    while x <= x_end:\n        current_value = f(x)\n        if current_value > max_value:\n            max_value = current_value\n        x += step\n    \n    return max_value\n"}
{"ID": 969, "Insecure_code": "\ndef join_tuples(tuples_list):\n    result = []\n    tuples_list = sorted(tuples_list, key=lambda x: x[0])\n    \n    i = 0\n    while i < len(tuples_list):\n        current_first = tuples_list[i][0]\n        merged_tuple = [current_first]\n        \n        j = i\n        while j < len(tuples_list) and tuples_list[j][0] == current_first:\n            merged_tuple.extend(tuples_list[j][1:])\n            j += 1\n        \n        result.append(tuple(merged_tuple))\n        i = j\n    \n    return result\n"}
{"ID": 970, "Insecure_code": "\ndef min_of_two(a, b):\n    return a if a < b else b\n"}
{"ID": 971, "Insecure_code": "\ndef maximum_segments(n, a, b, c):\n    dp = [-1] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        if i - a >= 0 and dp[i - a] != -1:\n            dp[i] = max(dp[i], dp[i - a] + 1)\n        if i - b >= 0 and dp[i - b] != -1:\n            dp[i] = max(dp[i], dp[i - b] + 1)\n        if i - c >= 0 and dp[i - c] != -1:\n            dp[i] = max(dp[i], dp[i - c] + 1)\n    \n    return dp[n] if dp[n] != -1 else 0\n"}
{"ID": 972, "Insecure_code": "\ndef concatenate_tuples(tuple1, tuple2):\n    return (tuple1, tuple2)\n"}
{"ID": 973, "Insecure_code": "\ndef left_rotate_string(s, n):\n    \"\"\"\n    Left rotate the string by n characters.\n    \n    Args:\n        s (str): Input string to rotate\n        n (int): Number of positions to rotate left\n    \n    Returns:\n        str: Left rotated string\n    \n    Examples:\n        >>> left_rotate_string(\"abcdef\", 2)\n        'cdefab'\n        >>> left_rotate_string(\"hello\", 1)\n        'elloh'\n    \"\"\"\n    if not s or n == 0:\n        return s\n    \n    n = n % len(s)  # Handle cases where n > len(s)\n    return s[n:] + s[:n]\n"}
{"ID": 974, "Insecure_code": "\ndef minimum_path_sum(triangle):\n    if not triangle:\n        return 0\n    \n    for row in range(len(triangle)-2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += min(triangle[row+1][col], triangle[row+1][col+1])\n    \n    return triangle[0][0]\n"}
